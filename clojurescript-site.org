* About
** Google Closure
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/about/closure.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/about/closure
:CLOJURESCRIPT_SITE_AUTHOR: Rich Hickey
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/about/closure
:END:
*** Motivations for using Google's Closure Tools
  :PROPERTIES:
  :CUSTOM_ID: _motivations_for_using_googles_closure_tools
  :END:

Clojure is nothing if not practical and ClojureScript is no different. As more and more applications target web and mobile environments, the role and reach of JavaScript likewise expands beyond the confines of the browser into even more constrained environments such as mobile with ubiquitous networked paths between nodes. The Google Closure tools provides a robust set of [[http://code.google.com/closure/library/][libraries]], a strong [[http://code.google.com/closure/library/docs/introduction.html#deps][dependency management system]], and a sophisticated [[http://code.google.com/closure/compiler/][compiler]] each working toward an ultimate goal of reducing JavaScript code size. For ClojureScript, Google Closure provides a solution to the "library problem" for JavaScript in three distinct ways:

-  Libraries

-  Dependency management

-  Aggressive code minification

Each of these features represents thousands of hours of research, design, development, and testing. Therefore ClojureScript leverages them in its implementation, allowing the Clojure/core team and contributors to focus on enabling the power of Clojure wherever JavaScript is found.

**** Libraries
   :PROPERTIES:
   :CUSTOM_ID: _libraries
   :END:

ClojureScript is written in Clojure and ClojureScript interoperating with the Google Closure JavaScript libraries. However, ClojureScript can interoperate with *any* JavaScript library or framework. The use of the [[https://developers.google.com/closure/library/docs/overview][Google Closure]] libraries in the ClojureScript core is an implementation strategy allowing us to reduce dependencies and ensure compatibility with advanced mode compilation (see below).

**** Dependency Management
   :PROPERTIES:
   :CUSTOM_ID: _dependency_management
   :END:

Google Closure's dependency management system offers three primitives =addDependency=, =provide=, and =require= that enable compile-time dependency inclusions. ClojureScript encapsulates these, providing access through the =ns= form. This capability is leveraged to allow fine-grained imports and exports of ClojureScript namespaces and functions and also external JavaScript libraries for interoperability purposes.

**** Compiler
   :PROPERTIES:
   :CUSTOM_ID: _compiler
   :END:

Google's Closure Tools provide a [[http://en.wikipedia.org/wiki/Minification_(programming)][minification compiler]] available to the ClojureScript compilation process via command-line flags. In summary, the minification compiler receives generated JavaScript produced by the ClojureScript compiler and renames variables to shorter names, removes whitespace, removes comments, etc. in an effort to reduce the source size while maintaining the program semantics.

***** Dead code analysis
    :PROPERTIES:
    :CUSTOM_ID: _dead_code_analysis
    :END:

[[http://code.google.com/closure/compiler/][Google's Closure compiler]] provides an [[http://code.google.com/closure/compiler/docs/api-tutorial3.html][advanced setting]] allowing a much more aggressive minification strategy than that outlined above. In fact, the Google Closure compiler uses highly sophisticated techniques for identifying and eliminating dead code (i.e. code that is never called nor reachable). The downside of this fact is that the style of the JavaScript code must [[http://code.google.com/closure/compiler/docs/limitations.html][conform to a strict standard]] in order to achieve maximum minification potential. Therefore, it is the goal of the ClojureScript team to ensure that the generated JavaScript code is maximally minifiable through an observance to said idioms and through the use of the Closure libraries and dependency system.

**** Learn More
   :PROPERTIES:
   :CUSTOM_ID: _learn_more
   :END:

[[http://covers.oreilly.com/images/0636920001416/cat.gif]]

The primary reference for the Google Closure tools is O'Reilly's *[[http://oreilly.com/catalog/0636920001416][Closure: The Definitive Guide]]* written by Michael Bolin. This book is highly recommended for anyone hoping to leverage the full power of ClojureScript interoperability, for ClojureScript contributors, and for those simply curious about advanced JavaScript techniques and tools.

** Differences from Clojure
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/about/differences.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/about/differences
:CLOJURESCRIPT_SITE_AUTHOR: Rich Hickey
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/about/differences
:END:

What follows is a section-by-section review of sections on the left-hand navigation panels of [[https://clojure.org/about]] and [[https://clojure.org/reference]], enumerating what is different in ClojureScript and in some cases the similarities.

*** Rationale
  :PROPERTIES:
  :CUSTOM_ID: _rationale
  :END:

The rationale for ClojureScript is much the same as for Clojure, with JavaScript in the role of platform, and additional emphasis on the reach of JS, as it is obviously not as rich a platform.

A [[file:rationale][deeper discussion on ClojureScript's rationale]] can be found elsewhere on this site.

*** State and Identity
  :PROPERTIES:
  :CUSTOM_ID: _state_and_identity
  :END:

Same as Clojure. Clojure's identity model is simpler and more robust than mutable state, even in single threaded environments.

*** Dynamic Development
  :PROPERTIES:
  :CUSTOM_ID: _dynamic_development
  :END:

As with Clojure, ClojureScript supports REPL-driven development, providing easily-launched REPLs for various JavaScript environments. See [[file:xref/../../guides/quick-start][Quick Start]] for details.

Additionally, ClojureScript's self-hosting capability supports extending the dynamic nature to pure JavaScript environments where third-party REPLs and other dynamic facilities can be created.

*** Functional Programming
  :PROPERTIES:
  :CUSTOM_ID: _functional_programming
  :END:

ClojureScript has the same immutable persistent collections as Clojure on the JVM.

*** Lisp
  :PROPERTIES:
  :CUSTOM_ID: _lisp
  :END:

Unlike in Clojure, ClojureScript macro definitions and their use cannot be intermixed in the same compilation stage. See the Macros section below.

*** Runtime Polymorphism
  :PROPERTIES:
  :CUSTOM_ID: _runtime_polymorphism
  :END:

-  ClojureScript protocols have the same semantics as Clojure protocols.

*** Concurrent Programming
  :PROPERTIES:
  :CUSTOM_ID: _concurrent_programming
  :END:

Clojure's model of values, state, identity, and time is valuable even in single-threaded environments.

-  Atoms work as in Clojure

-  No Refs nor STM

-  The user experience of =binding= is similar to that in Clojure

   -  Vars

      -  not reified at runtime

      -  many development time uses of reification are obviated by access to Clojure data structures via the analyzer

   -  =def= produces ordinary JS variables

-  Agents are currently not implemented

*** Hosted on the JVM
  :PROPERTIES:
  :CUSTOM_ID: _hosted_on_the_jvm
  :END:

-  ClojureScript is hosted on JavaScript VMs

-  Optionally, it may use Google's Closure compiler for optimization

-  It is [[file:closure][designed to leverage Google's Closure library]], and participates in its dependency/require/provide mechanism

*** Getting Started
  :PROPERTIES:
  :CUSTOM_ID: _getting_started
  :END:

See [[file:xref/../../guides/quick-start][Quick Start]]

*** The Reader
  :PROPERTIES:
  :CUSTOM_ID: _the_reader
  :END:

-  Numbers

   -  ClojureScript currently only supports integer and floating point literals that map to JavaScript primitives

      -  Ratio, BigDecimal, and BigInteger literals are currently not supported

      -  Equality on numbers works like JavaScript, not Clojure: =(= 0.0 0) ⇒ true=

-  Characters

   -  ClojureScript does not have character literals. Instead characters are the same as in JavaScript (i.e. single-character strings)

-  Lists, Vectors, Maps, and Set literals are the same as in Clojure

-  Macro characters

   -  Because there is no character type in ClojureScript, =\= produces a single-character string.

-  =read=

   -  The =read= and =read-string= functions are located in the =cljs.reader= namespace

*** The REPL and main
  :PROPERTIES:
  :CUSTOM_ID: _the_repl_and_main
  :END:

-  See the [[file:xref/../../guides/quick-start][Quick Start]] for ClojureScript REPL usage.

-  The standard ClojureScript REPLs support the Clojure main pattern.

*** Evaluation
  :PROPERTIES:
  :CUSTOM_ID: _evaluation
  :END:

-  ClojureScript has the same evaluation rules as Clojure

-  =load= exists, but only as a REPL special function

-  =load-file= exists, but only as a REPL special function

-  While Clojure performs locals clearing, ClojureScript does not

*** Special Forms
  :PROPERTIES:
  :CUSTOM_ID: _special_forms
  :END:

The following ClojureScript special forms are identical to their Clojure cousins: =if=, =do=, =let=, =letfn=, =quote=, =loop=, =recur=, =throw=, and =try=.

-  =var= notes

   -  Vars are not reified at runtime. When the compiler encounters the =var= special form it emits a =Var= instance reflecting *compile time* metadata. (This satisfies many common *static* use cases.)

-  =def= notes

   -  =def= produces ordinary JS variables

   -  =:private= metadata is not enforced by the compiler

      -  Private var access triggers an analysis warning

   -  =:const= metadata:

      -  will cause inlining of compile-time static EDN values

      -  causes =case= test constants which are symbols resolving to =^:const= Vars to be inlined with their values

   -  A =def= form evaluates to the value of the init form (instead of the var), unless the =:def-emits-var= compiler option is set (which defaults to =true= for REPLs)

-  =if= notes

   -  the section about Java's boolean boxes is irrelevant in ClojureScript

-  =fn= notes

   -  There is currently no runtime enforcement of arity when calling a fn

-  =monitor-enter=, =monitor-exit=, and =locking= are not implemented

*** Macros
  :PROPERTIES:
  :CUSTOM_ID: _macros
  :END:

ClojureScript's macros must be defined in a different /compilation stage/ than the one from where they are consumed. One way to achieve this is to define them in one namespace and use them from another.

Macros are referenced via the =:require-macros= keyword in namespace declarations:

#+BEGIN_SRC clojure
    (ns my.namespace
      (:require-macros [my.macros :as my]))
#+END_SRC

Sugared and other =ns= variants can be employed in lieu of using the =:require-macros= primitive; see Namespaces below for details.

Macros are written in =*.clj= or =*.cljc= files and are compiled either as Clojure when using regular ClojureScript or as ClojureScript when using bootstrapped / self-host ClojureScript. One point of note is that the code generated by Clojure-based ClojureScript macros must target the capabilities in ClojureScript.

#+BEGIN_QUOTE
  *Note*

  ClojureScript namespaces /can/ require macros from the selfsame namespace, so long as they are kept in different compilation stages. So, for example a =foo.cljs= or =foo.cljc= file can make use of a =foo.cljc= or =foo.clj= file for its macros.
#+END_QUOTE

Unlike in Clojure, in ClojureScript a macro and a function can have the same name (for example the =cljs.core/+= macro and =cljs.core/+= function can coexist).

#+BEGIN_QUOTE
  *Note*

  You may be wondering: “If that's the case, which one do I get?” ClojureScript (unlike Clojure) has two distinct stages that make use of two separate non-interacting namespaces. Macroexpansion occurs first, so a form like =(+ 1 1)= initially involves the =cljs.core/+= macro. On the other hand, in a form like =(reduce + [1 1])=, the =+= symbol is not in operator position, and passes untouched through macroexpansion to analysis/compilation where it is resolved as the =cljs.core/+= function.
#+END_QUOTE

*** Other Functions
  :PROPERTIES:
  :CUSTOM_ID: _other_functions
  :END:

-  printing

   -  =*out*= and =*err*= is currently not implemented

-  regex support

   -  ClojureScript [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp][regular expression support is that of JavaScript]]

-  asserts

   -  In JVM ClojureScript it is not possible to dynamically set =*assert*= to false at runtime. Instead the =:elide-asserts= compiler option must be used to effect elision. (On the other hand, in self-hosted ClojureScript =*assert*= behaves identically to Clojure.)

*** Data Structures
  :PROPERTIES:
  :CUSTOM_ID: _data_structures
  :END:

-  =nil=

   -  While in Clojure, =nil= is identical to Java's =null=, in ClojureScript =nil= is equivalent to JavaScript's =null= and =undefined=.

-  Numbers

   -  Currently ClojureScript numbers are just JavaScript numbers

-  Coercions are not implemented, since there are currently no types to coerce to

-  Characters

   -  JavaScript has no character type. Clojure characters are represented internally as single-character strings

-  Keywords

   -  ClojureScript keywords are not guaranteed to be =identical?=, for fast equality testing use =keyword-identical?=

-  Collections

   -  Persistent collections available

      -  Ports of Clojure's implementations

   -  Transient support in place for persistent vectors, hash maps and hash sets

   -  Most but not all collection fns are implemented

*** Seqs
  :PROPERTIES:
  :CUSTOM_ID: _seqs
  :END:

-  Seqs have the same semantics as in Clojure, and almost all Seq library functions are available in ClojureScript.

*** Protocols
  :PROPERTIES:
  :CUSTOM_ID: _protocols
  :END:

-  =defprotocol= and =deftype=, =extend-type=, =extend-protocol= work as in Clojure

-  Protocols are not reified as in Clojure, there are no runtime protocol objects

-  Some reflective capabilities (=satisfies?=) work as in Clojure

   -  =satisfies?= is a macro and must be passed a protocol name

-  =extend= is not currently implemented

-  =specify=, extend immutable values to protocols - instance level =extend-type= without wrappers

*** Metadata
  :PROPERTIES:
  :CUSTOM_ID: _metadata
  :END:

Works as in Clojure.

*** Namespaces
  :PROPERTIES:
  :CUSTOM_ID: _namespaces
  :END:

Namespaces in ClojureScript are compiled to Google Closure namespaces which are represented as nested JavaScript objects. Importantly this means that namespaces and vars have the potential to clash - however the compiler can detect these problematic cases and will emit a warning when this occurs.

-  You must currently use the =ns= form only with the following caveats

   -  You must use the =:only= form of =:use=

   -  =:require= supports =:as=, =:refer=, and =:rename=

      -  =:refer :all= not supported

      -  all options can be skipped

      -  in this case a symbol can be used as a libspec directly

         -  that is, =(:require lib.foo)= and =(:require [lib.foo])= are both supported and mean the same thing

      -  =:rename= specifies a map from referred var names to different symbols (and can be used to prevent clashes)

      -  [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/require][prefix lists]] are not supported

   -  The only options for =:refer-clojure= are =:exclude= and =:rename=

   -  =:import= is available only for importing Google Closure classes

      -  ClojureScript types and records should be brought in with =:use= or =:require :refer=, not =:import= ed

-  Macros must be defined in a different /compilation stage/ than the one from where they are consumed. One way to achieve this is to define them in one namespace and use them from another. They are referenced via the =:require-macros= / =:use-macros= options to =ns=

   -  =:require-macros= and =:use-macros= support the same forms that =:require= and =:use= do

/Implicit macro loading/: If a namespace is required or used, and that namespace itself requires or uses macros from its own namespace, then the macros will be implicitly required or used using the same specifications. Furthermore, in this case, macro vars may be included in a =:refer= or =:only= spec. This oftentimes leads to simplified library usage, such that the consuming namespace need not be concerned about explicitly distinguishing between whether certain vars are functions or macros. For example:

#+BEGIN_SRC clojure
    (ns testme.core (:require [cljs.test :as test :refer [test-var deftest]]))
#+END_SRC

will result in =test/is= resolving properly, along with the =test-var= function and the deftest macro being available unqualified.

/Inline macro specification/: As a convenience, =:require= can be given either =:include-macros true= or =:refer-macros
[syms…​]=. Both desugar into forms which explicitly load the matching Clojure file containing macros. (This works independently of whether the namespace being required internally requires or uses its own macros.) For example:

#+BEGIN_SRC clojure
    (ns testme.core
      (:require [foo.core :as foo :refer [foo-fn] :include-macros true]
                [woz.core :as woz :refer [woz-fn] :refer-macros [apple jax]]))
#+END_SRC

is sugar for

#+BEGIN_SRC clojure
    (ns testme.core
      (:require [foo.core :as foo :refer [foo-fn]]
                [woz.core :as woz :refer [woz-fn]])
      (:require-macros [foo.core :as foo]
                       [woz.core :as woz :refer [apple jax]]))
#+END_SRC

/Auto-aliasing clojure namespaces/: If a non-existing =clojure.*= namespace is required or used and a matching =cljs.*= namespace exists, the =cljs.*= namespace will be loaded and an alias will be automatically established from the =clojure.*= namespace to the =cljs.*= namespace. For example:

#+BEGIN_SRC clojure
    (ns testme.core (:require [clojure.test]))
#+END_SRC

will be automatically converted to

#+BEGIN_SRC clojure
    (ns testme.core (:require [cljs.test :as clojure.test]))
#+END_SRC

*** Libs
  :PROPERTIES:
  :CUSTOM_ID: _libs
  :END:

Existing Clojure libs will have to conform to the ClojureScript subset in order to work in ClojureScript.

Additionally, macros in Clojure libs must be compilable as ClojureScript in order to be consumable in self-host / bootstrapped ClojureScript via its =cljs.js/*load-fn*= capability.

*** Vars and the Global Environment
  :PROPERTIES:
  :CUSTOM_ID: _vars_and_the_global_environment
  :END:

-  =def= and =binding= work as in Clojure

   -  but on ordinary js variables

   -  Clojure can represent unbound vars. In ClojureScript =(def x)= results in =(nil? x)= being true.

   -  In Clojure, =def= yields the /var itself/. In ClojureScript =def= yields the /value/, unless the REPL option [[file:xref/../../../reference/repl-options#def-emits-var][:def-emits-var]] is set (this defaults to =true= for REPLs).

-  Atoms work as in Clojure

-  Refs and Agents are not currently implemented

-  Validators work as in Clojure

-  =intern= not implemented - no reified Vars

*** Refs and Transactions
  :PROPERTIES:
  :CUSTOM_ID: _refs_and_transactions
  :END:

Refs and transactions are not currently supported.

*** Agents
  :PROPERTIES:
  :CUSTOM_ID: _agents
  :END:

Agents are not currently supported.

*** Atoms
  :PROPERTIES:
  :CUSTOM_ID: _atoms
  :END:

Atoms work as in Clojure.

*** Host Interop
  :PROPERTIES:
  :CUSTOM_ID: _host_interop
  :END:

The host language interop features (=new=, =/=, =.=, etc.) work as in Clojure where possible, e.g.:

#+BEGIN_SRC clojure
    goog/LOCALE
    => "en"

    (let [sb (goog.string.StringBuffer. "hello, ")]
     (.append sb "world")
     (.toString sb))
        => "hello, world"
#+END_SRC

In ClojureScript =Foo/bar= always means that =Foo= is a namespace. It cannot be used for the Java static field access pattern common in Clojure as there's no reflection information in JavaScript to determine this.

The special namespace =js= provides access to global properties:

#+BEGIN_SRC clojure
    js/Infinity
    => Infinity
#+END_SRC

To access object properties (including functions that you want as a value, rather than to execute) use a leading hyphen:

#+BEGIN_SRC clojure
    (.-NEGATIVE_INFINITY js/Number)
    => -Infinity
#+END_SRC

**** Hinting
   :PROPERTIES:
   :CUSTOM_ID: _hinting
   :END:

While =^long= and =^double=---when used on function parameters---are type /declarations/ in Clojure, they are type /hints/ in ClojureScript.

Type hinting is primarily used to avoid reflection in Clojure. In ClojureScript, the only type hint of significance is the =^boolean= type hint: It is used to avoid checked =if= evaluation (which copes with the fact that, for example, =0= and =""= are false in JavaScript and true in ClojureScript).

*** Compilation and Class Generation
  :PROPERTIES:
  :CUSTOM_ID: _compilation_and_class_generation
  :END:

Compilation is different from Clojure:

-  All ClojureScript programs are compiled into (optionally optimized) JavaScript.

-  Individual files can be compiled into individual JS files for analysis of output

-  Production compilation is whole-program compilation via Google Closure compiler

-  =gen-class=, =gen-interface=, etc. are unnecessary and unimplemented in ClojureScript

*** Other Libraries
  :PROPERTIES:
  :CUSTOM_ID: _other_libraries
  :END:

ClojureScript currently includes the following non-core namespaces ported from Clojure:

-  =clojure.set=

-  =clojure.string=

-  =clojure.walk=

-  =clojure.zip=

-  =clojure.data=

-  =clojure.core.reducers=

   -  =fold= is currently an alias for =reduce=

-  =cljs.pprint= (port of =clojure.pprint=)

-  =cljs.spec= (port of =clojure.spec=)

-  =cljs.test= (port of =clojure.test=)

*** Contributing
  :PROPERTIES:
  :CUSTOM_ID: _contributing
  :END:

Clojure and ClojureScript share the same [[https://clojure.org/contributing][Contributor Agreement and development process]].

** Functional Programming
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/about/functional-programming.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/about/functional-programming
:CLOJURESCRIPT_SITE_AUTHOR: Rich Hickey
:CLOJURESCRIPT_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/about/functional-programming
:END:

Clojure is a functional programming language. It provides the tools to avoid mutable state, provides functions as first-class objects, and emphasizes recursive iteration instead of side-effect based looping. Clojure is /impure/, in that it doesn't force your program to be referentially transparent, and doesn't strive for 'provable' programs. The philosophy behind Clojure is that most parts of most programs should be functional, and that programs that are more functional are more robust.

*** First-class functions
  :PROPERTIES:
  :CUSTOM_ID: _first_class_functions
  :END:

[[file:xref/../../reference/special_forms#fn][fn]] creates a function object. It yields a value like any other - you can store it in a var, pass it to functions etc.

#+BEGIN_SRC clojure
    (def hello (fn [] "Hello world"))
    -> #'user/hello
    (hello)
    -> "Hello world"
#+END_SRC

[[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defn][defn]] is a macro that makes defining functions a little simpler. Clojure supports arity overloading in a /single/ function object, self-reference, and variable-arity functions using *&*:

#+BEGIN_SRC clojure
    ;trumped-up example
    (defn argcount
      ([] 0)
      ([x] 1)
      ([x y] 2)
      ([x y & more] (+ (argcount x y) (count more))))
    -> #'user/argcount
    (argcount)
    -> 0
    (argcount 1)
    -> 1
    (argcount 1 2)
    -> 2
    (argcount 1 2 3 4 5)
    -> 5
#+END_SRC

You can create local names for values inside a function using [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/let][let]]. The scope of any local names is lexical, so a function created in the scope of local names will close over their values:

#+BEGIN_SRC clojure
    (defn make-adder [x]
      (let [y x]
        (fn [z] (+ y z))))
    (def add2 (make-adder 2))
    (add2 4)
    -> 6
#+END_SRC

*Locals created with [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/let][let]] are not variables. Once created their values never change!*

*** Immutable Data Structures
  :PROPERTIES:
  :CUSTOM_ID: _immutable_data_structures
  :END:

The easiest way to avoid mutating state is to use immutable [[file:xref/../../reference/data_structures][data structures]]. Clojure provides a set of immutable lists, vectors, sets and maps. Since they can't be changed, 'adding' or 'removing' something from an immutable collection means creating a new collection just like the old one but with the needed change. /Persistence/ is a term used to describe the property wherein the old version of the collection is still available after the 'change', and that the collection maintains its performance guarantees for most operations. Specifically, this means that the new version can't be created using a full copy, since that would require linear time. Inevitably, persistent collections are implemented using linked data structures, so that the new versions can share structure with the prior version. Singly-linked lists and trees are the basic functional data structures, to which Clojure adds a hash map, set and vector both based upon array mapped hash tries. The collections have readable representations and common interfaces:

#+BEGIN_SRC clojure
    (let [my-vector [1 2 3 4]
          my-map {:fred "ethel"}
          my-list (list 4 3 2 1)]
      (list
        (conj my-vector 5)
        (assoc my-map :ricky "lucy")
        (conj my-list 5)
        ;the originals are intact
        my-vector
        my-map
        my-list))
    -> ([1 2 3 4 5] {:ricky "lucy", :fred "ethel"} (5 4 3 2 1) [1 2 3 4] {:fred "ethel"} (4 3 2 1))
#+END_SRC

Applications often need to associate attributes and other data about data that is orthogonal to the logical value of the data. Clojure provides direct support for this [[file:xref/../../reference/metadata][metadata]]. Symbols, and all of the collections, support a metadata map. It can be accessed with the [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/meta][meta]] function. Metadata does /not/ impact equality semantics, nor will metadata be seen in operations on the value of a collection. Metadata can be read, and can be printed.

#+BEGIN_SRC clojure
    (def v [1 2 3])
    (def attributed-v (with-meta v {:source :trusted}))
    (:source (meta attributed-v))
    -> :trusted
    (= v attributed-v)
    -> true
#+END_SRC

*** Extensible Abstractions
  :PROPERTIES:
  :CUSTOM_ID: _extensible_abstractions
  :END:

Clojure uses Java interfaces to define its core data structures. This allows for extensions of Clojure to new concrete implementations of these interfaces, and the library functions will work with these extensions. This is a big improvement vs. hardwiring a language to the concrete implementations of its data types.

A good example of this is the [[file:xref/../../reference/sequences][seq]] interface. By making the core Lisp list construct into an abstraction, a wealth of library functions are extended to any data structure that can provide a sequential interface to its contents. All of the Clojure data structures can provide seqs. Seqs can be used like iterators or generators in other languages, with the significant advantage that seqs are immutable and persistent. Seqs are extremely simple, providing a */first/* function, which return the first item in the sequence, and a */rest/* function which returns the rest of the sequence, which is itself either a seq or nil.

#+BEGIN_SRC clojure
    (let [my-vector [1 2 3 4]
          my-map {:fred "ethel" :ricky "lucy"}
          my-list (list 4 3 2 1)]
      [(first my-vector)
       (rest my-vector)
       (keys my-map)
       (vals my-map)
       (first my-list)
       (rest my-list)])
    -> [1 (2 3 4) (:ricky :fred) ("lucy" "ethel") 4 (3 2 1)]
#+END_SRC

Many of the Clojure library functions produce and consume seqs /lazily/:

#+BEGIN_SRC clojure
    ;cycle produces an 'infinite' seq!
    (take 15 (cycle [1 2 3 4]))
    -> (1 2 3 4 1 2 3 4 1 2 3 4 1 2 3)
#+END_SRC

You can define your own lazy seq-producing functions using the [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/lazy-seq][lazy-seq]] macro, which takes a body of expressions that will be called on demand to produce a list of 0 or more items. Here's a simplified [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/take][take]]:

#+BEGIN_SRC clojure
    (defn take [n coll]
      (lazy-seq
        (when (pos? n)
          (when-let [s (seq coll)]
           (cons (first s) (take (dec n) (rest s)))))))
#+END_SRC

*** Recursive Looping
  :PROPERTIES:
  :CUSTOM_ID: _recursive_looping
  :END:

In the absence of mutable local variables, looping and iteration must take a different form than in languages with built-in /for/ or /while/ constructs that are controlled by changing state. In functional languages looping and iteration are replaced/implemented via recursive function calls. Many such languages guarantee that function calls made in tail position do not consume stack space, and thus recursive loops utilize constant space. Since Clojure uses the Java calling conventions, it cannot, and does not, make the same tail call optimization guarantees. Instead, it provides the [[file:xref/../../reference/special_forms#recur][recur special operator]], which does constant-space recursive looping by rebinding and jumping to the nearest enclosing loop or function frame. While not as general as tail-call-optimization, it allows most of the same elegant constructs, and offers the advantage of checking that calls to recur can only happen in a tail position.

#+BEGIN_SRC clojure
    (defn my-zipmap [keys vals]
      (loop [my-map {}
             my-keys (seq keys)
             my-vals (seq vals)]
        (if (and my-keys my-vals)
          (recur (assoc my-map (first my-keys) (first my-vals))
                 (next my-keys)
                 (next my-vals))
          my-map)))
    (my-zipmap [:a :b :c] [1 2 3])
    -> {:b 2, :c 3, :a 1}
#+END_SRC

For situations where mutual recursion is called for, recur can't be used. Instead, [[http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/trampoline][trampoline]] may be a good option.

** Rationale
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/about/rationale.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/about/rationale
:CLOJURESCRIPT_SITE_AUTHOR: Rich Hickey
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/about/rationale
:END:
*** JavaScript's Reach
  :PROPERTIES:
  :CUSTOM_ID: _javascripts_reach
  :END:

There are many environments (e.g. browsers) in which JavaScript is the only programmable technology. There are others (e.g. mobile) where JavaScript is the most portable development approach. And JavaScript is widely used as an extension or scripting language, e.g. as an extension or indexing language in a database.

*** JavaScript is not Robust
  :PROPERTIES:
  :CUSTOM_ID: _javascript_is_not_robust
  :END:

However, even JavaScript's proponents will acknowledge its shortcomings. There are many dark corners in the language semantics. It is not particularly concise, and it's not well suited for metaprogramming or extension. Most troubling is that writing robust JavaScript programs, while possible, requires a combination of extensive discipline and convention, and conventions differ between development shops, communities and libraries.

*** Client-service Applications are on the Rise
  :PROPERTIES:
  :CUSTOM_ID: _client_service_applications_are_on_the_rise
  :END:

Initial use of JavaScript was oriented towards adding interaction to document/page oriented sites closely aligned to the linked hypertext design of the web. Increasingly JavaScript is being used to construct client-service applications (e.g. Google's apps), where the JavaScript represents an ongoing piece of logic, data, and UI connected to one or more network accessible services. Such applications place much greater demands on their JavaScript hosted portions.

*** JavaScript Engines Gain Power
  :PROPERTIES:
  :CUSTOM_ID: _javascript_engines_gain_power
  :END:

As JavaScript has been called upon to do more and more, JavaScript engines have moved from simple interpreters to quite sophisticated and high performance execution platforms involving native code generation and classic and novel dynamic language optimizations. The engines, in the large, are specifically oriented towards JavaScript semantics and execution, i.e. they are not as general as the JVM and CLR.

*** Google Leads the Way
  :PROPERTIES:
  :CUSTOM_ID: _google_leads_the_way
  :END:

As the leading purveyor of client-service applications, with tremendous resources and a vested interest in web-hosted applications, Google has cutting-edge technology in this area. From the V8 JS engine to the whole-program optimizing symbiotic pair of Closure library and the Closure compiler, Google has open sourced the most advanced technology available in this area. It is worthwhile to understand and leverage what they have provided.

*** The Library Problem
  :PROPERTIES:
  :CUSTOM_ID: _the_library_problem
  :END:

As applications are asked to do more, developers will seek to use more, and larger, libraries. But many of the target platforms are memory constrained, or network connected, and there is much pressure to reduce code size. Minification makes each library smaller, but minification alone still dictates a code size equal to the sum of the minified library sizes. However, applications rarely use all of the code in the libraries they consume. Whole program optimization can be used to construct an application whose code size footprint consists only of the code actually used, regardless of the number or size of the libraries utilized. This is the strategy pursued by the Google Closure library and compiler pair.

*** Opportunity
  :PROPERTIES:
  :CUSTOM_ID: _opportunity
  :END:

A development platform with extensive reach, portability, multi-vendor support, an optimization arms race, sophisticated tools, implemented on all new devices, and a call for richer and more sophisticated applications - what more could developers want? A different language, that's what. While efforts are underway to improve JavaScript, you can't significantly improve something with extensive reach in a timely manner - your improved version won't have the same reach for a long time, if ever. Thus JavaScript /as it currently exists/ is a given, and becomes the target, rather than the source language.

**** ClojureScript
   :PROPERTIES:
   :CUSTOM_ID: _clojurescript
   :END:

ClojureScript seeks to address the weak link in the client/embedded application development story by replacing JavaScript with Clojure, a robust, concise and powerful programming language. In its implementation, ClojureScript adopts the strategy of the Google Closure library and compiler, and is able to effectively leverage both tools, gaining a large, production-quality library and whole-program optimization. ClojureScript brings the rich data structure set, functional programming, macros, reader, destructuring, polymorphism constructs, state discipline and many other features of Clojure to every place JavaScript reaches.

* Community
** Books {amp} Videos
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/books.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/books
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2017-07-06
:CUSTOM_ID: content/community/books
:END:

Please support these fine books and videos about ClojureScript.

*** Books
  :PROPERTIES:
  :CUSTOM_ID: _books
  :END:

| Learn ClojureScript             | [[https://gum.co/learn-cljs][Learn ClojureScript]]\\                                            |
|                                 | by Andrew Meredith\\                                                                            |
|                                 | March 2021                                                                                      |
| Learning ClojureScript          | [[https://www.packtpub.com/web-development/learning-clojurescript][Learning ClojureScript]]\\   |
|                                 | by W. David Jarvis, Rafik Naccache, Allen Rohner\\                                              |
|                                 | June 2016                                                                                       |
| ClojureScript Unraveled         | [[https://leanpub.com/clojurescript-unraveled][ClojureScript Unraveled]]\\                      |
|                                 | by Andrey Antukh and Alejandro Gómez\\                                                          |
|                                 | June 25, 2016                                                                                   |
| Etudes for ClojureScript        | [[https://shop.oreilly.com/product/0636920043584.do][Etudes for ClojureScript]]\\               |
|                                 | by J. Eisenberg\\                                                                               |
|                                 | November 2015                                                                                   |
| ClojureScript: Up and Running   | [[https://amzn.com/1449327435][ClojureScript: Up and Running]]\\                                |
|                                 | by Stuart Sierra, Luke VanderHart\\                                                             |
|                                 | Nov 10, 2012                                                                                    |

*** Videos
  :PROPERTIES:
  :CUSTOM_ID: _videos
  :END:

-  [[https://www.learnreframe.com/][Learn re-frame]]

-  [[https://www.learnreagent.com/][Learn Reagent]]

-  [[https://lambdaisland.com][Lambda Island]]

-  [[https://purelyfunctional.tv][PurelyFunctional.tv]]

-  [[https://shop.oreilly.com/product/0636920040316.do][Learning ClojureScript]]

** Building the compiler
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/building.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/building
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/building
:END:

Make sure you have Maven and at least Java 8 installed. If you don't already have them, use a system specific package manager like =apt-get= or =brew=.

Checkout [[https://github.com/clojure/clojurescript][the git repository]], switch into the checkout and run:

#+BEGIN_SRC sh
    script/build
#+END_SRC

At the end of the build output you will see a line similar to the one below, but with different version numbers.

#+BEGIN_SRC sh
    [INFO] Installing <...>/clojurescript/target/clojurescript-1.7.164-aot.jar to /Users/username/.m2/repository/org/clojure/clojurescript/1.7.164/clojurescript-1.7.164-aot.jar
#+END_SRC

This shows that ClojureScript 1.7.164 has been built, and is installed in your local Maven repo. To use it, specify your ClojureScript dependency as =[org.clojure/clojurescript "1.7.164"]= (but with the version number that you built).

** Dev
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/closure.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/closure
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2018-03-25
:CUSTOM_ID: content/community/closure
:END:
*** Closure Compiler Development
  :PROPERTIES:
  :CUSTOM_ID: closure-compiler-development
  :END:

ClojureScript has deep integration with [[https://github.com/google/closure-compiler][Google Closure Compiler]]. Many ClojureScript features like Node / ES6 modules processing are actually provided through Google Closure Compiler support. In these areas, contribution to ClojureScript is done by contributing directly to the Google Closure compiler project itself.

**** Contributing to Closure Compiler
   :PROPERTIES:
   :CUSTOM_ID: _contributing_to_closure_compiler
   :END:

The Closure compiler team uses GitHub to manage the project and are particularly responsive to issues if they are accompanied by pull requests that provide resolutions. In order to contribute to the Closure Compiler project, you must submit a Google Contributor Agreement.

**** Closure Compiler Development
   :PROPERTIES:
   :CUSTOM_ID: _closure_compiler_development
   :END:

While sparsely documented, the Closure Compiler Java code base is surprisingly approachable. Using a free Java IDE like [[https://www.jetbrains.com/idea/download/][IntelliJ Community Edition]] can greatly simplify exploring and understanding the Closure Compiler source. When locating the source of Closure Compiler bugs, Java IDEs also have the added benefit of robust step debugging tools.

Once you believe you have a fix, create a branch with your fixes and then create a test case.

***** Adding a Test Case to Closure Compiler
    :PROPERTIES:
    :CUSTOM_ID: _adding_a_test_case_to_closure_compiler
    :END:

Find an appropriate test case file for your unit test. To test your specific test you must first build Closure Compiler:

#+BEGIN_EXAMPLE
    mvn clean && mvn -DskipTests -pl externs/pom.xml,pom-main.xml,pom-main-shaded.xml
#+END_EXAMPLE

At this point unless you need to recompile your compiler changes you can simply compile and run your test case which takes less time. In the following replace =TestClass#testMethod= with the class and method that you are testing.

#+BEGIN_EXAMPLE
    mvn -pl pom-main.xml compiler:testCompile surefire:test -Dtest=TestClass#testMethod
#+END_EXAMPLE

Once your tests are passing create a branch if you haven't already with your fixes and submit a pull request. Your pull request should probably be linked to a corresponding GitHub issue.

The final step is to verify that your fix actually addresses the issue in ClojureScript.

***** Testing Closure Compiler against ClojureScript
    :PROPERTIES:
    :CUSTOM_ID: _testing_closure_compiler_against_clojurescript
    :END:

Build Closure Compiler:

#+BEGIN_EXAMPLE
    mvn clean && mvn -DskipTests -pl externs/pom.xml,pom-main.xml,pom-main-unshaded.xml
#+END_EXAMPLE

This will install the unshaded JAR in your local maven, take note of the version. In the ClojureScript repo change the dependency information for the Closure Compiler artifact using whichever tool your prefer (i.e. edit project.clj or deps.edn).

Test that the ClojureScript issue is resolved via a ClojureScript specific test.

** Companies
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/companies.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/companies
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-02-24
:CUSTOM_ID: content/community/companies
:END:

Below is a partial list of some companies using ClojureScript. To add your company to the list, please submit a pull request to the [[https://github.com/clojure/clojurescript-site][ClojureScript.org repository]].

-  [[https://www.8thlight.com][8th Light]]

-  [[https://www.active-group.de/][Active Group]]

-  [[https://www.adaptly.com][Adaptly]]

-  [[https://www.adgoji.com][AdGoji]]

-  [[https://adzerk.com/][Adzerk]]

-  [[https://www.againtelligent.com/en/][AGA]]

-  [[https://akvo.org/][Akvo]]

-  [[https://journals.aps.org/][American Physical Society]]

-  [[https://attendify.com/][Attendify]]

-  [[https://audio.audyx.com/][Audyx]]

-  [[https://www.balboa.io][Balboa]]

-  [[https://www.bevuta.com/][bevuta]]

-  [[https://www.bgpworks.com][BGPworks]]

-  [[https://www.billfront.com/][BillFront]]

-  [[https://www.blossom.co][Blossom]]

-  [[https://en.booctin.com][Booctin']]

-  [[https://www.brightnorth.co.uk][Bright North]]

-  [[https://www.brightin.nl][Brightin]]

-  [[https://levelmoney.com][Capital One/Level Money]]

-  [[https://carouselapps.com/][Carousel Apps]]

-  [[https://www.cenx.com][CENX]]

-  [[https://cicayda.com/][cïcayda]]

-  [[https://circleci.com][CircleCI]]

-  [[https://www.threatgrid.com][Cisco]]

-  [[https://www.cognesys.de][cognesys]]

-  [[https://www.cognician.com][Cognician]]

-  [[https://cognitect.com][Cognitect]]

-  [[https://www.condense.com.au/][Condense]]

-  [[https://www.consumerreports.org/][Consumer Reports]]

-  [[https://www.cybershopsystems.com][Cybershop Systems]]

-  [[https://www.cycognito.com][CyCognito]]

-  [[https://democracy.works/][Democracy Works]]

-  [[https://designed.ly/][Designed.ly]]

-  [[https://dive-networks.com][DIVE Networks]]

-  [[https://www.doctronic.de][doctronic.de]]

-  [[https://scholars.duke.edu][Duke University]]

-  [[https://www.ebay.com][eBay]]

-  [[https://www.vakantiediscounter.nl][Elmar Reizen B.V.]]

-  [[https://www.facjure.com][Facjure]]

-  [[https://fikesfarm.com/cc/][FikesFarm]] (iOS app)

-  [[https://fincite.com][Fincite]]

-  [[https://flexiana.com][Flexiana]]

-  [[https://floatingpoint.io/][Floating Point]]

-  [[https://www.formcept.com/][Formcept]]

-  [[https://framed.io][Framed Data]]

-  [[https://freshcodeit.com][Freshcode]]

-  [[https://jobs.functionalworks.com][Functional Works]]

-  [[https://www.fundingcircle.com][Funding Circle]]

-  [[https://www.getcontented.com.au][GetContented]] (for content editor, not on public site)

-  [[https://www.goizper.com/][Goizper Group]]

-  [[https://greative.jp/][Greative]]

-  [[https://hvac.io][HVAC.IO]]

-  [[https://www.hendrickauto.com][Hendrick Automotive Group]] (not on public site - yet)

-  [[https://hexawise.com/][Hexawise]]

-  [[https://hostelrocket.com][Hostel Rocket]]

-  [[https://www.intelie.com.br][Intelie]] (not on public site)

-  [[https://intentmedia.com][Intent Media]]

-  [[https://juxt.pro][Intent Media]]

-  [[https://keminglabs.com][Keming Labs]]

-  [[https://www.kontor.com][Kontor]]

-  [[https://kirasystems.com][Kira Systems]]

-  [[https://lifebooker.com][Lifebooker]]

-  [[https://lightmesh.com][LightMesh]]

-  [[https://www.loyal3.com/][Loyal3]] (only certain parts of public site, transition in progress)

-  [[https://lucidit.consulting][Lucid IT Consulting]]

-  [[https://www.magnet.coop][Magnet]]

-  [[https://www.mttmarket.com/][MTTMarket]]

-  [[https://www.mastodonc.com/][Mastodon C]] (Not on public site, however)

-  [[https://welcome.mayvenn.com/hello][Mayvenn]]

-  [[https://mazira.com/][Mazira]]

-  [[https://what.meewee.com][MeeWee]]

-  [[https://metail.com/][Metail]]

-  [[https://www.metosin.fi][Metosin]]

-  [[https://modnakasta.ua/][modnaKasta]]

-  [[https://www.mphasis.com/][Mphasis]]

-  [[https://welcome.thenavisway.com/][NAVIS]]

-  [[https://www.nemcv.com/][NemCV]] - [[https://www.zubairquraishi.com/zubairquraishi/case-study---nemcv.html][Details]]

-  [[https://www.nws.ai][Newsroom AI]]

-  [[https://nextjournal.com][Nextjournal]]

-  [[https://nubank.com.br][Nubank]]

-  [[https://nukomeet.com][Nukomeet]]

-  [[https://numerical.co.nz][Numerical Brass Computing]]

-  [[https://obsidian-innovations.com/][Obsidian Innovations]]

-  [[https://omnimemory.com/][Omnimemory]] [[https://www.omnyway.com][Omnyway]] - [[https://github.com/omnyway-labs][Github]]

-  [[https://company.ona.io][Ona]]

-  [[https://opensensors.io/][OpenSensors]]

-  [[https://www.orkli.com/en][Orkli]]

-  [[https://oursky.com][Oursky]]

-  [[https://www.outpace.com/][Outpace]]

-  [[https://www.pros.com/][PROS]]

-  [[https://paddleguru.com][PaddleGuru]]

-  [[https://pandanet-igs.com/][Pandanet]]

-  [[https://pitch.com/][Pitch]]

-  [[https://postspectacular.com/][PostSpectacular]]

-  [[https://precursorapp.com/][Precursor]]

-  [[https://practitest.com/][PractiTest]]

-  [[https://getprismatic.com/home][Prismatic]]

-  [[https://www.purposefly.com/][PurposeFly]]

-  [[https://qficonsulting.com][QFI Consulting LLP]]

-  [[https://racehubhq.com][RaceHub]]

-  [[https://rackspace.com][Rackspace]]

-  [[https://www.radi8.co.uk][Radi8.co.uk]]

-  [[https://www.recurse.com][Recurse Center]]

-  [[https://www.redradix.com][Redradix]]

-  [[https://rentpath.com/][RentPath]]

-  [[https://www.repairtechsolutions.com/][RepairTech]]

-  [[https://www.roomstorm.com][Roomstorm]]

-  [[https://scivera.com][SciVera]] (Not on public site, however)

-  [[https://serenova.com][Serenova]]

-  [[https://www.shareablee.com][Shareablee]]

-  [[https://www.sinapsi.com/][Sinapsi]]

-  [[https://sistemimoderni.com][Sistemi Moderni]]

-  [[https://www.smartchecker.de/][SmartChecker]]

-  [[https://smeebi.com][Smeebi]]

-  [[https://smxemail.com/][SMX]] (Not on public site, however)

-  [[https://socialsuperstore.com][Social Superstore]]

-  [[https://www.solita.fi/in-english/][Solita]]

-  [[https://www.sparrho.com][Sparrho]]

-  [[https://www.squarevenue.com][SquareVenue]]

-  [[https://status.im/][Status]]

-  [[https://www.studyflow.nl][Studyflow]]

-  [[https://www.style.com/][Style.com]]

-  [[https://shop.stylefruits.de][stylefruits]]

-  [[https://suprematic.net][Suprematic]]

-  [[https://open.mediaexpress.reuters.com][Thomson Reuters]]

-  [[https://www.twosigma.com][Two Sigma]]

-  [[https://www.uhn.ca/][University Health Network]]

-  [[https://www.upworthy.com][Upworthy]]

-  [[https://www.uswitch.com][uSwitch]]

-  [[https://www.vincit.com][Vincit]]

-  [[https://vitallabs.co][Vital Labs]]

-  [[https://vouch.io/][Vouch.io]]

-  [[https://workframe.com][Workframe]]

-  [[https://yetanalytics.com][Yet Analytics]]

-  [[https://xnlogic.com][XN Logic]]

-  [[https://www.zenfinance.com.br/][Zen Finance]]

-  [[https://zensight.co/][Zensight]]

-  [[https://zignal.co/][Zignal]]

-  [[https://devblog.zimpler.com/blog/2015/08/12/clojurescript-from-zero-to-production-part-1/][Zimpler]]

** Contributing to ClojureScript
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/contributing.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/contributing
:CLOJURESCRIPT_SITE_AUTHOR: Rich Hickey
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/contributing
:END:
*** Ways to Contribute
  :PROPERTIES:
  :CUSTOM_ID: _ways_to_contribute
  :END:

There are many ways to make a meaningful contribution to the ClojureScript community:

-  Advocate for the use of ClojureScript in your organization

-  Use ClojureScript and share your experience via talks, blogs, etc

-  Start or join a local meetup

-  Help new ClojureScript users in Slack or other forums

-  Create or provide patches to open source libraries

-  Create or improve ClojureScript tools

-  Write guides or reference documentation for libraries

-  Write intros or getting started guides for tools

-  Create ClojureScript podcasts, screencasts, or videos

-  Give a talk at a conference

-  Write an article or book

-  Start a ClojureScript podcast

-  Test alpha or beta releases of ClojureScript on your code base and provide feedback

**** Editing this Site
   :PROPERTIES:
   :CUSTOM_ID: _editing_this_site
   :END:

If you are writing a guide, making an event, or creating a resource, please consider contributing to this web site, clojurescript.org. All of the content is [[https://github.com/clojure/clojurescript-site][stored in GitHub]] and pull requests and issues are accepted. For more information on how to contribute, see the page on [[file:contributing_site][contributing to the site]]. Every page has a link to the corresponding source file in the bottom right corner. If you have an idea for a new guide or updated documentation, please [[https://github.com/clojure/clojurescript-site/issues][file an issue]] for discussion.

*** Reporting Problems and Requesting Enhancements
  :PROPERTIES:
  :CUSTOM_ID: _reporting_problems_and_requesting_enhancements
  :END:

The Clojure team provides a [[https://clojure.org/community/ask][forum]] where users can ask questions, submit potential problems, and request enhancements to Clojure, ClojureScript, or Clojure contrib libraries. For all of these cases, please ask a question on the [[https://ask.clojure.org][forum]]. Mark the question with tag =problem= for potential problems and =request= for enhancements. The community and core team will assess the issue and determine whether to file an issue in the jira tracker. If an issue is filed, the link will be added to the question and it will be tagged with =jira=.

If you are looking to provide feedback on an issue in jira, please search the [[https://ask.clojure.org][forum]] for the equivalent issue by title and add your feedback there as an "answer" instead.

The development teams for these languages and libs will use the question votes to prioritize their work in jira towards the next release.

*** Making a contribution
  :PROPERTIES:
  :CUSTOM_ID: _making_a_contribution
  :END:

If you have a proposal for ClojureScript, please post it as a question on [[https://ask.clojure.org]] using the ClojureScript category and label it =request=. ClojureScript developers will help you determine whether this idea is a good fit for ClojureScript and a patch is wanted. If you would prefer to have a real time discussion before investing in a more considered proposal, the #cljs-dev [[https://clojurians.slack.com/][Clojurians Slack]] channel is very active.

If the ClojureScript developers indicate this is a useful thing to do, please follow the [[https://clojure.org/dev/dev][process]] to become a contributor. This requires signing the Contributor Agreement and requesting access to the ClojureScript jira account.

*** Contributor Agreement
  :PROPERTIES:
  :CUSTOM_ID: _contributor_agreement
  :END:

Following the lead of other open source projects, the ClojureScript project requires contributors to jointly assign their copyright on contributed code. The [[https://secure.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor Agreement]] (CA) gives Rich Hickey and the contributor joint copyright interests in the code: the contributor retains copyrights while also granting those rights to Rich Hickey as the open source project sponsor.

The CA is derived from the Oracle Contributor Agreement (OCA), used for OpenJDK, Netbeans and OpenSolaris projects and others. There is a good [[https://www.oracle.com/technetwork/oca-faq-405384.pdf][OCA FAQ]] answering many questions.

The CA does not change the rights or responsibilities of the Clojure community under the [[https://opensource.org/licenses/eclipse-1.0.php][Eclipse Public License (EPL)]]. By executing the CA, contributors protect the Clojure code base, enable alternative licensing models, and protect the flexibility to adapt the project to the changing demands of the community. In order for the CA to be effective, the Clojure project must obtain an assignment for all contributions. Please review the CA for a complete understanding of its terms and conditions. By contributing source code or other material to Clojure, you represent that you have a CA with Rich Hickey for such contributions. In order to track contributors, you understand that your full name and username may be posted on a web page listing authorized contributors that is accessible via a public URL.

*** Instructions for submitting the agreement
  :PROPERTIES:
  :CUSTOM_ID: _instructions_for_submitting_the_agreement
  :END:

Fill out and submit the [[https://secure.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor Agreement]] (an online e-form)

Please see the [[https://clojure.org/community/contributing][Contributing]] page for a collection of resources on tickets, builds, patches, source, and more. If you'd like to submit a patch, please follow these guidelines on the [[https://clojure.org/community/workflow][preferred process for submitting]].

/*Many thanks for your contributions to ClojureScript!*/

** Contributing to This Site
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/contributing_site.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/contributing_site
:CLOJURESCRIPT_SITE_AUTHOR: Alex Miller
:CLOJURESCRIPT_SITE_DATE: 2015-08-01
:CUSTOM_ID: content/community/contributing_site
:END:

This web site is an open-source repository of content about the ClojureScript programming language and its greater ecosystem, hosted at [[https://clojurescript.org]].

If you wish to point out an issue in the site or propose a new page, you can do so by filing a GitHub issue at [[https://github.com/clojure/clojurescript-site/issues]].

If you wish to make a contribution (typo, modification, or new content), you must become a contributor and use the processes described below:

-  [[contributor][How To Become a Contributor]]

-  [[minor][Submitting Small Changes]]

-  [[major][Submitting Large Changes]]

-  [[build][Building and Previewing Changes]]

-  [[style][Style and Navigation Changes]]

-  [[review][How Contributions are Reviewed and Deployed]]

*** How To Become a Contributor
  :PROPERTIES:
  :CUSTOM_ID: contributor
  :END:

Contributors must sign the Clojure Contributor Agreement prior to submitting changes. The [[https://secure.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor Agreement]] (CA) gives Rich Hickey and the contributor joint copyright interests: the contributor retains copyrights while also granting those rights to Rich Hickey as the open source project sponsor.

The CA is derived from the Oracle Contributor Agreement (OCA), used for OpenJDK, Netbeans and OpenSolaris projects and others. There is a good [[https://www.oracle.com/technetwork/oca-faq-405384.pdf][OCA FAQ]] answering many questions.

By executing the CA, contributors protect the ClojureScript site content and protect the flexibility to adapt the project to the changing demands of the community. In order for the CA to be effective, the ClojureScript project must obtain an assignment for all contributions. Please review the CA for a complete understanding of its terms and conditions. By contributing source code or other material to ClojureScript, you represent that you have a CA with Rich Hickey for such contributions. In order to track contributors, you understand that your full name and username may be posted on a web page listing authorized contributors that is accessible via a public URL.

To complete the agreement, fill out and submit the [[https://secure.echosign.com/public/hostedForm?formid=95YMDL576B336E][Contributor Agreement]] (an online e-form).

Note that if you have already signed the Clojure Contributor Agreement to supply patches to the ClojureScript source code, you do not need to sign it again as it is the same agreement.

*** Submitting Small Changes
  :PROPERTIES:
  :CUSTOM_ID: minor
  :END:

Small changes can be proposed directly in the GitHub web interface:

1. Go to the content repository [[https://github.com/clojure/clojurescript-site]]

2. Navigate to the page you wish to update under content/ - the url should match the file base name. For example, this file's content is at [[https://github.com/clojure/clojurescript-site/blob/master/content/community/contributing_site.adoc]].

3. Click the edit (pencil) icon.

4. Content is written using the asciidoc format, which is similar to Markdown. The [[file:editing][Editing]] page lists examples of the most common things you will encounter when editing content on this site. Make your changes in the text box. You can preview your changes using the "Preview changes" tab. GitHub understands asciidoc format and will provide a formatted preview of your changes.

5. Write a concise description of the change in the bottom section of the page then click "Propose file change". This will fork the original repository into your own version of the repository with the change applied.

6. You will then be shown a "Comparing changes" page - all of the information should be filled out automatically and a summary of your changes will be at the bottom - this is a good time to look them over one more time. Assuming it all looks correct, you can propose the change back to the original repository by clicking "Create pull request". You'll then be able to add a comment to the pull request itself then click "Create pull request".

*** Submitting Large Changes
  :PROPERTIES:
  :CUSTOM_ID: major
  :END:

#+BEGIN_QUOTE
  *Important*

  For any major changes, *please* open an [[https://github.com/clojure/clojurescript-site/issues][issue]] first and discuss the change before spending time on it.
#+END_QUOTE

If you are going to create an entirely new page or make significant changes requiring multiple commits, you will likely find it easier to work using command line tools.

To create a local environment for working on a bigger change:

1. Fork the content repository [[https://github.com/clojure/clojurescript-site]] - this will create a version of the site content under your own user id.

2. =git clone= the forked repository in your local terminal and =cd clojurescript-site=.

3. =git checkout -b <branchname>= - create a new branch to work on your change. You'll use this branch to submit a pull request.

4. Make one or more commits on this branch, modifying or adding one or more files. See the section below on how to build and preview changes locally. The [[file:editing][Editing]] page lists examples of the most common things you will encounter when editing content on this site.

5. Use =git push= to push your changes to the branch.

6. Go to https://github.com/username/clojurescript-site/tree/branchname.

7. Click the green button to "Compare, review, and create a pull request" and proceed through the prompts to submit the pull request.

To actively contribute to the site, it's important to keep your own fork up-to-date with this repository. To do that:

1. Add this repository to your remote urls: =git remote add upstream https://github.com/clojure/clojurescript-site.git=.

2. Before every contribution:

   -  fetch the content of upstream: =git fetch upstream= ;

   -  move to your master branch: =git checkout master= (in case you aren't already there);

   -  clean your master branch of any unplanned modifications by reseting the HEAD to the fetched branch: =git reset --hard upstream/master=; and

   -  create a new branch as explained above: =git checkout -b <branchname>=

*** Building and Previewing Changes
  :PROPERTIES:
  :CUSTOM_ID: build
  :END:

When working on bigger changes it's useful to build the site locally. The site is built using [[https://jbake.org/][JBake]].

To [[https://jbake.org/docs/2.5.0/#installation][install]] JBake 2.5.0-SNAPSHOT:

1. =curl -O http://cdn.cognitect.com/clojurescript.org/jbake-2.5.0-SNAPSHOT-bin.zip= (or download this file with your browser)

2. =unzip -o jbake-2.5.0-SNAPSHOT-bin.zip=

3. Add jbake-2.5.0-SNAPSHOT/bin to your system PATH

To build the site:

Retrieve the content:

1. =git clone https://github.com/clojure/clojurescript-site.git= (or your own fork)

2. =cd clojurescript-site=

Retrieve and install the current theme assets (these don't change very often so you don't need to do this every time):

1. =curl -O https://clojurescript.org/cljstheme.zip= (or download this file with your browser to the clojurescript-site directory)

2. =unzip -o cljstheme.zip=

Generate the pages:

#+BEGIN_QUOTE
  Note that =jbake= 2.5.0 requires Java 8. (It will not run properly under Java 9.)
#+END_QUOTE

1. =jbake= - this will create the static site in the output directory

2. To view the static files, open =output/index= in your browser

3. To view a live preview, run =jbake -s= and go to [[https://localhost:8820/index]]

*** Style and Navigation Changes
  :PROPERTIES:
  :CUSTOM_ID: style
  :END:

We are not currently looking for changes in the overall site styling, navigation, or infrastructure. There is ongoing work in that area that will be visible in the near future.

If you have an issue in these areas, please open an [[https://github.com/clojure/clojurescript-site/issues][issue]] rather than a pull request.

*** How Contributions are Reviewed and Deployed
  :PROPERTIES:
  :CUSTOM_ID: review
  :END:

After submitting a pull request, a contribution will be waiting for review.

For each pull request, one more of the reviewers will take action:

-  Mark the comment with the Reviewed label. This indicates the reviewer approves of the changes and requests that an Editor merges those changes.

-  Comment on the pull request suggesting additional changes. You may address these changes with further commits on your local branch.

-  Close the pull request with a comment indicating why the change is not appropriate.

*** Thanks!
  :PROPERTIES:
  :CUSTOM_ID: _thanks
  :END:

Thanks for your contributions!

*** Terms of Use
  :PROPERTIES:
  :CUSTOM_ID: _terms_of_use
  :END:

Copyright © 2015 Rich Hickey and contributors

All documentation contained in this repository is licensed by Rich Hickey under the [[https://www.eclipse.org/legal/epl-v10.html][Eclipse Public License v1.0]] unless otherwise noted.

** Custom REPLs
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/custom-repls.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/custom-repls
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/custom-repls
:END:

This page documents recent changes to requirements for custom REPLs that use the functionality provided in [[https://github.com/clojure/clojurescript/blob/master/src/main/clojure/cljs/repl.cljc][cljs.repl]]. These changes have been made towards the goal of dramatically diminishing the start time of /all/ ClojureScript REPLs and simplifying the synchronization of REPL state with compiled source. This is accomplished by reusing the globally available compilation caching infrastructure. In fact it is currently possible to launch a REPL with =:output-dir= set to an existing compilation cache and incur no analysis or compilation.

Under the new infrastructure all the builtin REPLs are capable of booting on modern hardware in a second or less.

*** Expectations
  :PROPERTIES:
  :CUSTOM_ID: expectations
  :END:

In order to boot REPLs as quickly as possible REPLs must implement the new 2-arg arity of =-setup= which take the typical compiler build options. In the past =-setup= was permitted to be asynchronous - this is no longer supported, REPLs must now compile and load cljs.core and all of its dependencies during =-setup=. In =-setup= REPLs should use the build options to cache compiled JavaScript and analysis information to the expected location. Note, while it is OK to stream compiled forms the user has entered this should be avoided at all costs for loading namespaces - REPLs should rely on the target environment to interpret =goog.require=. This has many benefits including precise source mapping information.

The new Node.js REPL is a good example of the [[https://github.com/clojure/clojurescript/blob/master/src/main/clojure/cljs/repl/node.clj#L69][new pattern]]. The Node.js REPL is short because it relies on the Node.js runtime itself to interpret =goog.require=.

Examining =cljs.repl/load-file= and =cljs.repl/load-namespace= will clarify the new approach:

-  Given a namespace ensure that it's compiled.

-  Compute the =goog.addDependency= string for the file and evaluate it.

-  Emit =goog.require= statement for the namespace and evaluate it.

REPLs should override the global =CLOSURE_IMPORT_SCRIPT= function to get custom =goog.require= behavior.

*** Eliminating Loaded Libs tracking
  :PROPERTIES:
  :CUSTOM_ID: eliminating-loaded-libs-tracking
  :END:

Under the new changes REPLs no longer need to bother with explicitly tracking loaded libs directly within their Clojure implementation. Instead, REPLs should arrange to ensure that the JavaScript evaluation environment honors =cljs.core/loaded-libs=, embedding the required logic in =CLOSURE_IMPORT_SCRIPT= if need be.

History: This was only previously done because =goog.provide= throws if the namespace has already been loaded. This is a completely bogus error intended to teach "beginners". By monkey-patching =goog.isProvided_= to be a function that always returns false - the error can be suppressed. Again the Node.js REPL is a good example of such patching as well as honoring =loaded-libs= in the =CLOSURE_IMPORT_SCRIPT= implementation.

*** Special Functions
  :PROPERTIES:
  :CUSTOM_ID: special-functions
  :END:

All REPLs support several "special functions". Special functions must take the REPL environment, an analysis environment, the form, and (optionally) compiler build options. Out of the box =in-ns=, =require=, =load-file=, and =load-namespace= are provided.

*** Output
  :PROPERTIES:
  :CUSTOM_ID: output
  :END:

Custom REPLs should not call =println=, =print=, or =flush= directly, but should instead honor values associated with =:print=, =:print-no-newline=, and =:flush= in the =opts= (second argument) passed to =-setup=. Also note that the functions associated with =:print= and =:print-no-newline= take exactly one argument.

*** Source Mapping
  :PROPERTIES:
  :CUSTOM_ID: source-mapping
  :END:

All REPLs can now implement a new protocol in order to get source mapping support for "free". In the case of an =:exception= result from evaluation the REPL infrastructure will invoke =-parse-stacktrace= if the REPL evaluation environment satisfies =cljs.repl/IParseStacktrace=. The REPL evaluation environment will receive the original JavaScript stacktrace string, the entire original error value, as well as all build options passed into the REPL. The REPL evaluation environment may then return a canonical stacktrace which must take the form of:

#+BEGIN_SRC clojure
    [{:function <string>
      :file <string>
      :line <integer>
      :column <integer>}*]
#+END_SRC

=:file= must be a URL style path (forward slashes) without a URI protocol relative to =:output-dir=.

With [[https://github.com/clojure/clojurescript/commit/de15ba8f756457f9cb4f5758848147911665e56b][this commit]], the contract has been relaxed slightly to accommodate REPL-defined functions: The =:file= value may begin with =<= to indicate that no source is present, and ="NO_SOURCE_FILE"= will be emitted in the trace.

Custom REPLs may still want to further customize or control printing of stacktraces. A hook is provided, the REPL evaluation environment may implement =cljs.repl/IPrintStacktrace=. =-print-stacktrace= takes the mapped canonical stacktrace, the entire original error value, and all build options passed to the REPL.

** Dev
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/dev.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/dev
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/dev
:END:
*** Contributing
  :PROPERTIES:
  :CUSTOM_ID: contributing
  :END:

ClojureScript is developed using the same [[https://clojure.org/dev/dev][Contributor Agreement and development process]] as Clojure.

*** Dev Docs
  :PROPERTIES:
  :CUSTOM_ID: dev-docs
  :END:

-  [[https://clojure.atlassian.net/browse/CLJS][Bugs and feature status]]

-  [[file:building][Building the Compiler]]

-  [[file:patches][Patches]]

-  [[file:running-tests][Running the Tests]]

-  [[file:closure][Closure Compiler Development]]

-  [[file:custom-repls][Custom REPLs]]

-  [[file:xref/../../../reference/bootstrapping][Bootstrapping the Compiler]]

** Editing
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/editing.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/editing
:CLOJURESCRIPT_SITE_AUTHOR: Alex Miller
:CLOJURESCRIPT_SITE_DATE: 2015-09-29
:CUSTOM_ID: content/community/editing
:END:

This page covers helpful Asciidoc editing tips for writing content on this site. It does not cover every feature of Asciidoc, just the ones that have come up most commonly while writing content on this site.

*** File metadata
  :PROPERTIES:
  :CUSTOM_ID: _file_metadata
  :END:

Every file should start with a metadata block that looks like this:

#+BEGIN_EXAMPLE
    = Mechanical Computing
    Ada Lovelace
    2015-12-31
    :jbake-type: page
    :toc: macro
#+END_EXAMPLE

The first lines indicate the title, author, and creation date. The last two lines are necessary boilerplate metadata attributes.

*** Headers
  :PROPERTIES:
  :CUSTOM_ID: _headers
  :END:

*** h2
  :PROPERTIES:
  :CUSTOM_ID: _h2
  :END:

#+BEGIN_EXAMPLE
    == h2
#+END_EXAMPLE

**** h3
   :PROPERTIES:
   :CUSTOM_ID: _h3
   :END:

#+BEGIN_EXAMPLE
    === h3
#+END_EXAMPLE

***** h4
    :PROPERTIES:
    :CUSTOM_ID: _h4
    :END:

#+BEGIN_EXAMPLE
    ==== h4
#+END_EXAMPLE

*** Text markup
  :PROPERTIES:
  :CUSTOM_ID: _text_markup
  :END:

| markup                    | effect                |
|---------------------------+-----------------------|
| \_italic\_                | /italic/              |
| *bold*                    | *bold*                |
| \_**italic and bold**\_   | /*italic and bold*/   |
| `inline code`             | =inline code=         |
| (C) (R) (TM)              | © ® ™                 |
| -- ...                    |  --- ...​             |
| -> simpara>               | → ← ⇒ ⇐               |

To get a line break without a paragraph change, append + to the end of the line:

#+BEGIN_EXAMPLE
    force +
    line break
#+END_EXAMPLE

force\\
line break

If you have many lines in a row that will need breaks you can prefix them with [%hardbreaks]:

#+BEGIN_EXAMPLE
    [%hardbreaks]
    first line
    second line
#+END_EXAMPLE

first line\\
second line

There are a number of ways to handle escaping in Asciidoc but one of the most helpful is to omit all formatting by using:

#+BEGIN_EXAMPLE
    pass:[*ns*]
#+END_EXAMPLE

*ns*

*** Links
  :PROPERTIES:
  :CUSTOM_ID: _links
  :END:

Create an anchor in a page:

#+BEGIN_EXAMPLE
    [[dot]]
#+END_EXAMPLE

Link to another internal page (note the trailing # after the page - this is required in our generator!):

#+BEGIN_EXAMPLE
    <<resources#,Resources>>
#+END_EXAMPLE

[[file:resources][Resources]]

There is a bug in the parser used in the current version of JBake for links to a page in a parent directory. For example, to link to a page at ../reference/java\_interop.adoc, you can use a link like this:

#+BEGIN_EXAMPLE
    <<xref/../../reference/java_interop#,Java Interop>>
#+END_EXAMPLE

This goes to a (fictitious) subdirectory xref, then back a directory, and then finally the path you wish to follow. While the choice of "xref" here is arbitrary, please use only this string so that we can more easily find and update these upward cross references later when there is a version that fixes this issue.

Link to an anchor in an internal page:

#+BEGIN_EXAMPLE
    <<resources#books,Books>>
#+END_EXAMPLE

[[file:resources#books][Books]]

Link to an external page:

#+BEGIN_EXAMPLE
    https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defn[defn]
#+END_EXAMPLE

[[https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defn][defn]]

*** Images
  :PROPERTIES:
  :CUSTOM_ID: _images
  :END:

Images should be placed in the assets/images/content directory in a subdirectory corresponding to the page location.

Reference the image in a page as follows:

#+BEGIN_EXAMPLE
    image::/images/content/reference/transducers/xf.png[Nested transformations]
#+END_EXAMPLE

[[/images/content/reference/transducers/xf.png]]

*** Code blocks
  :PROPERTIES:
  :CUSTOM_ID: _code_blocks
  :END:

You can insert a Clojure formatted code block as follows:

#+BEGIN_EXAMPLE
    [source,clojure]
    ----
    (defn hey
      []
      (println "hey"))
    ----
#+END_EXAMPLE

#+BEGIN_SRC clojure
    (defn hey
      []
      (println "hey"))
#+END_SRC

*** Lists
  :PROPERTIES:
  :CUSTOM_ID: _lists
  :END:

There are a lot of options for creating lists. Only the most common ones are shown here:

Bulleted lists:

#+BEGIN_EXAMPLE
    * first
    * second
    ** nested
    *** more nested
#+END_EXAMPLE

-  first

-  second

   -  nested

      -  more nested

Ordered lists:

#+BEGIN_EXAMPLE
    . a
    . b
    .. b.1
    ... b.1.a
#+END_EXAMPLE

1. a

2. b

   1. b.1

      1. b.1.a

Mixed lists:

#+BEGIN_EXAMPLE
    * a
    . a.1
    . a.2
    * b
    . b.1
    . b.2
#+END_EXAMPLE

-  a

   1. a.1

   2. a.2

-  b

   1. b.1

   2. b.2

Use the line break advice from the text formatting section to create lists with multi-line items.

*** Tables
  :PROPERTIES:
  :CUSTOM_ID: _tables
  :END:

Tables are another large Asciidoc topic with extensive formatting options. This is a basic table example however:

#+BEGIN_EXAMPLE
    [options="header"]
    |===
    | col1 | col2
    | a | b
    | b | c
    |===
#+END_EXAMPLE

| col1   | col2   |
|--------+--------|
| a      | b      |
| b      | c      |

*** Other
  :PROPERTIES:
  :CUSTOM_ID: _other
  :END:

Horizontal rule:

#+BEGIN_EXAMPLE
    ''''
#+END_EXAMPLE

Insert table of contents, which should generally be done at the top of your file (the page template will position this appropriately):

#+BEGIN_EXAMPLE
    toc::[]
#+END_EXAMPLE

*** More resources
  :PROPERTIES:
  :CUSTOM_ID: _more_resources
  :END:

Asciidoc is an extensive language and there is likely some way to do anything you want to do. Below are some more Asciidoc resources to answer more advanced questions.

-  [[https://powerman.name/doc/asciidoc][Asciidoc cheat sheet]]

-  [[https://asciidoctor.org/docs/user-manual][Asciidoctor user manual]]

** ClojureScript Libraries
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/libraries.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/libraries
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/libraries
:END:
*** Compatible Clojure Contrib libraries
  :PROPERTIES:
  :CUSTOM_ID: compatible-clojure-contrib-libraries
  :END:

-  [[https://github.com/clojure/core.async][core.async]], Communicating Sequential Processes

-  [[https://github.com/clojure/core.logic][core.logic]], miniKanren implementation

-  [[https://github.com/clojure/core.match][core.match]], Efficient pattern matching

-  [[https://github.com/clojure/core.rrb-vector][core.rrb-vector]], concatenation and non-view slicing for vectors

-  [[https://github.com/clojure/data.avl][data.avl]], sorted maps and sets with O(log n) rank queries and splits

-  [[https://github.com/clojure/test.check][test.check]], QuickCheck style property based testing

-  [[https://github.com/clojure/tools.reader][tools.reader]], portable Clojure(Script) reader

*** Libraries
  :PROPERTIES:
  :CUSTOM_ID: _libraries
  :END:

**** Dom Manipulation
   :PROPERTIES:
   :CUSTOM_ID: _dom_manipulation
   :END:

-  [[https://github.com/levand/domina][domina]], DOM utilities

-  [[https://github.com/Prismatic/dommy][dommy]], DOM utilities

-  [[https://github.com/aaronc/freactive][freactive]], reactive DOM library

**** React Wrappers
   :PROPERTIES:
   :CUSTOM_ID: _react_wrappers
   :END:

-  [[https://github.com/omcljs/om/][om]], React bindings and state management

-  [[https://github.com/Prismatic/om-tools][om-tools]], Om extensions

-  [[https://github.com/reagent-project/reagent][reagent]], React bindings

-  [[https://github.com/yogthos/reagent-forms][reagent-forms]], Forms for Reagent

-  [[https://github.com/levand/quiescent][quiescent]], React bindings

-  [[https://github.com/active-group/reacl][reacl]], React bindings

-  [[https://github.com/tonsky/rum][rum]], React bindings

-  [[https://github.com/weavejester/brutha][brutha]] Simple ClojureScript interface to React

-  [[https://github.com/r0man/sablono][sablono]] Hiccup style wrapper for React DOM Elements

-  [[https://github.com/bhauman/cljs-react-reload][cljs-react-reload]] Writing reloadable React Classes

-  [[https://github.com/Lokeh/helix][helix]] Modern React development with low runtime overhead

-  [[https://roman01la.gitbook.io/uix][uix]] Idiomatic interface into modern React

**** HTML Templating
   :PROPERTIES:
   :CUSTOM_ID: _html_templating
   :END:

-  [[https://github.com/r0man/sablono][sablono]], Hiccup style HTML generation for React

-  [[https://github.com/framed-data/sablono-tools][sablono-tools]], Enlive-style selector-based templating and transformations for Sablono

-  [[https://github.com/ckirkendall/kioo][kioo]], Enlive style HTML generation

-  [[https://github.com/jeluard/hipo/][hipo]], Hiccup style templating

-  [[https://github.com/ckirkendall][enfocus]], Enlive templating for ClojureScript

-  [[https://github.com/davidsantiago/hickory][hickory]] parses HTML into Hiccup vectors

-  [[https://github.com/rauhs/hicada][hicada]] macro-based Hiccup compiler for React

**** CSS Generation
   :PROPERTIES:
   :CUSTOM_ID: _css_generation
   :END:

-  [[https://github.com/noprompt/garden][garden]], CSS generation

-  [[https://github.com/facjure/mesh][mesh]], Responsive Grid & Typography library built on Garden

-  [[https://github.com/azizzaeny/boot-atomizer][boot-atomizer]], Parse and Generate Atomic CSS === Graphics

-  [[https://github.com/liebke/apogee][apogee]] SVG charting

-  [[https://github.com/kovasb/gamma][gamma]] GLSL DSL

-  [[https://clojars.org/quil][quil]], Processing for Clojure & ClojureScript

-  [[https://github.com/thi-ng/geom][Geometry primitives, mesh operations, SVG & WebGL rendering]]

-  [[https://github.com/thi-ng/color][Color space conversion & manipulation]]

-  [[https://github.com/thi-ng/tweeny][Interpolation of arbitrary nested value maps]]

**** Client-side Routing
   :PROPERTIES:
   :CUSTOM_ID: _client_side_routing
   :END:

-  [[https://github.com/gf3/secretary][secretary]], Routing

-  [[https://github.com/juxt/bidi][bidi]], Routing

-  [[https://github.com/DomKM/silk][silk]], Routing

**** Networking
   :PROPERTIES:
   :CUSTOM_ID: _networking
   :END:

-  [[https://github.com/ashercoren/klozzer][klozzer]], Http Caching and File System Api with core.async

-  [[https://github.com/viebel/s3-cljs][s3-cljs]], aws s3 sdk wrapper

-  [[https://github.com/ptaoussanis/sente][sente]], core.async + websockets

-  [[https://github.com/JulianBirch/cljs-ajax][cljs-ajax]] simple Ajax client for ClojureScript

-  [[https://github.com/r0man/cljs-http][cljs-http]] a ClojureScript HTTP library

-  [[https://github.com/jeluard/happy]]) a Clojure(Script[happy] HTTP async client library

-  [[https://github.com/diligenceengine/clj-browserchannel][clj-browserchannel]] Real-time, bi-directional communication between ClojureScript and Clojure

-  [[https://github.com/james-henderson/chord][chord]], core.async + WebSockets

-  [[https://github.com/crisptrutski/matchbox]]), Firebase client for Clojure(Script[matchbox]

**** Data formats
   :PROPERTIES:
   :CUSTOM_ID: _data_formats
   :END:

-  [[https://github.com/cognitect/transit-cljs][transit-cljs]], efficient, extensible data exchange format

**** Datastores
   :PROPERTIES:
   :CUSTOM_ID: _datastores
   :END:

-  [[https://github.com/tonsky/datascript][datascript]], Datomic-like in-memory database

-  [[https://github.com/ghubber/konserve][konserve]], KV store protocol

-  [[https://github.com/dialelo/hodgepodge][hodgepodge]] A idiomatic interface to local and session storage

-  [[https://thi.ng/trio]]) Non-RDF triplestores & SPARQL like query engine (CLJX[thi.ng/trio]

**** iOS/Android
   :PROPERTIES:
   :CUSTOM_ID: _iosandroid
   :END:

-  [[https://github.com/omcljs/ambly][Ambly]]

-  [[https://github.com/drapanjanas/re-natal][re-natal]]

-  [[https://github.com/mfikes/goby][goby]]

**** FRP
   :PROPERTIES:
   :CUSTOM_ID: _frp
   :END:

-  [[https://github.com/weavejester/reagi][reagi]] An FRP library for Clojure and ClojureScript

-  [[https://github.com/jamesmacaulay/zelkova][zelkova]] Elm-style FRP for Clojure and ClojureScript

-  [[https://github.com/Day8/re-frame][re-frame]] A Reagent Framework For Writing SPAs, in Clojurescript.

**** Misc
   :PROPERTIES:
   :CUSTOM_ID: _misc
   :END:

-  [[https://github.com/purnam/purnam][purnam]] is a clojurescript library designed to provide better clojurescript/javascript interop, testing and documentation tools to the programmer.

-  [[https://github.com/funcool/cuerdas][cuerdas]], string manipulation

-  [[https://github.com/prismatic/schema][schema]], Validation & contracts

-  [[https://github.com/pleasetrythisathome/bardo][bardo]], transitions

-  [[https://github.com/jeluard/lucuma/][lucuma]], WebComponents

-  [[https://github.com/Skinney/differ][differ]], data structure diffing

-  [[https://github.com/quile/component-cljs][component-cljs]], port of Stuart Sierra's Component library

-  [[https://github.com/niwibe/cats][cats]], Monads

-  [[https://github.com/immoh/lively][lively]], Client-side live programming support

-  [[https://wilker-dev.com/patterny/][patterny]], Extract imagine patterns

-  [[https://github.com/spellhouse/phalanges][phalanges]], Keyboard events

-  [[https://github.com/piranha/keybind][keybind]], Key bindings

-  [[https://github.com/andrewmcveigh/cljs-time]]), Date/time lib (almost[cljs-time] consistent API with clj-time

-  [[https://github.com/jamesmacaulay/cljs-promises][cljs-promises]], Promises

-  [[https://github.com/yogthos/markdown-clj][markdown-clj]] extensible Clojure/Script Markdown parser

-  [[https://github.com/yogthos/json-html][json-html]] generates a DOM node with a human representation of the JSON/EDN encoded data

-  [[https://github.com/reagent-project/historian]]) a drop-in atom-state-management (UNDOs!![historian] for your clojurescript projects

-  [[https://github.com/thi-ng/validate]]) Schema based validation of nested data (CLJX[thi.ng/validate]

-  [[https://github.com/rbrush/clara-rules][clara]] Rete-based rule engine

**** Testing
   :PROPERTIES:
   :CUSTOM_ID: _testing
   :END:

-  [[https://github.com/clojure/clojurescript/blob/master/src/main/cljs/cljs/test.cljs][cljs.test]], a port of clojure.test built-in to the standard library

-  DEPRECATED: [[https://github.com/cemerick/clojurescript.test][clojurescript.test]] a port of clojure.test that pre-dates the built-in version

-  [[https://github.com/spellhouse/clairvoyant][clairvoyant]], tracing

-  [[https://purnam.github.io/purnam/#purnam-test][purnam.test]], provides macros for testing with the karma test runner, works with async tests.

-  [[https://github.com/slagyr/speclj][speclj]] A TDD/BDD framework for Clojure and Clojurescript, based on RSpec.

** License
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/license.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/license
:CLOJURESCRIPT_SITE_AUTHOR: Rich Hickey
:CLOJURESCRIPT_SITE_DATE: 2015-01-01
:CUSTOM_ID: content/community/license
:END:

The use and distribution terms for this software are covered by the [[https://opensource.org/licenses/eclipse-1.0.php][Eclipse Public License 1.0]], which can be found in the file epl-v10.html at the root of this distribution. By using this software in any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any other, from this software.

** Patches
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/patches.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/patches
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/patches
:END:
*** Creating patches
  :PROPERTIES:
  :CUSTOM_ID: creating-patches
  :END:

Make a branch off master and write the code for the patch and commit it. Please write the commit message starting with =CLJS-NNNN: TICKET TITLE=, followed by an empty line, followed by a few sentences explaining the changes. Please squash multiple commits into a single commit. Then produce the patch with the following:

#+BEGIN_SRC sh
    git format-patch master --stdout > CLJS-NNNN.patch
#+END_SRC

*** Testing patches
  :PROPERTIES:
  :CUSTOM_ID: testing-patches
  :END:

In order to test ClojureScript patches in your own project, apply the patch to a local clone of the ClojureScript repo. Run =script/build=, this will install a version of ClojureScript - note the version number. Change your projects =:dependencies= to use this version number and confirm the patch works for you.

*** Submitting patches
  :PROPERTIES:
  :CUSTOM_ID: submitting-patches
  :END:

Attach =CLJS-NNNN.patch= to the associated JIRA ticket, providing additional commentary that may be useful for understanding the patch.

If submitting follow-on patches in order to address comments raised during review or defects found in a patch, name them =CLJS-NNNN-2.patch=, =CLJS-NNNN-3.patch=, and so on. Subsequent patches should be stand-alone (squashed and not dependent on earlier patches).

Edit the ticket's Patch field to indicate either "Code" or "Code and Test". This makes it easier for others to find patches in need of review (appearing in the [[https://clojure.atlassian.net/issues/?filter=10017][CLJS Screenable]] preset filter).

*** A note about patches for Windows files
  :PROPERTIES:
  :CUSTOM_ID: a-note-about-patches-for-windows-files
  :END:

Patches that modify files with Windows line endings may fail to apply. Running =git am --keep-cr < /path/to/CLJS-NNNN.patch= will generally apply the patch if it would otherwise apply cleanly (*i.e.* no merge conflicts).

** Reporting Bootstrap Issues
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/reporting-bootstrap-issues.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/reporting-bootstrap-issues
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/reporting-bootstrap-issues
:END:
*** Ticket Entry
  :PROPERTIES:
  :CUSTOM_ID: ticket-entry
  :END:

Please enter issues with self-hosted / bootstrapped ClojureScript

-  marked as having Minor priority

-  title prefixed with "Self-host: "

-  marked with =bootstrap= label

*** Minimal Repro
  :PROPERTIES:
  :CUSTOM_ID: minimal-repro
  :END:

Do not rely on downstream bootstrapped environments to report or demonstrate issues.

Oftentimes, a new unit test can be written that fails when =script/test-self-parity= is run. (This runs the compiler unit tests, but in a bootstrap environment).

Otherwise, reproduction steps generally need to involve minimal code that exercises =cljs.js=, demonstrating the issue.

Frequently it is possible to do this with a couple of lines in a REPL. Here is an example exercising the =cljs.js/eval-str= API by simply issuing a couple forms in the shipping Node REPL:

#+BEGIN_SRC sh
    $ clj -M -m cljs.main cljs.repl.node
    To quit, type: :cljs/quit
    cljs.user=> (require 'cljs.js)
    nil
    cljs.user=> (cljs.js/eval-str (cljs.js/empty-state)
      "(+ 1 2)" nil {:eval cljs.js/js-eval :context :expr} prn)
    {:ns cljs.user, :value 3}
    nil
#+END_SRC

For more complex situations, reproduction could involve additional code, or even a new self-host unit test that exhibits the problem. Information on self-host unit tests is [[file:running-tests][here]].

** Reporting Issues
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/reporting-issues.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/reporting-issues
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/reporting-issues
:END:

To report an issue please file a question on [[https://ask.clojure.org][ask.clojure.org]] under the ClojureScript category and tag it with =problem=. CLJS developers can assess and determine whether it is an issue. If needed, they can file a ticket in the [[https://clojure.atlassian.net/browse/CLJS][ClojureScript issue tracker]].

It's important that before submitting any issue that you have a thorough understanding of the [[file:xref/../../../guides/quick-start][Quick Start]] first. Even if you are an experienced ClojureScript developer this is required reading.

It's helpful, but not essential, to first check the [[https://clojure.atlassian.net/browse/CLJS][existing bug reports]], the [[https://groups.google.com/forum/#!forum/clojurescript][mailing list]], or the Freenode #clojurescript IRC channel or Slack channels and ensure that the issue hasn't been reported before.

Also, it can be helpful to ensure that you are running the latest released version of ClojureScript. Also, checking against ClojureScript master is prudent---frequently when bugs are found, fixes are quickly committed (see instructions below).

It is essential, however, to report the bug using ClojureScript only. Downstream tooling often interacts with the ClojureScript compiler in non-trivial ways, and the best way to isolate the issue to ClojureScript is to remove them from the report altogether.

Please report issues by building the uberjar from master and using this to verify the issue. Using [[https://clojurescript.org/reference/repl-and-main][=cljs.main=]] with this uberjar to create a minimal repro is ideal. Alternatively, using [[https://clojure.org/guides/getting_started][=clj=]] and =deps.edn= is acceptable. Do not use any other 3rd party tooling (Maven, Leiningen, Boot). When creating issues please add all relevant instructions and code to reproduce to the ticket directly or via additional comments. Please do not attach projects, links to projects, links to gists / pastebins, or zips.

#+BEGIN_QUOTE
  *Note*

  Bootstrap issues may require special consideration. Please see [[file:reporting-bootstrap-issues][Reporting Bootstrap Issues]] for more details.
#+END_QUOTE

*** Building the uberjar from master
  :PROPERTIES:
  :CUSTOM_ID: building-the-uberjar-from-master
  :END:

Make a checkout of the ClojureScript repository. From the root of the project run the following:

#+BEGIN_SRC sh
    ./script/uberjar
#+END_SRC

This will create =target/cljs.jar=.

*** Installing from master
  :PROPERTIES:
  :CUSTOM_ID: installing-from-master
  :END:

When verifying issues it may be useful to first check that the issue has not already been resolved in master. /Do not report issues using this method, it's only for convenience when verifying master yourself/. Make a checkout of the ClojureScript repository. From the root of the project run the following:

#+BEGIN_SRC sh
    ./script/build
#+END_SRC

This will install ClojureScript into your local Maven. Make note of the version when it scrolls by. Use this as appropriate for your tooling.

*** Pinpointing Regressions with git bisect
  :PROPERTIES:
  :CUSTOM_ID: pinpointing-regressions-with-git-bisect
  :END:

If you've discovered a regression, it is helpful to identify information regarding the first bad commit when reporting issues. This is easy to do by first depending on a checkout of ClojureScript as a local root dependency and then using =git bisect=.

For this example, let's say you've discovered a regression that is reproducible directly in the REPL (variations on the below can be employed if not).

First checkout ClojureScript master and =cd= to the top of the checkout tree.

Assuming you can reproduce the issue on master, but that things worked with ClojureScript 1.10.748, issue these commands at the top of the checkout tree:

#+BEGIN_SRC sh
    git bisect start
    git bisect bad HEAD
    git bisect good r1.10.748
#+END_SRC

Then (in another directory) start up a REPL against the current state of the checkout tree by issuing:

#+BEGIN_SRC sh
    clj -Srepro -Sdeps '{:deps {org.clojure/clojurescript {:local/root "/<path-to-checkout>/clojurescript"}}}' -m cljs.main -r
#+END_SRC

Test to see if you can reproduce the issue in the REPL and then exit the REPL.

If you couldn't reproduce the problem, issue this in the ClojureScript checkout tree:

#+BEGIN_SRC sh
    git bisect good
#+END_SRC

Or, if you were able to reproduce the problem:

#+BEGIN_SRC sh
    git bisect bad
#+END_SRC

If the bisect is complete, =git= will indicate that a certain commit hash "is the first bad commit." Copy all of this text for JIRA.

Otherwise restart the REPL and repeat the above steps until done.

When finished, you can issue this to restore your ClojureScript checkout:

#+BEGIN_SRC sh
    git bisect reset
#+END_SRC

** Community Resources
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/resources.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/resources
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/resources
:END:
*** Tutorials
  :PROPERTIES:
  :CUSTOM_ID: tutorials
  :END:

-  [[https://github.com/magomimmo/modern-cljs][modern-cljs]]

-  [[https://funcool.github.io/clojurescript-unraveled/][ClojureScript Unraveled]] (book)

-  [[https://clojurescriptmadeeasy.com/][ClojureScript Made Easy]] (blog)

-  [[https://github.com/bhauman/lein-figwheel/wiki/Quick-Start][Getting started with Figwheel]]

-  [[https://github.com/vvvvalvalval/reagent-phonecat-tutorial/wiki][Reagent Phonecat]] : official AngularJS 1.X tutorial, re-written for ClojureScript + Reagent.

*** Learning Tools
  :PROPERTIES:
  :CUSTOM_ID: learning-tools
  :END:

-  [[https://replete-repl.org][Replete]] ClojureScript REPL iOS, macOS, and Android app

-  [[https://planck-repl.org][Planck]] Stand-alone ClojureScript REPL for macOS and Linux

-  [[https://github.com/priyatam/replify][Replify]] Standalone Clojurescript REPL and minimalist build tool

-  [[https://github.com/princejwesley/Mancy][Mancy]] Electron based NodeJS REPL with ClojureScript Support + (Data Visualisation, Transpiled JS View & more...)

*** Online Clojurescript REPLs
  :PROPERTIES:
  :CUSTOM_ID: online-clojurescript-repls
  :END:

-  [[https://app.klipse.tech][KLIPSE]]

-  [[https://clojurescript.io/][clojurescript.io]]

-  [[https://clojurescript.net/][clojurescript.net]]

*** Getting Help
  :PROPERTIES:
  :CUSTOM_ID: getting-help
  :END:

**** Chat
   :PROPERTIES:
   :CUSTOM_ID: chat
   :END:

-  IRC: =#clojurescript= on [[https://freenode.net/][freenode.net]]

-  Slack: =#clojurescript= on [[https://clojurians.slack.com/][Clojurians Slack]] ([[https://clojurians.net/][get an invite here]])

   -  searchable chat logs can be found [[https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/clojurescript][here]], and [[https://clojurians-log.clojureverse.org/][here]]

-  Zulip: =#clojurescript= on [[https://clojurians.zulipchat.com/#narrow/stream/151762-clojurescript][Clojurians Zulip Chat]]

**** Mailing Lists
   :PROPERTIES:
   :CUSTOM_ID: mailing-lists
   :END:

-  [[https://groups.google.com/group/clojurescript][ClojureScript user mailing list]]

-  [[https://groups.google.com/group/clojure][Clojure mailing list]]

**** Feedback
   :PROPERTIES:
   :CUSTOM_ID: feedback
   :END:

ClojureScript does not take pull requests. Please follow the links below to contribute to ClojureScript.

-  [[https://clojure.atlassian.net/browse/CLJS][Bug Reports]]

-  [[https://archive.clojure.org/design-wiki/display/design/Home.html][Design Docs archive]]

-  [[https://groups.google.com/group/clojure-dev][Dev Mailing List]] - membership restricted to those who have submitted a signed [[https://clojure.org/dev/contributor_agreement][Clojure CA]] (Contributor Agreement)

-  [[https://groups.google.com/group/clojurescript][ClojureScript Mailing List]]

-  Become a [[https://clojure.org/dev/contributor_agreement][Contributor]]

** Running the Tests
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/community/running-tests.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/community/running-tests
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/community/running-tests
:END:
*** Testing the Compiler Infrastructure
  :PROPERTIES:
  :CUSTOM_ID: testing-the-compiler-infrastructure
  :END:

#+BEGIN_SRC sh
    lein test
#+END_SRC

Will run the tests for the analyzer, compiler, and closure components.

*** Testing JavaScript Engines
  :PROPERTIES:
  :CUSTOM_ID: testing-javascript-engines
  :END:

How to setup the important JavaScript runtimes.

**** Google V8
   :PROPERTIES:
   :CUSTOM_ID: google-v8
   :END:

Follow [[https://v8.dev/docs/build][Google V8 checkout and build instructions]].

Set the V8\_HOME environment variable to the path where [[https://v8.dev/docs/d8][d8]] was built, for example:

=export V8_HOME="$HOME/v8/out/x64.release"=

Verify via:

=echo quit | $V8_HOME/d8=

**** Mozilla SpiderMonkey
   :PROPERTIES:
   :CUSTOM_ID: spidermonkey
   :END:

Get the JavaScript shell (jsshell) from [[https://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-central/]]. Set your SPIDERMONKEY\_HOME environment variable to installation location.

Verify via:

=$SPIDERMONKEY_HOME/js --version=

**** WebKit JavaScriptCore
   :PROPERTIES:
   :CUSTOM_ID: javascriptcore
   :END:

On macOS we test with JavaScriptCore. JavaScriptCore (jsc) should be on your system, but needs to be added to your =PATH= environment variable so that it will be found, for example:

=export PATH="$PATH:/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources"=

Verify that =jsc= brings up a prompt.

**** Java Nashorn
   :PROPERTIES:
   :CUSTOM_ID: nashorn
   :END:

Setup the =$NASHORN_HOME= environment variable so that

=$NASHORN_HOME/jjs=

prompts a JavaScript Console. Nashorn is usually under =$JAVA_HOME/bin=, so you can write:

=export NASHORN_HOME="$JAVA_HOME/bin"=

Verify via:

=echo 'quit()' | $NASHORN_HOME/jjs -fv=

**** Oracle GraalVM
   :PROPERTIES:
   :CUSTOM_ID: graalvm
   :END:

Get GraalVM from [[https://www.graalvm.org]]. Set your GRAALVM\_HOME environment variable so that =$GRAALVM_HOME/js= executes Graal.js.

Verify via:

=$GRAALVM_HOME/js --version=

**** Microsoft ChakraCore
   :PROPERTIES:
   :CUSTOM_ID: chakracore
   :END:

Get ChakraCore from [[https://github.com/Microsoft/ChakraCore/releases]]. Set your CHAKRACORE\_HOME environment variable so that =$CHAKRACORE_HOME/ch= executes ChakraCore.

Verify via:

=$CHAKRACORE_HOME/ch -version=

**** Setting up dependencies
   :PROPERTIES:
   :CUSTOM_ID: setting-up-dependencies
   :END:

#+BEGIN_SRC sh
    ./script/bootstrap
#+END_SRC

**** Running the tests
   :PROPERTIES:
   :CUSTOM_ID: running-the-tests
   :END:

#+BEGIN_SRC sh
    ./script/test
#+END_SRC

Will run tests for each JavaScript runtime that you setup as described above, runtimes that you did not setup will be skipped.

**** Running bootstrapped ClojureScript tests
   :PROPERTIES:
   :CUSTOM_ID: running-bootstrapped-clojurescript-tests
   :END:

If you have Node.js installed, you can run the bootstrapped ClojureScript test suite (located at =src/test/self/self_host/test.cljs=):

#+BEGIN_SRC sh
    ./script/test-self-host
#+END_SRC

You can also build and run the ClojureScript compiler test suite in bootstrapped mode within Node.js by running

#+BEGIN_SRC sh
    ./script/test-self-parity
#+END_SRC

**** Running ClojureScript CLI (=cljs.main=) tests
   :PROPERTIES:
   :CUSTOM_ID: running-clojurescript-cli-tests
   :END:

You can run tests exercising the ClojureScript CLI by running

#+BEGIN_SRC sh
    ./script/test-cli repl-env [repl-env-opts-edn]
#+END_SRC

where =repl-env= is any of the built-in REPL environments (=node=, =browser=, /etc./). This will be passed to =cljs.main= 's =-re= option.

Note that testing with =graaljs= REPL environment requires GRAALVM\_HOME to be found early in your PATH. You can test via:

#+BEGIN_SRC sh
    (export PATH="$GRAALVM_HOME:$PATH"; ./script/test-cli graaljs)
#+END_SRC

You can also specify a non-built-in REPL environment, but you would have to revise =script/test-cli= to include the downstream REPL environment on the classpath. You can also pass optional =repl-env-opts-edn=, which will be passed to =cljs.main= 's =-ro= option.

**** Don't forget the Browser REPL
   :PROPERTIES:
   :CUSTOM_ID: dont-forget
   :END:

It is important to make sure that the Browser REPL hasn't accidentally been broken.

You may have already run tests against the browser REPL via =./script/test-cli browser=. If not, now is a good time to do so. Note: It is normal for this test to launch plenty of browser windows/tabs.

In addition, you might only be comfortable after some manual verification - if only to try a sanity =(js/alert "Hello CLJS!")=:

1. You can launch a browser REPL by running =clj -M -m cljs.main= from the clojurescript project root dir.

2. Or from a new empty dir, create a =deps.edn= that points to your [[file:building][build of the ClojureScript compiler]] replacing =1.10.123= with your local version:

   #+BEGIN_SRC clojure
       {:deps {org.clojure/clojurescript {:mvn/version "1.10.123"}}}
   #+END_SRC

   and then from this dir, run =cljs -m cljs.main=.

* Guide
** Code Splitting
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/code-splitting.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/code-splitting
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2017-07-10
:CUSTOM_ID: content/guides/code-splitting
:END:

*This guide requires ClojureScript 1.10.238 or later and assumes familiarity with the [[file:xref/../../guides/quick-start][Quick Start]]*.

As client applications become larger it becomes desirable to load only the code actually required to run a particular logical screen. Previously ClojureScript =:modules= compiler option permitted such code splitting, but this feature only worked under =:advanced= compilation and users would still have to manage loading these splits. =:modules= also required manual explicit placement of many entries to produce optimal splits otherwise dependencies would get moved to =:cljs-base=.

All of these issues are now addressed directly in ClojureScript. This guide will walk you through code splitting a simple project and demonstrate these new enhancements.

*** Make a Simple Project
  :PROPERTIES:
  :CUSTOM_ID: _make_a_simple_project
  :END:

Create a project folder:

#+BEGIN_EXAMPLE
    mkdir -p hello-modules
    cd hello-modules
    mkdir src
#+END_EXAMPLE

Create a =build.edn= file that looks like the following:

#+BEGIN_EXAMPLE
    {:output-dir "out"
     :asset-path "/out"
     :browser-repl false
     :modules {:foo {:entries #{foo.core}
                     :output-to "out/foo.js"}
               :bar {:entries #{bar.core}
                     :output-to "out/bar.js"}}}
#+END_EXAMPLE

Now make an =index.html= file:

#+BEGIN_EXAMPLE
    <html>
        <body>
             <button id="button">Load Bar!</button>
             <script src="out/cljs_base.js" type="text/javascript"></script>
             <script src="out/foo.js" type="text/javascript"></script>
        </body>
    </html>
#+END_EXAMPLE

*** The Sources
  :PROPERTIES:
  :CUSTOM_ID: _the_sources
  :END:

Create the =foo.core= namespace:

#+BEGIN_EXAMPLE
    mkdir -p src/foo
    touch src/foo/core.cljs
#+END_EXAMPLE

Edit this file to look like the following:

#+BEGIN_EXAMPLE
    (ns foo.core
      (:require [goog.dom :as gdom]
                [goog.events :as events]
                [cljs.loader :as loader])
      (:import [goog.events EventType]))

    (println "I'm foo!")

    (events/listen (gdom/getElement "button") EventType.CLICK
      (fn [e]
        (loader/load :bar
          (fn []
            ((resolve 'bar.core/woz))))))

    (loader/set-loaded! :foo)
#+END_EXAMPLE

Notice the unfamiliar namespace =cljs.loader=. This namespace provides a Google Closure ModuleManager singleton to manage the loading of code splits. This manager will be initialized with whatever module graph you have defined in =:modules=.

When the user clicks the button we load the =:bar= module and invoke a function that exists in the =bar.core= namespace. Notice that we use =resolve=. This is because we cannot directly call something we never required. If we tried to do this without =resolve= the ClojureScript compiler would emit an undeclared var warning during compilation.

Finally, note that it is necessary to manually mark a module as loaded via =cljs.loader/set-loaded!=. Without this dependencies may be loaded multiple times which may lead to unpredictable behavior.

Create the =bar.core= namespace:

#+BEGIN_EXAMPLE
    mkdir -p src/bar
    touch src/bar/core.cljs
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require [cljs.loader :as loader]))

    (println "I'm bar!")

    (defn woz []
      (println "WOZ!"))

    (loader/set-loaded! :bar)
#+END_EXAMPLE

*** Build the Project
  :PROPERTIES:
  :CUSTOM_ID: _build_the_project
  :END:

Build your project and start the builtin HTTP server:

#+BEGIN_EXAMPLE
    clj -M -m cljs.main -v -co build.edn -c -s
#+END_EXAMPLE

Navigate to [[http://localhost:9000/index.html]].

Click the button. You will see that the =:bar= module gets loaded and the function in the other namespace gets invoked.

*** Release Builds
  :PROPERTIES:
  :CUSTOM_ID: _release_builds
  :END:

Build your project:

#+BEGIN_EXAMPLE
    clj -M -m cljs.main -co build.edn -O advanced -c -s
#+END_EXAMPLE

Navigate to [[http://localhost:9000/index.html]]. Your application should function correctly even though advanced compiled.

Change the =foo.core= to take a new require like =cljs.reader=. Rebuild.

You should see that =cljs.reader= gets moved into the =:foo= module but not =:bar=.

If you examine the split files in =out= you will see that =foo.js= is larger than =bar.js=.

*** Additional Notes
  :PROPERTIES:
  :CUSTOM_ID: _additional_notes
  :END:

Because the code in splits is running in JavaScript's global scope, sometimes it may interfere with other JavaScript loaded on the same page (i.e. analytics), which may result in unpredictable behaviour. If this is a problem for your application prefix all variables in generated JavaScript by specifiyng =:rename-prefix= compiler option.

** Externs
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/externs.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/externs
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2017-01-22
:CUSTOM_ID: content/guides/externs
:END:

*This guide requires ClojureScript 1.10.238 or later and assumes familiarity with the [[file:xref/../../guides/quick-start][Quick Start]]*.

This page documents how to write externs for third party JavaScript libraries that do not conform to Google Closure Compiler conventions [[https://developers.google.com/closure/compiler/docs/limitations]].

*** Motivation
  :PROPERTIES:
  :CUSTOM_ID: motivation
  :END:

Many useful libraries cannot go through Google Closure Compiler advanced compilation. Thus they cannot be a part of the build and are considered "foreign". Still Closure must know something about these libraries, otherwise properties may be unintentionally renamed. Unfortunately, often this accidental renaming won't be apparent until the least opportune time - production.

For libraries that already have mature externs this type of mistake is easily avoided. However, this requirement adds an incredible amount of friction to the adoption of newer or less popular but equally useful libraries. With the arrival of externs inference, the ClojureScript compiler can now automatically generate missing externs as well as greatly aid the process of writing comprehensive externs.

*** Externs Inference
  :PROPERTIES:
  :CUSTOM_ID: externs-inference
  :END:

Imagine that we have specified a foreign library =some.fooLib=. We would like to write interop against this library but have certainty that either the correct externs will be automatically generated or the compiler will notify us of externs we must additionally supply.

To enable externs inference, we specify the =:infer-externs true= in our compiler configuration.

Create a =build.edn= file with the following content:

#+BEGIN_SRC clojure
    {:main my-project.core
     :output-to "out/main.js"
     :output-dir "out"
     :optimizations :none
     :infer-externs true})
#+END_SRC

However this alone isn't enough to have the compiler generate warnings around externs. Because of the large number of libraries written before this feature existed, we cannot enable this capability in a global way. Instead there is a new file local compiler flag =*warn-on-infer*= which is somewhat analogous to =*warn-on-reflection*= in Clojure. Once set the compiler will warn for the remainder of the file anytime it cannot determine the types involved in a dot form, whether property access or method invocation.

#+BEGIN_SRC clojure
    (ns my-project.core
      (:require [some.fooLib]))

    (set! *warn-on-infer* true)

    (defn wrap-baz [x]
      (.baz x))
#+END_SRC

The above code would trigger a warning message:

#+BEGIN_EXAMPLE
    Cannot infer target type in expression (.baz x) ...
#+END_EXAMPLE

We simply need to type-hint =x= with the foreign type for this interop call:

#+BEGIN_SRC clojure
    (ns my-project.core
      (:require [some.fooLib]))

    (set! *warn-on-infer* true)

    (defn wrap-baz [^js/Foo.Bar x]
      (.baz x))
#+END_SRC

The compiler now has enough information to automatically generate the required externs. When you run your build you will see a new file in your output directory =inferred_externs.js=. If you examine its contents it will probably look similar to the following:

#+BEGIN_EXAMPLE
    var Foo = {};
    Foo.Bar = function() {};
    Foo.Bar.prototype.baz = function() {};
#+END_EXAMPLE

Quickly integrating foreign JavaScript libraries without complete externs is now considerably easier and less error prone.

In some cases you may still want to write externs or you may be a consumer of a popular JavaScript library with mature externs and you would like a bit more validation. The following section describes an additional useful feature provided by externs inference.

*** Return Types
  :PROPERTIES:
  :CUSTOM_ID: return-types
  :END:

Local type hints go a long way to automating the process of writing externs. However, for interop heavy code this will lead to a lot of type hinting particularly for the return values of commonly used functions. In this case it's probably better to provide the externs file. Even here the ClojureScript compiler can ease the process:

#+BEGIN_SRC clojure
    (ns my-project.core
      (:require [some.fooLib]))

    (set! *warn-on-infer* true)

    (defn my-fn [^js/Foo.Bar x]
      (let [z (.baz x)]
        (.-wozz z)))
#+END_SRC

Imagine that our externs file looks something like the following:

#+BEGIN_EXAMPLE
    var Foo = {};
    /**
     * @constructor
     */
    Foo.Bar = function() {};
    Foo.Bar.prototype.baz = function() {};
    /**
     * @constructor
     */
    Foo.Boo = function() {};
    Foo.Boo.prototype.woz = function() {};
#+END_EXAMPLE

However this isn't sufficient for knowing the type of =z= in the ClojureScript program. The ClojureScript compiler will issue the following warning:

#+BEGIN_EXAMPLE
    WARNING: Adding extern to Object for property wozz due to ambiguous expression (. z -wozz) ...
#+END_EXAMPLE

We need to add the return type information to the externs file:

#+BEGIN_EXAMPLE
    var Foo = {};
    /**
     * @constructor
     */
    Foo.Bar = function() {};
    /**
     * @return {Foo.Boo} <-- CHANGED
     */
    Foo.Bar.prototype.baz = function() {};
    /**
     * @constructor
     */
    Foo.Boo = function() {};
    Foo.Boo.prototype.woz = function() {};
#+END_EXAMPLE

Touching your source file and re-running build will result in a different warning:

#+BEGIN_EXAMPLE
    WARNING: Cannot resolve property wozz for inferred type js/Foo.Boo in expression (. z -wozz)
#+END_EXAMPLE

As we can see the ClojureScript used the return type information to clarify the problem.

** FAQ (for JavaScript developers)
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/faq-js.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/faq-js
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/guides/faq-js
:END:

This page aims at answering some concerns JavaScript developers may have regarding using ClojureScript.

*** Language features and semantics
  :PROPERTIES:
  :CUSTOM_ID: language-features-and-semantics
  :END:

*[[immutable_advantages][Immutable data structures are like regular data structures, except that they cannot change. So what reason is there to prefer them, since they obviously have less capabilities?]]*

Actually, you /can/ change immutable data structures, it's just that 'change' does not mean the same thing. In this case, changing means making a /new/ data structure, that has some differences to the one you started with.

In JavaScript, you're already doing this when working with strings, booleans, and numbers: incrementing a number is making a new number; appending to a string is making a new string.

So you should really not think of immutable data structures as constrained containers, but as /composite values/.

You should feel reassured by the fact that persistent data structures are /hard/ to implement efficiently. There are some sophisticated algorithms doing the heavy lifting for you behind the scenes so you can have your cake and eat it too. This is similar to Garbage Collection: an algorithmic innovation which yields semantics that are less natural for computers and more natural for humans.

/This is all nice, but how will programming with values make my life better?/

The most immediately visible benefit is that you will never have to use brittle techniques like defensive copying, cloning, etc., because you'll never have to worry about some other part of your code mutating your data from under you.

Let's see a concrete example. Imagine you have a Person model in your web app, and a component that lets you edit and submit changes to the value of the Person's fields. When programming with values, it is trivial to achieve the following functionality:

1. start editing from the current version of your model at some point in time

2. when editing, have your modifications be only local to your editing component, without affecting the rest of your app

3. conversely, have your app see changes to your model from an external source (e.g updates pushed from your API), while your local editing process still deals with the version it had started with

4. support undos and redos while editing

5. when submitting your changes, optimistically change the value of your model in your web app so that your changes are immediately visible, and revert them if the server comes back to you with an error.

More deeply, there are strong reasons to believe that values are a much more natural fit than mutable data structures for making information systems. This is particularly true in network-intensive applications like web apps (values are what you get from / send over the wire; it's not like your AJAX call was going to give you a data structure that lets you mutate your database). There's a [[http://www.infoq.com/presentations/Value-Values][talk]] which makes an excellent case for values.

Finally, even without considering the benefits of value-based programming, you'll find that ClojureScript's collections are just very powerful and pleasant to use, thanks to a very complete standard library.

*[[but-how-do-i-change-anything][...​ but how do I change anything ?]]*

/Since data structures are immutable, and locals are not variable, how to I make a program that evolves over time ?/

Fear not: you won't have to use monads. ClojureScript acknowledges the need for mutable state, and provides a /reference type/, the atom, to manage it. Here's an example:

*JavaScript:*

#+BEGIN_EXAMPLE
    // declaring the state
    var state = {
      count: 0
    };

    // ...

    // updating the state :

    state.count = state.count + 1;
#+END_EXAMPLE

*ClojureScript:*

#+BEGIN_SRC clojure
    ;; declaring the state
    (def state (atom {:count 0}))

    ;; ...

    ;; updating the state
    (swap! state #(update % :count inc))
#+END_SRC

ClojureScript atoms are superior to JavaScript variables in the same way that JavaScript functions are superior to, say, Java methods: because they're first-class. They can be passed to functions, referenced by data structures, and abstractions can be built atop them. In addition, atoms can be observed.

You'll find that you use much fewer ClojureScript atoms than you did JavaScript variables. The combination of atoms and immutable data structures allows you to manage your state in a few key places, instead of having it strewn all over your programs.

*[[what-value-do-macros-bring][What value do macros bring?]]*

A lot of people define macros as an easy way to customize the first steps of compilation. This is the kind of definition you understand only once you've used macros, so let's explain it differently.

A macro lets you specify some transformation of your code; using a macro called =my-macro= is like saying to ClojureScript: 'when I write =(my-macro <this nice-looking code>)=, I mean `(<this more tedious code>)' . In the same way that functions factor out parts of the execution of your programs, macros factor out parts of the writing of your code.

As a consequence, when you have macros, you can always make calling your code as comfortable as possible, because the syntax will never get in your way.

For example, the =doto= macro lets you write

#+BEGIN_SRC clojure
    (def my-date (doto (new Date)
                   (.setDate 7) (.setMonth 7) (.setFullYear 1991)))
#+END_SRC

which is /as if/ you had written:

#+BEGIN_SRC clojure
    (def my-date
      (let [d (new Date)]
        (.setDate d 7)
        (.setMonth d 7)
        (.setFullYear d 1991)
        d))
#+END_SRC

which you would have (painfully) written in JavaScript:

#+BEGIN_EXAMPLE
    var myDate = (function(){
      var d = new Date();
      d.setDate(7);
      d.setMonth(7);
      d.setFullYear(1991);
      return d;
    }());
#+END_EXAMPLE

More profoundly, macros make it trivial to separate 2 important concerns: making well-structured programs, and making them practical from a syntactic viewpoint.

But macros are not merely a means of eliminating boilerplate. By letting you extend and manipulate the syntax of ClojureScript, they enable you to import new paradigms to your programs.

Macros in ClojureScript make it possible to add these "features" to ClojureScript /à la carte, as libraries/:

-  [[https://github.com/clojure/core.async][Golang-style CSPs]] and 'go-routines' for asynchrony

-  OCaml-style [[https://github.com/clojure/core.match][pattern matching]]

-  an optional [[https://github.com/clojure/core.typed][static type checker]]

Let's also note that macros have zero runtime overhead, since everything they do happens when generating JavaScript.

*[[but-i-heard-macros-are-bad-practice-yielding-code-that-is-hard-to-reason-about.-why-use-a-language-that-supports-them][...​ but I heard macros are bad practice, yielding code that is hard to reason about. Why use a language that supports them?]]*

Indeed, even in the ClojureScript community it is considered bad style to use a macro when you don't have to. ClojureScript application developers very rarely write macros, because most of the time a function can also do the job, and is easier to reason about.

But from time to time, you need to make a conceptual leap that only macros can achieve, because the tedium in the syntax cannot be mitigated with functions, or because it requires code analysis.

Macros are like planes. You don't want to take a plane everyday to go to work. But from time to time, planes allow you to reach another continent in a matter of hours, so we're glad we have them.

*[[ill-never-get-used-to-the-syntax][I'll never get used to the syntax!]]*

Indeed, transitioning from JavaScript syntax to Clojure syntax is */daunting/*:

JavaScript:

#+BEGIN_EXAMPLE
    myFun(x, y, z);
#+END_EXAMPLE

ClojureScript:

#+BEGIN_SRC clojure
    (myFun x y z)
#+END_SRC

You need to move one parenthesis from one side of the operator to the other, and remove the commas and semicolons.

Clojure's syntax (aka EDN - Extensible Data Notation) is what makes writing macros in Clojure practical.

It's most likely unfamiliar to you, but it's not unnatural. Once you get used to it, you'll find it has more regularity and less clutter than JavaScript.

This is fun, let's do this again for data structure literals:

JavaScript:

#+BEGIN_EXAMPLE
    {a : "b",
     c : [d, e]}
#+END_EXAMPLE

ClojureScript:

#+BEGIN_SRC clojure
    {:a "b"
     :c [d e]}
#+END_SRC

As you can see, the main difference is you get rid of commas and colons.

Interestingly, although it does not seem like much, this has big implications on one important part of web programming: HTML templating.

Clojure's data notation is so conveniently lightweight that several Clojure libraries use them to embed HTML templating in the language:

#+BEGIN_SRC clojure
    [:div.text-right
      [:span "Click here: "]
      [:button {:class "btn" :on-click #(do something)} "Click me!"]]
#+END_SRC

Some people are bothered by the number of parentheses that Clojurescript code requires. You'll find that they're not a problem once you get used to [[https://github.com/bbatsov/clojure-style-guide#source-code-layout—​organization][Clojure indentation conventions]]. It goes without saying you should use an editor that will help you match parentheses, braces, and brackets. If you also use an [[are-there-good-editors-for-clojurescript][editor that will help format your code for you]], you'll be able to see immediately if you've made a mistake with parentheses.

*[[can-i-call-javascript-from-clojurescript][Can I call JavaScript from ClojureScript?]]*

ClojureScript has very good JavaScript interoperability. ClojureScript functions are regular JavaScript functions. The language provides primitives to access native browser objects, access and set properties of objects, create and manipulate JavaScript objects and arrays, and call any JavaScript function or method.

You can also write functions in ClojureScript and call them from JavaScript.

*[[can-i-use-existing-javascript-libraries-from-clojurescript][Can I use existing JavaScript libraries from ClojureScript?]]*

Yes, for example many ClojureScript developers use libraries like React or d3.

*[[how-does-clojurescript-compare-to-the-newer-ecmascript-versions][How does ClojureScript compare to the newer ECMAScript versions?]]*

/ES2015, ES7, etc. bring a lot of expressiveness to JavaScript (arrows, generators, destructuring, ...​) while addressing several of its shortcomings and deficiencies (modules, block scope, ...​). Does this not make languages like ClojureScript pointless?/

Comparing programming languages by listing their features is a dangerous exercise, but let's do it anyway. Most of the syntax enhancements newer ECMAScript versions bring, Clojure provides. The following table lists recent ECMAScript features and their ClojureScript equivalent.

| ECMAScript                             | ClojureScript                                                                                                                                                                                                                                             |
|----------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Arrows                                 | Clojure function expressions are already quite concise, and expression-based (compare =(fn [x y] (+ x y))= to =function (x, y){return x + y;}=). In addition, there is an even more lightweight function syntax (=#(+ %1 %2)=).                           |
| Classes                                | ClojureScript is not class-based [[https://clojure.org/datatypes#toc5][by design]]; use data types and protocols to get the good parts of Object-Orientation. See [[why-are-there-no-classes-][next section]] for more details.                           |
| Template Strings                       | ClojureScript strings are multi-line, and the absence of commas makes using the =str= function for concatenation very natural; you can also use C-style format from the Google Closure library.                                                           |
| Destructuring                          |  Available, also supports nesting and function parameters.                                                                                                                                                                                                |
| Default and rest arguments             | Fully supported                                                                                                                                                                                                                                           |
| Let and const                          |  these are the exact semantics of ClojureScript's =let=.                                                                                                                                                                                                  |
| Iterators and For..Of                  |  Seq abstraction, which is implemented by all default collections.                                                                                                                                                                                        |
| Generators                             | Lazy seqs                                                                                                                                                                                                                                                 |
| Sets and Maps                          | part of the standard library (as persistent data structures), allow for arbitrary keys.                                                                                                                                                                   |
| Proxies                                | Not relevant                                                                                                                                                                                                                                              |
| Symbols                                |  By design, ClojureScript is against information hiding, so no private members. Keywords can be namespaced, reducing the potential for conflict in map keys. Protocols let you extend the behaviour of existing data types without new visible members.   |
| Math + Number + String + Object APIs   |  Similar functionality in both the standard library and the Google Closure library.                                                                                                                                                                       |
| Number literals                        | there are literals for any base, with special syntax for octal and hexadecimal (and of course decimal)                                                                                                                                                    |
| Promises                               | Available via libraries                                                                                                                                                                                                                                   |
| Reflect API                            | Not relevant                                                                                                                                                                                                                                              |
| Tail Calls                             | partially supported via the explicit =recur= construct.                                                                                                                                                                                                   |

*[[why-are-there-no-classes][Why are there no classes ?]]*

In no small part, Clojure was [[https://clojure.org/rationale#toc5][born]] as an answer to the limitations of Object Orientation as embodied by class-based languages like Java and Ruby.

From Clojure's perspective, classes conflate data representation, program logic, code organisation, state management, and polymorphism; all these concerns are /separately/ addressed in Clojure by data structures, functions, namespaces, managed references, and 'polymorphism à la carte' construct (protocols and multimethods).

/But how will I reuse code if I don't have inheritance ?/

Even in the object-oriented world, the experts will tell you to favor composition over inheritance to achieve code reuse. Because functions are so fine-grained, they're very easy to compose.

Data structures are also easier to reuse than classes, because they imply less specificity.

(Note that both of these benefits are not specific to Clojure; you may have already experienced them by using JavaScript in a functional, data-oriented way).

If you have a strong object-oriented background, it may take you some time to learn to live without classes. Don't worry. This learning curve goes downhill, and your efforts will be rewarded.

*** Ecosystem
  :PROPERTIES:
  :CUSTOM_ID: ecosystem
  :END:

*[[whats-clojurescripts-equivalent-of-underscore.js-lodash][What's ClojureScript's equivalent of Underscore.js / Lodash ?]]*

It's ClojureScript itself! ClojureScript comes with an excellent collections library. All the collections functions you know and love are there (map, reduce, filter, remove, ...), and they work on abstractions, which means they are not restricted to javascripts objects and array-likes.

*[[what-frameworks-are-there-for-clojurescript-like-angularjs-backbone-ember-etc.][What frameworks are there for ClojureScript ? (like AngularJs, Backbone, Ember etc.)]]*

You won't find an equivalent of AngularJs or Backbone in ClojureScript. This is actually a good sign. In great part, what motivated these client-side frameworks was JavaScript's lack of modularity, primitives and a decent standard library.

ClojureScript as a platform addresses these issues, and relies on the Google Closure library to address browser inconsistencies. The other concerns of building applications (e.g templating, server communication, routing etc.) are addressed by composing together special-purpose libraries.

To get started on ClojureScript projects, the ClojureScript Wiki provides several [[file:project-templates][project templates]], as well as a catalog of [[file:xref/../../../community/libraries][libraries]].

*[[do-people-use-clojurescript-in-production][Do people use ClojureScript in production?]]*

Yes [[file:xref/../../../community/companies][they do]].

*[[is-clojurescript-maturestable][Is ClojureScript mature/stable?]]*

ClojureScript, as a programming language, is very mature. Clojure was carefully designed for several years before being made available to the public in 2008. When ClojureScript came out in 2011, Clojure had been tested and proven for several years on the JVM. This, along with the combination of Clojure's emphasis on simplicity and the fact that macros eliminate many difficult language design decisions, has led Clojure as a language to reach stability in only a few years.

If the transformations JavaScript is going through are a problem to you (new language features, paradigm shifts in the community, convention changes in programming shops, and all the changes they cause in the tooling and libraries), ClojureScript may be a nice place for you.

Of course, the language is not everything, and the ClojureScript library ecosystem will go through important transformations in the coming years. But one should note that this is happening in the JavaScript ecosystem as well, as shown by the massive adoption of paradigm-shifting libraries like React and Falcor, and the changes undergoing application platforms and requirements.

*** React and Flux
  :PROPERTIES:
  :CUSTOM_ID: react-and-flux
  :END:

*[[does-clojurescript-play-well-with-reactflux][Does ClojureScript play well with React/Flux ?]]*

Yes, almost everyone in the ClojureScript community uses React because of the deep synergies it has with functional programming as embodied by ClojureScript. In fact, a lot of ClojureScript programmers think of ClojureScript as the best way to leverage React.

The rich collections library, advanced control flow operators (such as =cond=, =case=, =when=, =let=, =if-let=, pattern matching etc.), and the fact that /everything is an expression/ enable you to write rendering functions in a very direct and declarative way (you won't have to lay out a bunch of intermediary variables).

Flux is very straightforward to implement in ClojureScript, thanks to the combination of persistent data structures and managed references (atoms). This is part of the raison d'être of influential libraries like [[https://github.com/omcljs/om][Om]].

In many respects, ClojureScript is leading the way for the wider React/Flux community, as shown by the progressive adoption of immutable data structures, the 'all state in one place' principle, and other functional techniques.

*[[can-i-re-use-react-components-in-clojurescript][Can I re-use React components in ClojureScript?]]*

Yes! Besides the fact that you can just use React in ClojureScript, the most popular ClojureScript wrappers to React (Om, Reagent and Quiescent) all let you include React components without any effort.

*** Tools
  :PROPERTIES:
  :CUSTOM_ID: tools
  :END:

*[[are-there-good-editors-for-clojurescript][Are there good editors for ClojureScript?]]*

Definitely. A lot of people use [[file:xref/../../../tools/emacs-inf][Emacs with Clojure]], there are also excellent plugins for [[file:xref/../../../tools/cursive][IntelliJ]], [[file:xref/../../../tools/vim][Vim]], Eclipse and [[file:xref/../../../tools/sublime][Sublime Text]].

You'll probably find that structural editing is more practical than what you're used to, because it naturally lets you manipulate the building blocks of your code (i.e expressions, not lines or words).

*[[are-there-build-tools-for-clojurescript][Are there build tools for ClojureScript?]]*

Yes. Most ClojureScript developers use [[http://leiningen.org/][Leiningen]] to manage ClojureScript projects, which takes care of dependencies loading, packaging, and has plugins for front-end development workflow (CSS pre-processing, assets minification, etc.). Another popular tool is [[http://boot-clj.com/][Boot]].

In particular, ClojureScript with Figwheel is arguably the state-of-the-art of interactive front-end development, thanks to live code reloading and the ClojureScript REPL.

*[[i-dont-feel-very-good-about-clojurescript-relying-on-google-closure.][I don't feel very good about ClojureScript relying on Google Closure.]]*

Google Closure offers compelling advantages for front-end JavaScript developers:

-  a very comprehensive, battle-tested library

-  very efficient minification

-  dead-code elimination, i.e code which is not used is removed. (This is what enables the library to be comprehensive: you don't have worry about the extra bytes when adding functionality.)

The majority of JavaScript developers have rejected Google Closure because of a major drawback: for dead-code elimination to work, they had to follow strict discipline about the JavaScript they write (in particular, it ended up looking a lot like Java).

You don't have this impediment when using Google Closure from ClojureScript, because the ClojureScript compiler emits JavaScript that is optimized for Closure out of the box. This means you can reap the benefits listed above without making any compromise on your language semantics.

Dead-code elimination is a great convenience for the application developer, but it has even deeper benefits for the development of the ecosystem. Library authors no longer have to make functionality-vs-weight tradeoffs because the users only get the bytes they use.

*** Platform
  :PROPERTIES:
  :CUSTOM_ID: platform
  :END:

*[[can-i-run-clojurescript-on-the-server-side-and-share-logic-between-server-and-client][Can I run ClojureScript on the server-side, and share logic between server and client?]]*

First, ClojureScript targets all major JavaScript engines. Therefore, you /can/ run ClojureScript on NodeJS.

However, you won't find many examples of ClojureScript for writing NodeJS servers. For a variety of reasons, people tend to prefer the original JVM Clojure on the server (the library ecosystem is more mature, and it does not force you to write asynchronous code).

Since Clojure 1.7, it has become very easy to write Clojure code that targets both the Java and JavaScript runtimes.

However, when that approach fails (in the cases where you need to rely on JavaScript-specific functionality on both server and client), people tend to turn to Nashorn, the JavaScript runtime embedded in Java 8.

Which brings us to:

*[[can-i-make-isomorphic-applications-with-clojurescript][Can I make isomorphic applications with ClojureScript?]]*

[[https://www.paren.com/posts/isomorphic-clojure-part-1][Various]] [[http://blog.sparrho.com/post/111401717082/introducing-supper-making-om-isomorphic][Proofs of concept]] have been published towards this goal, but currently there are no ready-made library solutions like Fluxible for this problem.

*[[does-clojurescript-work-in-old-browsers][Does ClojureScript work in old browsers?]]*

ClojureScript compiles to ES3-compliant code. It requires less discipline to write portable code in ClojureScript than in vanilla JS.

*** Practical use
  :PROPERTIES:
  :CUSTOM_ID: practical-use
  :END:

*[[whats-the-debugging-story-like][What's the debugging story like?]]*

ClojureScript has excellent support for traditional JavaScript debugging techniques: you can set breakpoints in your source code, get ClojureScript stacktraces, etc. This is possible thanks to very well engineered source maps, which work even on production code with advanced minification.

In addition to this, REPL-driven development and hot-code reloading bring a whole new dimension to this, by enabling to test and modify stateful programs without erasing the conditions for a bug.

*Icing on the cake:* Macros help you here too. A typical JavaScript debugging technique is to insert =console.log= calls in the middle of your code, but this quickly gets tedious and intrusive.

For example, let's assume you have this code, and suspect the myFun function is faulty:

#+BEGIN_EXAMPLE
    var result = x + myFun(y);
#+END_EXAMPLE

What you would have to do is:

#+BEGIN_EXAMPLE
    var z = myFun(y);
    console.log("myFun(y) : ", z);
    var result = x + z;
#+END_EXAMPLE

In ClojureScript, you can define a =spy= macro that does the same thing in a very lightweight manner. So the equivalent ClojureScript code:

#+BEGIN_SRC clojure
    (let [result (+ x (myFun y))])
#+END_SRC

would become:

#+BEGIN_SRC clojure
    (let [result (+ x (spy (myFun y)))])
#+END_SRC

and you would see the same information in the console. Cool, huh?

*[[clojurescript-looks-nice-in-theory-but-does-it-just-work][ClojureScript looks nice in theory, but does it 'just work'?]]*

In many people's opinion, more so than JavaScript :). The language semantics are less slippery, and the tooling is now mature enough to be used without worry.

*[[is-clojurescript-slow][Is ClojureScript slow?]]*

#+BEGIN_QUOTE
  Obviously, since ClojureScript is abstractions on top of JavaScript, it must be slower, especially because of persistent data structures.
#+END_QUOTE

Actually, the creators of ClojureScript had the pleasant surprise that JavaScript features is a very natural and direct foundation for ClojureScript's semantics (for instance, ClojureScript functions are regular JavaScript functions; ClojureScript protocols map to JavaScript prototypes in a very straightforward way). As a result, ClojureScript is quite fast.

ClojureScript's persistent data structures are obviously slower than JavaScript arrays and objects, but not as much as you'd think, because they were not implemented in a naive way (it's not cloning or copy-on-write). Here's a [[https://github.com/swannodette/mori/wiki/Benchmarking][benchmark]] to give you an idea.

In addition, persistent data structures allow for global optimizations that are not possible with mutable data structures. In particular, ClojureScript has been known to significantly improve the performance of React apps by using persistent data structures for caching ([[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs]]).

*** Learning ClojureScript
  :PROPERTIES:
  :CUSTOM_ID: learning-clojurescript
  :END:

*[[is-clojurescript-hard-to-learn][Is ClojureScript hard to learn?]]*

This varies significantly depending on people's programming experience and aptitudes.

If you're a JavaScript developer, you're in a good starting place to learn Clojure(Script) - more so than if you program in a classical language such as Ruby or Java - because JavaScript has already educated you to first-class functions, dynamic typing, conveying information with data structures (not classes), and organizing your code in namespaces (not class hierarchies).

Conceptually, you need to learn fewer things in ClojureScript that in JavaScript to get productive, because you don't have to learn to avoid all the traps of JavaScript. The REPL and the fact that documentation is included in the language play a critical role in speeding up the learning process.

In all likelihood, the big challenge will not be to assimilate new concepts, but to forget old ones. As Yoda put it: 'You must unlearn what you have learned [about imperative and object-oriented paradigms]'; this makes it harder for experienced programmers. Having said that, if you've been developing with JavaScript in a near-to-functional style (as [[https://www.youtube.com/watch?v=ya4UHuXNygM][advocated]] e.g by Douglas Crockford), this won't really be a problem.

*[[is-it-only-suitable-for-academics][Is it only suitable for academics?]]*

/I heard functional programming is only accessible to people who have a Ph.D./

You don't need to know Category Theory, Monads, etc. to use ClojureScript. For 99% of the work you'll be doing, the programming concepts you'll need are those you're already using in JavaScript (dynamic typing, functions, data structures).

*** Community
  :PROPERTIES:
  :CUSTOM_ID: community
  :END:

*[[is-there-a-community-how-is-it][Is there a community? How is it?]]*

There is, and it's growing fast. Actually, the community is often what people love most about Clojure. The Slack and various mailing lists are very active, and people are very responsive whenever you need help.

What characterizes the Clojure(Script) community is its combination of pragmatism, inventiveness, high quality standards, and wise leadership.

(Also, the people are very nice.)

*[[is-the-clojurescript-community-pragmatic][Is the ClojureScript community pragmatic?]]*

/I'm wondering if the Clojure people are not just in love with some elegant ideas, without being lucid about their actual added value in the real world./

Most people in the Clojure community went through a sort of epiphany when exposed to the ideas of its creator (notably through some excellent talks like [[http://www.infoq.com/presentations/Simple-Made-Easy][Simple Made Easy]] and [[http://www.infoq.com/presentations/Value-Values][The Value of Values]]), and felt greatly rewarded when adopting their incarnation in Clojure. As a consequence, we can sometimes be enthusiastic to the point we don't seem very objective.

But you should know that practicality and pragmatism have always been core values of Clojure, which motivated fundamental decisions like targeting the popular platforms which are the JVM and JavaScript runtimes, as well as the design decisions of sacrificing some functional purity as compared to other languages. You can tell that the Clojure community has kept true to this spirit by all the efforts they have put in developing practical tools and extending Clojure's reach to a broad spectrum of platforms.

*** Misc
  :PROPERTIES:
  :CUSTOM_ID: misc
  :END:

*[[this-all-seems-too-good-to-be-true…​][This all seems too good to be true...​]]*

Clojure is based on the fundamental belief that aiming for simplicity can dramatically empower programmers. The counter-intuitive implication is that getting rid of sophisticated tools and techniques will actually make you more effective. You won't believe it until you experience it.

*[[i-have-another-question][I have another question!]]*

You can suggest additional questions for this FAQ [[http://goo.gl/forms/dIAPRL9TE5][here]].

In the meantime, don't hesitate to reach out to the community on StackOverflow or on the [[https://groups.google.com/forum/#!forum/clojurescript][mailing list]], people are very friendly!

** Frequently Asked Questions
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/faq.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/faq
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/guides/faq
:END:
*** Builds
  :PROPERTIES:
  :CUSTOM_ID: _builds
  :END:

*[[slow_dev][Why are my dev builds slow?]]*

Make sure that your development classpath does not unnecessarily include test directories. ClojureScript now always recompiles child namespaces and changing a file could easily unintentionally trigger recompilation of all of your tests. Passing =:verbose true= is a simple way to check that the compiler isn't compiling more than it should.

** Guides
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/guides.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/guides
:CLOJURESCRIPT_SITE_AUTHOR: Alex Miller
:CLOJURESCRIPT_SITE_DATE: 2015-11-25
:CUSTOM_ID: content/guides/guides
:END:

-  [[file:quick-start][Quick Start]]

-  [[file:faq][FAQ]]

-  [[file:faq-js][FAQ (for JavaScript Devs)]]

-  [[file:externs][Externs]]

-  [[file:ns-forms][Namespaces]]

-  [[file:javascript-modules][JavaScript Modules]]

-  [[file:project-templates][Project Templates]]

-  [[file:self-hosting][Optional Self-hosting]]

-  [[file:native-executables][Native Executables]]

-  [[file:promise-interop][Promise Interop]]

** JavaScript Modules (Alpha)
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/javascript-modules.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/javascript-modules
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2017-01-22
:CUSTOM_ID: content/guides/javascript-modules
:END:

*This guide requires ClojureScript 1.10.238 or later and assumes familiarity with the [[file:xref/../../guides/quick-start][Quick Start]]*.

This page documents how to mix modern JavaScript source files seamlessly into an existing ClojureScript project. The features documented should be considered of alpha quality and subject to change.

*** Motivation
  :PROPERTIES:
  :CUSTOM_ID: motivation
  :END:

When ClojureScript was initially released, compilation to JavaScript was still a novelty and source transformation beyond minification was rare. Since then, source to source compilation of JavaScript has become increasingly popular, whether embedded HTML DSLs as with [[https://facebook.github.io/react/docs/introducing-jsx.html][React JSX]], or the [[https://www.ecma-international.org/ecma-262/7.0/][new ECMAScript standards]] that address many of JavaScript's old weaknesses. But integrating these new kinds of source files into a ClojureScript project required deferring to JavaScript build tools which still lack the more advanced features of the Google Closure compiler like precise dead code elimination and code splitting.

Fortunately, Google Closure has not only kept abreast of many of the various enhancements to the JavaScript language, they've also provided transformation from the various popular JavaScript module formats (CommonJS, AMD, ES6) into the Google Closure namespace convention. ClojureScript now exposes all of this functionality and, with the help of [[http://openjdk.java.net/projects/nashorn/][Java 8's Nashorn JavaScript engine]], can provide even the most cutting edge JavaScript source transforms with relative ease.

In addition Google Closure now has support for the Node.js resolution algorithm. The ClojureScript compiler can now build projects that want to use dependencies from NPM.

*** Prerequisites
  :PROPERTIES:
  :CUSTOM_ID: prerequisites
  :END:

Like the [[file:quickstart.html][Quick Start]], this guide assumes you have the latest release of [[https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html][JDK 8]], [[https://nodejs.org][Node.js >= 6.9.4]] and rlwrap installed. This guide only uses [[https://leiningen.org][Leiningen]] for managing dependencies and is easily adapted to [[http://boot-clj.com][Boot]] or [[https://maven.apache.org][Maven]].

*** JavaScript Modules
  :PROPERTIES:
  :CUSTOM_ID: javascript-modules
  :END:

First let's see how JavaScript modules can be a part of your build.

#+BEGIN_EXAMPLE
    mkdir -p hello-es6
    cd hello-es6
    touch project.clj
#+END_EXAMPLE

Create a =build.edn= file with the following contents:

#+BEGIN_SRC clojure
    {:output-to    "main.js"
     :output-dir   "out"
     :main         hello-es6.core
     :target       :nodejs
     :foreign-libs [{:file "src"
                     :module-type :es6}]
     :verbose      true})
#+END_SRC

Notice that a =:foreign-libs= entry may now specify a directory for =:file=. In this case, the ClojureScript compiler will recursively search this directory for =.js= files and automatically create the =:foreign-libs= entries for you with the supplied options. The =:provides= namespace for each entry will be automatically computed from the directory structure.

Let's create the main ClojureScript namespace:

#+BEGIN_EXAMPLE
    mkdir -p src/hello_es6
    touch src/hello_es6/core.cljs
#+END_EXAMPLE

Edit this file to look like the following:

#+BEGIN_SRC clojure
    (ns hello-es6.core
      (:require [cljs.nodejs :as nodejs]
                [js.hello :as hello]))

    (nodejs/enable-util-print!)

    (defn -main [& args]
      (hello/sayHello))

    (set! *main-cli-fn* -main)
#+END_SRC

Note that our JavaScript file can be imported like any other Google Closure namespace.

Let's write the JavaScript:

#+BEGIN_EXAMPLE
    mkdir -p src/js
    touch src/js/hello.js
#+END_EXAMPLE

JavaScript files do not declare namespaces, so the ClojureScript compiler will compute one based on the location of the entry. Since the =:foreign-libs= entry specified ="src"=, the namespace of this JavaScript file for usage from ClojureScript will be =js.hello=.

Edit this file to look like the following:

#+BEGIN_EXAMPLE
    export var sayHello = function() {
        console.log("Hello, world!");
    };
#+END_EXAMPLE

Let's check that our watch script works:

#+BEGIN_EXAMPLE
    cljs -m cljs.main -co build.edn -w -c
#+END_EXAMPLE

You can verify the script works as intended by invoking Node on =main.js=:

#+BEGIN_EXAMPLE
    node main.js
    Hello world!
#+END_EXAMPLE

*** Using the REPL
  :PROPERTIES:
  :CUSTOM_ID: using-the-repl
  :END:

Since JavaScript modules simply get compiled into Google Closure namespaces, all of the generic ClojureScript REPL features just work. For example, if you want automatic hot-loading of your ES6 source files just use [[https://github.com/bhauman/lein-figwheel][Figwheel]].

We'll demonstrate manual hot-loading with the standard Node.js REPL.

Start the REPL:

#+BEGIN_EXAMPLE
    clj -M -m cljs.main -co build.edn -r
#+END_EXAMPLE

Require the =js.hello= namespace and try it out:

#+BEGIN_EXAMPLE
    user> (require '[js.hello :as hello])
    true
    user> (hello/sayHello)
    Hello world!
#+END_EXAMPLE

Without quitting your REPL, edit =src/js/hello.js= to the following:

#+BEGIN_EXAMPLE
    export var sayHello = function() {
        console.log("Hello, world!");
    };
    export var sayThings = function(xs) {
        for(let x of xs) {
            console.log(x);
        }
    };
#+END_EXAMPLE

Reload your JavaScript module and try the new functionality:

#+BEGIN_EXAMPLE
    user> (require '[js.hello :as hello] :reload)
    true
    user> (hello/sayThings ["ClojureScript", "+", "JavaScript", "Rocks!"])
    ClojureScript
    +
    JavaScript
    Rocks!
#+END_EXAMPLE

Since ClojureScript vectors support the ES6 iteration protocol ES6 =for…​of= just works.

While Google Closure can handle ES6 you may want to use other preprocessors from the JavaScript ecosystem - for example [[http://babeljs.io][Babel's JSX transform]]. In this case we will want to leverage Nashorn.

*** Babel Transforms
  :PROPERTIES:
  :CUSTOM_ID: babel-transforms
  :END:

Change your =deps.edn= file to the following:

#+BEGIN_SRC clojure
    {:deps {org.clojure/clojurescript {:mvn/version "1.9.854"}
            cljsjs/react {:mvn/version "15.4.2-0"}
            cljsjs/react-dom {:mvn/version "15.4.2-0"}
            cljsjs/react-dom-server {:mvn/version "15.4.2-0"}
            cljsjs/babel-standalone {:mvn/version "6.18.1-3"}}}
#+END_SRC

Change your =build.edn= to look like the following:

#+BEGIN_SRC clojure
    {:output-to    "main.js"
     :output-dir   "out"
     :main         hello-es6.core
     :target       :nodejs
     :foreign-libs [{:file "src"
                     :module-type :es6
                     :preprocess cljsjs.babel-standalone/transform}] ;; CHANGED
     :verbose      true})
#+END_SRC

[[https://github.com/cljsjs/packages/tree/master/babel-standalone][Babel-standalone]] package from Cljsjs provides the necessary JavaScript file and a function that can be used as =:preprocess= handler. The function uses Nashorn JS engine to run Babel and process foreign libraries. Options to Babel can be provided by adding property =:cljsjs.babel-standalone/babel-opts= to the foreign library map.

Let's add a React JSX component to =src/js/hello.js=:

#+BEGIN_EXAMPLE
    export var sayHello = function() {
        console.log("Hello, world!");
    };
    export var sayThings = function(xs) {
        for(let x of xs) {
            console.log(x);
        }
    };
    export var reactHello = function() {
        return <div>Hello world!</div>
    };
#+END_EXAMPLE

Let's change our ClojureScript:

#+BEGIN_SRC clojure
    (ns hello-es6.core
      (:require [cljsjs.react]
                [cljsjs.react.dom]
                [cljsjs.react.dom.server]
                [cljs.nodejs :as nodejs]
                [js.hello :as hello]))

    (nodejs/enable-util-print!)

    (defn -main [& args]
      (hello/sayHello)
      (println (.renderToString js/ReactDOMServer (hello/reactHello))))

    (set! *main-cli-fn* -main)
#+END_SRC

Run the watch script:

#+BEGIN_EXAMPLE
    lein trampoline run -m clojure.main watch.clj
#+END_EXAMPLE

When the build finishes run the code

#+BEGIN_EXAMPLE
    node main.js
#+END_EXAMPLE

You should see output like the following:

#+BEGIN_EXAMPLE
    Hello, world!
    <div data-reactroot="" data-reactid="1" data-react-checksum="1334186935">Hello world!</div>
#+END_EXAMPLE

You may have noticed that our ES6 file does not declare its dependency on React, ReactDOM, or ReactDOMServer via =import=. Handling this correctly depends on a pending patch to Google Closure to support Node.js module resolution for ES6 source files. When this change lands this guide will updated.

However CommonJS support for Node.js resolution works today. The following section covers this topic and will eventually apply to ES6 files as well.

*** Custom JavaScript transforms
  :PROPERTIES:
  :CUSTOM_ID: custom-transforms
  :END:

In previous example the Babel transformation function was provided by a Cljsjs package. If you need to use different transformations you can write your own preprocessing function. The Babel transformation can be implemented like this, without the Cljsjs package:

Remove =cljsjs/babel-standalone= dependency from your project.clj.

Download =babel.min.js= into your project directory:

#+BEGIN_EXAMPLE
    curl -O https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.18.1/babel.min.js
#+END_EXAMPLE

Create a new =src/hello_es6/babel.clj= file:

#+BEGIN_SRC clojure
    (ns hello-es6.babel
      (:require [clojure.java.io :as io]
                [cljs.build.api :as b])
      (:import javax.script.ScriptEngineManager))

    (def engine
      (doto (.getEngineByName (ScriptEngineManager.) "nashorn")
        (.eval (io/reader (io/file "babel.min.js")))))

    (defn transform-jsx [js-module opts]
      (let [code (str (gensym))]
        (.put engine code (:source js-module))
        (assoc js-module :source
          (.eval engine (str "Babel.transform("code", {presets: ['react', 'es2016']}).code")))))
#+END_SRC

Change your =build.edn= to look like the following and rebuild:

#+BEGIN_SRC clojure
    {:output-to    "main.js"
     :output-dir   "out"
     :main         hello-es6.core
     :target       :nodejs
     :foreign-libs [{:file "src"
                     :module-type :es6
                     :preprocess 'hello-es6.babel/transform-jsx}] ;; CHANGED
     :verbose      true})
#+END_SRC

** Native executables
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/native-executables.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/native-executables
:CLOJURESCRIPT_SITE_AUTHOR: Craig Andera
:CLOJURESCRIPT_SITE_DATE: 2016-09-23
:CUSTOM_ID: content/guides/native-executables
:END:

This guide illustrates how to produce native executables from ClojureScript source. The basic idea is to produce a JavaScript file using the ClojureScript compiler, and then use a Node.js tool called [[https://github.com/jaredallard/nexe][nexe]] to compile that into an executable. The resulting file can be run without requiring a node install on the target machine, which can be handy.

nexe works by compiling the v8 engine into an exe that also contains your Javascript. So, strictly speaking, your program itself is not being compiled ahead of time. But if what you're after is the packaging convenience of an EXE, this is still pretty handy.

Setup:

#+BEGIN_SRC sh
    # Install node and nexe
    brew install node
    npm install nexe -g
#+END_SRC

Make a little hello world file:

#+BEGIN_SRC sh
    mkdir -p /tmp/nexe-test/src
    cd /tmp/nexe-test
    cat > src/hello.cljs <<EOF
    (ns hello)
    (enable-console-print!)
    (println "Hello world!")
    EOF
#+END_SRC

Fire up a REPL and compile the ClojureScript:

#+BEGIN_SRC sh
    wget https://github.com/clojure/clojurescript/releases/download/r1.9.473/cljs.jar
    java -cp cljs.jar clojure.main <<EOF
    (require 'cljs.build.api)
    (cljs.build.api/build "src" {:optimizations :advanced :output-to "out/main.js"})
    EOF
#+END_SRC

Use nexe to compile the js into a native exe. This will take a while the first time, but will be reasonably fast for subsequent runs:

#+BEGIN_SRC sh
    nexe -i out/main.js -o hello.exe

    # Run it
    time ./hello.exe

    # It's reasonably fast:
    # Hello world!
    #
    # real      0m0.095s
    # user      0m0.070s
    # sys       0m0.025s
#+END_SRC

Enjoy!

** Namespaces
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/ns-forms.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/ns-forms
:CLOJURESCRIPT_SITE_AUTHOR: Mike Fikes
:CLOJURESCRIPT_SITE_DATE: 2018-01-28
:CUSTOM_ID: content/guides/ns-forms
:END:

The ClojureScript =ns= form can, in most usage, be quite simple and similar to Clojure, especially with affordances that have been recently added to ClojureScript.

But, there is a rich set of options that underlie the =ns= form and you may encounter their use in the wild. This guide aims to walk through these options and provide some clarity.

*** Macros
  :PROPERTIES:
  :CUSTOM_ID: _macros
  :END:

In ClojureScript, macros are handled a bit differently than in Clojure. In particular, the =ns= form supports =:require-macros=, along with some simplifying sugar and implicit loading behavior that we will cover here.

**** Primitives
   :PROPERTIES:
   :CUSTOM_ID: _primitives
   :END:

For the sake of an example, let's assume that we have the following in =src/foo/core.clj=:

#+BEGIN_EXAMPLE
    (ns foo.core)

    (defmacro add
      [a b]
      `(+ ~a ~b))
#+END_EXAMPLE

To use this macro in some ClojureScript source, you can employ the =:require-macros= spec as

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require-macros [foo.core]))

    (foo.core/add 2 3)
#+END_EXAMPLE

Now, =:require-macros= is designed to work a lot like =:require=. So, for example, you could directly refer the =add= symbol into your namespace:

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require-macros [foo.core :refer [add]]))

    (add 2 3)
#+END_EXAMPLE

#+BEGIN_QUOTE
  An alternative to the above (which is infrequently seen, but worth covering for completeness), is =:use-macros=. In ClojureScript =:require= / =:refer= and =:use= / =:only= are essentially dual forms of each other. So, the =ns= form in the above could have just as well been written =(ns bar.core (:use-macros [foo.core :only [add]]))=.
#+END_QUOTE

You could also set up a namespace alias =foo=:

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require-macros [foo.core :as foo]))

    (foo/add 2 3)
#+END_EXAMPLE

**** Sugar
   :PROPERTIES:
   :CUSTOM_ID: _sugar
   :END:

The examples above are all making use of the =:require-macros= primitive.

Frequently, though, you will be consuming code that comes from a library that offers both runtime code (functions and other =def= s) and macros, all from the same namespace.

So, continuing on our example, let's say that there is a =src/foo/core.cljs= file with

#+BEGIN_EXAMPLE
    (ns foo.core)

    (defn subtract
      [a b]
      (- a b))
#+END_EXAMPLE

Now if you wanted to use both add and subtract, you might do something like this:

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require-macros [foo.core :refer [add]])
      (:require [foo.core :refer [subtract]]))

    (add 2 3)
    (subtract 7 4)
#+END_EXAMPLE

But, there is a bit of =ns=-form sugar, =:refer-macros= that lets you write instead:

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require [foo.core :refer [subtract] :refer-macros [add]]))

    (add 2 3)
    (subtract 7 4)
#+END_EXAMPLE

The =:refer-macros= above really is just sugar, and it is algorithmically desugared into the previous form by the compiler.

Similarly, there is =:include-macros= sugar that you can use to signal that the macros namespace should be required using the same specifications as the runtime namespace. So for example, this works:

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require [foo.core :as foo :include-macros true]))

    (foo/add 2 3)
    (foo/subtract 7 4)
#+END_EXAMPLE

The above desugars into the more repetitively verbose primitive form:

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require-macros [foo.core :as foo])
      (:require [foo.core :as foo]))

    (foo/add 2 3)
    (foo/subtract 7 4)
#+END_EXAMPLE

**** Implicit Sugar
   :PROPERTIES:
   :CUSTOM_ID: _implicit_sugar
   :END:

In cases where a runtime namespace being required /internally/ requires its own macro namespace (meaning a namespace with the same name), then you implicitly get the =:include-macros= sugar for free. This is recommended if you are developing a library, users can then simplify their require form.

To illustrate this, let's say our =src/foo/core.cljs= file instead looked like this:

#+BEGIN_EXAMPLE
    (ns foo.core
      (:require-macros foo.core))

    (defn subtract
      [a b]
      (- a b))
#+END_EXAMPLE

Now, you can consume things like this:

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require [foo.core :as foo]))

    (foo/add 2 3)
    (foo/subtract 7 4)
#+END_EXAMPLE

**** Implicit Refer
   :PROPERTIES:
   :CUSTOM_ID: _implicit_refer
   :END:

What about this nice-looking simplification?

#+BEGIN_EXAMPLE
    (ns bar.core
      (:require [foo.core :refer [add subtract]))

    (add 2 3)
    (subtract 7 4)
#+END_EXAMPLE

In this case, the fact that =add= is a macro and that =subtract= is a function is automatically handled by the compiler, thus making it possible to uniformly refer vars, with the =ns= form looking essentially like it would in Clojure.

**** Docs
   :PROPERTIES:
   :CUSTOM_ID: _docs
   :END:

If you are ever at a REPL and need a quick reference to the above topics, the docstring for the =ns= special form is there to help. The sugared forms are referred to as /inline macro specification/ and the implicit sugar is referred to as /implicit macro loading/. A fairly comprehensive example of desugaring is included in the docstring. In a pinch, =(doc ns)= is your friend.

**** The =require= and =require-macros= macros
   :PROPERTIES:
   :CUSTOM_ID: _the_require_and_require_macros_macros
   :END:

You can use =require= and =require-macros= to dynamically load code into your REPL. What's interesting is that the capability described above also works for these macros.

This is an implementation detail, but it helps you see how this is accomplished: When you issue

#+BEGIN_EXAMPLE
    (require-macros '[foo.core :as foo :refer [add]])
#+END_EXAMPLE

at the REPL, this is internally converted into an =ns= form that looks like

#+BEGIN_EXAMPLE
    (ns cljs.user
      (:require-macros [foo.core :as foo :refer [add]]))
#+END_EXAMPLE

And, importantly, when you use =require=, a similar =ns= form is employed, and it is subject to all the desugaring and inference behavior described above.

*** =clojure= Namespace Aliasing
  :PROPERTIES:
  :CUSTOM_ID: _clojure_namespace_aliasing
  :END:

Some namespaces---like =clojure.string= and =clojure.set=---are available for use in ClojureScript, even though the first segment in those namespaces is =clojure=. But then others---like =cljs.pprint=, =cljs.test=, and now =cljs.spec=---live under =cljs=.

Why the difference? Ideally, there'd be none. But, if you look at, say, the port of =clojure.pprint= for use with ClojureScript, it involves a /macro/ namespace. This is where the problem lies. Since the JVM ClojureScript compiler uses Clojure for execution, there would be a namespace collision if the port were not moved to =cljs.pprint=. In short, the =clojure.pprint= namespace was taken.

A consequence of this is that we have to remember to use =cljs.*= for some namespaces when writing ClojureScript. And, if you are writing portable code, you need to employ reader conditionals.

There is a relatively new simplification to the =ns= form that you can employ: You can use =clojure= in lieu of =cljs= in the first segment of namespaces in the case of nonexistent =clojure.*= namespaces that can be mapped to =cljs.*= namespaces.

A simple example:

#+BEGIN_EXAMPLE
    (ns foo.core
      (:require [clojure.test]))
#+END_EXAMPLE

can be used instead of

#+BEGIN_EXAMPLE
    (ns foo.core
      (:require [cljs.test]))
#+END_EXAMPLE

If you do this, the ClojureScript compiler will first see if it can load the =clojure.test= namespace. Since it doesn't exist, it will fall back to loading =cljs.test=.

At the same time, an alias is set up from =clojure.test= to =cljs.test=, as if you had written:

#+BEGIN_EXAMPLE
    (ns foo.core
      (:require [cljs.test :as clojure.test]))
#+END_EXAMPLE

This is important because it allows you to have code that qualifies symbols, as in =clojure.test/test-var=.

With this aliasing, along with the ability to infer macro vars in =:refer= specs (see “Implicit Refer” above), the following code works just fine in ClojureScript:

#+BEGIN_EXAMPLE
    (ns foo.core-test
      (:require [clojure.test :as test :refer [deftest is]]))

    (deftest foo-test
      (is (= 3 4)))

    (test/test-var #'foo-test)
#+END_EXAMPLE

And, more importantly: /This is the exact same code you'd write in Clojure/. No reader conditionals needed!

Of course, this also works in the =require= ClojureScript macro. So for example, you can do:

#+BEGIN_EXAMPLE
    (require '[clojure.spec :as s])
#+END_EXAMPLE

Then =(s/def ::even? (s/and number? even?))= will work just fine. The reason for this is that the =require= macro is implemented in terms of the =ns= special.

**** Summary
   :PROPERTIES:
   :CUSTOM_ID: _summary
   :END:

Hopefully these detailed examples help clarify how =ns= desugaring, inference, and aliasing work. The overall intent is to simplify ClojureScript =ns= form usage, but unpacking how these extra capabilities work leads to a better understanding for those times when you either want or need to know what is really going on.

Making good use of these capabilities should go a long way towards easing the differences between ClojureScript and Clojure =ns= forms.

** Project Templates
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/project-templates.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/project-templates
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/guides/project-templates
:END:
*** Leiningen
  :PROPERTIES:
  :CUSTOM_ID: leiningen
  :END:

-  [[https://github.com/swannodette/mies][mies]] Minimal ClojureScript project template

-  [[https://github.com/bhauman/figwheel-template][figwheel-template]] A Leinigen template for live coding with figwheel (includes Reagent and Om variants)

-  [[https://github.com/plexus/chestnut][chestnut]] Application template for ClojureScript/Om with live reloading

-  [[https://github.com/magomimmo/cljs-start][cljs-start]] A lein template for creating ClojureScript lib with batteries included

-  [[https://github.com/priyatam/mala][mala]] A lein template for building UIs in 100% Clojurescript, with Om, Garden, and curated libs

-  [[https://github.com/reagent-project/reagent-template][reagent-template]] A Leiningen template for projects using Reagent

-  [[https://github.com/Day8/re-frame-template][re-frame-template]] Leiningen template for reagent web app based on the re-frame pattern. Includes figwheel and optionally re-com and secretary

-  [[https://github.com/karad/lein_template_descjop][descjop]] A Leiningen template for Web based desktop application with Electron(atom-shell) and others

-  [[https://github.com/ducky427/electron-template][electron-template]] A Leiningen template for creating Electron based ClojureScript projects with support for Reagent

*** Boot
  :PROPERTIES:
  :CUSTOM_ID: boot
  :END:

-  [[https://github.com/martinklepsch/tenzing][tenzing]] Clojurescript application template using Boot

-  [[https://github.com/pandeiro/jamal][jamal]] Basic ClojureScript frontend repo with testing using Boot

-  [[https://github.com/Deraen/saapas][saapas]] A complete frontend and backend example using Boot

*** Shadow CLJS
  :PROPERTIES:
  :CUSTOM_ID: shadow-cljs
  :END:

-  [[https://github.com/filipesilva/create-cljs-app][create-cljs-app]] Set up a modern CLJS web app by running one command.

** Promise interop
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/promise-interop.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/promise-interop
:CLOJURESCRIPT_SITE_AUTHOR: Filipe Silva
:CLOJURESCRIPT_SITE_DATE: 2019-10-03
:CUSTOM_ID: content/guides/promise-interop
:END:
*** Using JavaScript promises directly
  :PROPERTIES:
  :CUSTOM_ID: using-javascript-promises-directly
  :END:

Promises are a common way of handling asynchronous operations in JavaScript. You can just as easily use them in ClojureScript by calling the promise methods.

*JavaScript:*

#+BEGIN_EXAMPLE
    Promise.resolve(42)
      .then(val => console.log(val));
#+END_EXAMPLE

*ClojureScript:*

#+BEGIN_SRC clojure
    (.then (js/Promise.resolve 42)
           #(js/console.log %))
#+END_SRC

However, chained promise methods in ClojureScript results in cascading code. Using the [[https://cljs.github.io/api/cljs.core/#-GT][thread-first macro]] we can can get back to more elegant code.

*JavaScript:*

#+BEGIN_SRC clojure
    Promise.resolve(42)
      .then(val => console.log(val))
      .catch(err => console.log(err))
      .finally(() => console.log('cleanup'));
#+END_SRC

*ClojureScript:*

#+BEGIN_EXAMPLE
    (.finally
      (.catch
      (.then (js/Promise.resolve 42)
              #(js/console.log %))
      #(js/console.log %))
      #(js/console.log "cleanup"))

    ; same as above
    (-> (js/Promise.resolve 42)
        (.then #(js/console.log %))
        (.catch #(js/console.log %))
        (.finally #(js/console.log "cleanup")))
#+END_EXAMPLE

Promise-heavy code that uses =await= results in more complicated code structures that aren't very friendly. Take this example from [[https://github.com/GoogleChrome/puppeteer#usage][Puppeteer usage]]:

*JavaScript:*

#+BEGIN_EXAMPLE
    const puppeteer = require('puppeteer');

    (async () => {
      const browser = await puppeteer.launch();
      const page = await browser.newPage();
      try {
        await page.goto('https://example.com');
        await page.screenshot({path: 'example.png'});
      } catch (err) {
        console.log(err);
      }

      await browser.close();
    })();
#+END_EXAMPLE

*ClojureScript:*

#+BEGIN_SRC clojure
    (def puppeteer (js/require "puppeteer"))

    (-> (.launch puppeteer)
        (.then (fn [browser]
                 (-> (.newPage browser)
                     (.then (fn [page]
                              (-> (.goto page "https://clojure.org")
                                  (.then #(.screenshot page #js{:path "screenshot.png"}))
                                  (.catch #(js/console.log %))
                                  (.then #(.close browser)))))))))
#+END_SRC

To tame this sort of code we turn to =core.async=.

*** Using Promises with core.async
  :PROPERTIES:
  :CUSTOM_ID: using-promises-with-core-async
  :END:

ClojureScript offers excellent facilities for async programming in [[https://github.com/clojure/core.async][core.async]]. One especially handy tool is the =<p!= macro, that consumes a promise inside a [[https://clojure.github.io/core.async/#clojure.core.async/go][=go= block]].

Using =go= blocks allows us to write code that looks synchronous even though it's actually asynchronous, exactly like =await= and =async= do in JavaScript.

*ClojureScript:*

#+BEGIN_SRC clojure
    (:require
       [cljs.core.async :refer [go]]
       [cljs.core.async.interop :refer-macros [<p!]])

    (def puppeteer (js/require "puppeteer"))

    (go
      (let [browser (<p! (.launch puppeteer))
            page (<p! (.newPage browser))]
        (try
          (<p! (.goto page "https://clojure.org"))
          (<p! (.screenshot page #js{:path "screenshot.png"}))
          (catch js/Error err (js/console.log (ex-cause err))))
        (.close browser)))
#+END_SRC

This is just scratching the surface. =core.async= gives you very powerful queue-like channels that can do much more than handle one-off promises.

You can read more about =core-async= in the [[https://github.com/clojure/core.async][repository]], [[https://clojure.org/news/2013/06/28/clojure-clore-async-channels][rationale]], [[https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj][code walkthrough]], and [[https://swannodette.github.io/2013/07/12/communicating-sequential-processes][blog post]].

** Quick Start
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/quick-start.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/quick-start
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2018-03-25
:CUSTOM_ID: content/guides/quick-start
:END:

If you are using macOS or Linux the only dependencies required for the main part of this tutorial are a web browser and an installation of [[https://clojure.org/guides/getting_started][Clojure]]. On Windows you will need [[http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html][Java 8]] and the [[https://github.com/clojure/clojurescript/releases/download/r1.10.758/cljs.jar][standalone ClojureScript JAR]]. Note that the requirement of a web browser excludes headless environments, and we then recommend skimming to the Node.js portion of the tutorial.

*** Hello, ClojureScript
  :PROPERTIES:
  :CUSTOM_ID: clojurescript-compiler
  :END:

In this tutorial we will guide you through compiling and running a simple ClojureScript project, as well as running REPLs to interactively develop and test your code. The tutorial only assumes basic familiarity with the command line.

First set up a project folder for our Hello World program. Here's a list of the files and folders you'll need. Note that the directory structure and the underscores in the names are important and should not be changed.

#+BEGIN_EXAMPLE
    hello-world        # Our project folder
    ├─ src             # The CLJS source code for our project
    │  └─ hello_world  # Our hello_world namespace folder
    │     └─ core.cljs # Our main file
    ├─ cljs.jar        # (Windows only) The standalone Jar you downloaded earlier
    └─ deps.edn        # (macOS/Linux only) A file for listing our dependencies
#+END_EXAMPLE

If you are on macOS or Linux your =deps.edn= file should contain the following:

#+BEGIN_SRC clojure
    {:deps {org.clojure/clojurescript {:mvn/version "1.10.758"}}}
#+END_SRC

In your favorite text editor edit the =src/hello_world/core.cljs= to look like the following:

#+BEGIN_SRC clojure
    (ns hello-world.core)

    (println "Hello world!")
#+END_SRC

Now that we have a simple program, let's build and run some ClojureScript. Make sure you are in the =hello-world= project directory and run the following command:

#+BEGIN_SRC sh
    clj -M --main cljs.main --compile hello-world.core --repl
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main --compile hello-world.core --repl
#+END_SRC

Your default web browser will open to a page that looks like the following:

[[/images/content/guides/quick-start/browser.png]]

If you are running Linux and the REPL does not start, try disabling browser auto-launch and opening =http://localhost:9000= manually:

#+BEGIN_SRC sh
    clj -M --main cljs.main --repl-opts "{:launch-browser false}" --compile hello-world.core --repl
#+END_SRC

After a couple of seconds you will see =Hello world!= print at the terminal and you will be given a REPL prompt. Try evaluating some expressions like the following:

#+BEGIN_SRC clojure
    (inc 1)
    (map inc [1 2 3])
    (.getElementById js/document "app")
#+END_SRC

Let's look a bit closer at the flags we've used here. =--main= invokes a /Clojure/ function, in this case =cljs.main=. The =cljs.main= function supports a variety of command line arguments to specify common tasks. We're using =--compile= to specify that we want to compile the =hello-world.core= namespace. This is followed by =--repl= to say that we want a REPL to launch immediately when compilation completes.

Change your =src/hello_world/core.cljs= source file to look like the following:

#+BEGIN_SRC clojure
    (ns hello-world.core)

    (println "Hello world!")

    ;; ADDED
    (defn average [a b]
      (/ (+ a b) 2.0))
#+END_SRC

At the REPL prompt, recompile and reload your namespace by evaluating the following:

#+BEGIN_SRC clojure
    (require '[hello-world.core :as hello] :reload)
    (hello/average 20 13)
#+END_SRC

You should see the result =16.5=.

Let's make a mistake. Try evaluating =(ffirst [1])=. You should get a source mapped stack trace pointing at ClojureScript source locations not JavaScript ones. This makes debugging a lot nicer.

You can easily explore the options provided by the ClojureScript compiler by using =--help=. You will see there are abbreviated flags for all the options we used thus far.

#+BEGIN_SRC sh
    clj -M -m cljs.main --help
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main --help
#+END_SRC

One important thing to note is that so-called main options like =--compile=, =--main=, =--repl= must always come last.

*** Production Builds
  :PROPERTIES:
  :CUSTOM_ID: production-builds
  :END:

You may have noticed the =out= directory which contains all of the compiled JavaScript. There's about 6 1/2 megabytes worth of JavaScript in there. This may seem unwieldy but fortunately the ClojureScript compiler generates output optimized for the Google Closure Compiler. The Google Closure Compiler performs many optimizations and the most significant for browser-based clients are minification and dead code elimination.

Let's remove the REPL modifications we made earlier from =src/hello_world/core.cljs=:

#+BEGIN_SRC clojure
    (ns hello-world.core)

    (println "Hello world!")
#+END_SRC

We can create a release build by setting the appropriate value for the =--optimizations= flag. The default optimization level is =none=, but this time we want to use all the optimizations provided by both ClojureScript and Google Closure Compiler - this can be done by specifying =advanced=. Other valid options for =--optimizations= are =whitespace= and =simple= but these are less commonly used:

#+BEGIN_SRC clojure
    clj -M -m cljs.main --optimizations advanced -c hello-world.core
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main --optimizations advanced -c hello-world.core
#+END_SRC

This process will take significantly longer which is why we don't use this compilation mode for development.

Examine =out/main.js=, the file size should be around 90K. If you zip this file you'll see that it's around 20K. This is significantly smaller than a jQuery dependency yet when using ClojureScript you have implicit dependencies on the entire ClojureScript standard library (10KLOC) and the Google Closure Library (300KLOC). You can thank dead code elimination.

You can test that this file still works by running the built in simple web server via the =--serve= flag:

#+BEGIN_SRC sh
    clj -M -m cljs.main --serve
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main --serve
#+END_SRC

This command does not start a REPL, so a browser window will not be automatically opened. Navigate to [[http://localhost:9000]] using your favorite browser. Check the JavaScript Console, you should see =Hello world!= printed. The builtin web server gzips JavaScript content. Check your browser's JavaScript Console Network tab and you should be able to confirm that the total JavaScript payload is now around 20K.

*** Running ClojureScript on Node.js
  :PROPERTIES:
  :CUSTOM_ID: running-clojurescript-on-node.js
  :END:

First make sure you have Node.js installed. For instructions on installing Node.js, see the [[https://github.com/nodejs/node/blob/master/README.md][Node.js wiki]]. Only the current stable versions of Node.js (>= =0.12.X=) are supported at this time.

Before we proceed, enable source mapping:

#+BEGIN_SRC sh
    npm install source-map-support
#+END_SRC

Let's build your Node project. We can specify that we want to generate code for a specific JavaScript target with =--target=. If no =--target= flag is supplied, ClojureScript generates code for browsers. We're also using =--output-to= here for specifying the =--output-to= file:

#+BEGIN_SRC sh
    clj -M -m cljs.main --target node --output-to main.js -c hello-world.core
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main --target node --output-to main.js -c hello-world.core
#+END_SRC

You can run your file with:

#+BEGIN_SRC sh
    node main.js
#+END_SRC

#+BEGIN_QUOTE
  *Note*

  *Note*: Under Node.js there is little reason to use advanced optimizations. While advanced optimizations does apply performance related optimizations, these are now largely obviated by optimizations present in modern JavaScript virtual machines like V8, SpiderMonkey, and JavaScriptCore. For Node.js, =simple= or =none= optimizations suffice.
#+END_QUOTE

**** Node.js REPL
   :PROPERTIES:
   :CUSTOM_ID: node.js-repl
   :END:

Running a Node.js REPL is similar to running a browser REPL. In order to specify a REPL which uses a different JavaScript evaluation environment you supply =--repl-env=. This value defaults to the browser REPL but in this case we want to specify =node=.

#+BEGIN_SRC sh
    clj -M -m cljs.main --repl-env node
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main --repl-env node
#+END_SRC

All the previously described REPL interactions for the browser should work.

*** Dependencies
  :PROPERTIES:
  :CUSTOM_ID: dependencies
  :END:

ClojureScript supports a wide variety of options for including ClojureScript and JavaScript dependencies (see [[file:xref/../../../reference/dependencies][Dependencies]] for details).

[[http://facebook.github.io/react/][React]] is a popular dependency for ClojureScript projects. [[http://cljsjs.github.io][CLJSJS]] provides a [[https://github.com/cljsjs/packages/tree/master/react][bundled version]]. Let's see how to include it.

Modify your =deps.edn= file:

#+BEGIN_SRC clojure
    {:deps {org.clojure/clojurescript {:mvn/version "1.10.758"}
            cljsjs/react-dom {:mvn/version "16.2.0-3"}}}
#+END_SRC

Let's edit our simple program to look like the following so that React is properly required:

#+BEGIN_SRC clojure
    (ns hello-world.core
      (:require react-dom))

    (.render js/ReactDOM
      (.createElement js/React "h2" nil "Hello, React!")
      (.getElementById js/document "app"))
#+END_SRC

Let's build and run:

#+BEGIN_SRC sh
    clj -M -m cljs.main -c hello-world.core -r
#+END_SRC

When the browser launches you should momentarily see the default page which will then be quickly replaced by a =h2= tag containing =Hello React!=.

** Optional self-hosting
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/self-hosting.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/self-hosting
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/guides/self-hosting
:END:

This page documents advice for people wanting to build ClojureScript projects that want or need to leverage =cljs.js/eval-str= and other self-hosted functionality.

#+BEGIN_QUOTE
  *Warning*

  If you are building a web application where the final size of the deployed artifact matters significantly, you should not be using any of the functionality outlined on this page.
#+END_QUOTE

*** Production Builds
  :PROPERTIES:
  :CUSTOM_ID: production-builds
  :END:

You can leverage up to =:optimization :simple= with builds that include the =cljs.js= namespace. Other recommended settings:

#+BEGIN_SRC clojure
    :pretty-print false
    :optimize-constants true
    :static-fns true
#+END_SRC

=:optimize-constants= is significant for code size, all literal keywords and symbols in your source will be compiled into a single lookup table.

=:static-fns true= is especially important if you are targeting Safari / JavaScriptCore. (See [[https://clojure.atlassian.net/browse/CLJS-1381][CLJS-1381]] for details.)

By default for ease of use =cljs.js/empty-state= will dump the analysis cache for =cljs.core= directly into the =cljs.js= namespace. This doubles the size of the final artifact. You can disable this with setting =:dump-core false= in your compiler build options.

This means you will need to load the analysis for core yourself. It's easy to dump the core analysis cache. In your ClojureScript project load a /Clojure/ REPL and do something like the following:

#+BEGIN_SRC clojure
    (require '[clojure.java.io :as io]
             '[cognitect.transit :as transit])
    (import [java.io ByteArrayOutputStream])

    (def out-path
      "../../assets/js/cljs/core.cljs.cache.aot.json")
    (def out (ByteArrayOutputStream. 1000000))
    (def writer (transit/writer out :json))

    (def cache
      (read-string
        (slurp (io/resource "cljs/core.cljs.cache.aot.edn"))))

    (transit/write writer cache)

    (spit (io/file out-path) (.toString out))
#+END_SRC

Then in your /ClojureScript/ source you can load this cache - for example that might look something like this:

#+BEGIN_SRC clojure
    (def st (cljs.js/empty-state))

    ;; path to Transit encoded analysis cache
    (def cache-url "/assets/js/cljs/core.cljs.cache.aot.json")

    (defn main []
      (http/get cache-url
        (fn [json]
          (let [rdr   (transit/reader :json)
                cache (transit/read rdr json)]
            (cljs.js/load-analysis-cache! st 'cljs.core cache)
            ;; ...
            ))))
#+END_SRC

This simple optimization eliminates about 2.7mb of generated JavaScript.

** ClojureScript with Webpack
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/guides/webpack.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/guides/webpack
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2018-06-15
:CUSTOM_ID: content/guides/webpack
:END:

*This guide requires ClojureScript 1.10.741 or later and assumes familiarity with the [[file:xref/../../guides/quick-start][Quick Start]]*.

This page documents how to integrate ClojureScript with a typical JavaScript bundler such as [[http://webpack.js.org][Webpack]]. You should have [[http://nodejs.org][Node.js]] installed. This guide assumes you have read through the Quick Start. This guide borrows liberally from this [[https://scotch.io/tutorials/setup-a-react-environment-using-webpack-and-babel][excellent guide on Webpack 2]].

While we happen to use Webpack here, these instructions are easily adapted to other bundlers like Metro for React Native.

*** Setting Up Your Project
  :PROPERTIES:
  :CUSTOM_ID: setting-up
  :END:

First create a project directory:

#+BEGIN_EXAMPLE
    mkdir hello-bundler
    cd hello-bundler
#+END_EXAMPLE

Create a =deps.edn= file the following contents:

#+BEGIN_EXAMPLE
    {:deps {org.clojure/clojurescript {:mvn/version "1.10.741"}}}
#+END_EXAMPLE

Create an empty =package.json= file:

#+BEGIN_EXAMPLE
    echo "{}" > package.json
#+END_EXAMPLE

Add webpack and its command line tools:

#+BEGIN_EXAMPLE
    npm install --save-dev webpack webpack-cli
#+END_EXAMPLE

We're now ready to setup our JS dependencies.

**** JavaScript Dependencies
   :PROPERTIES:
   :CUSTOM_ID: javascript-dependencies
   :END:

Install react and react-dom:

#+BEGIN_EXAMPLE
    npm install --save react react-dom
#+END_EXAMPLE

Now create =src/hello_bundler/core.cljs= with the following contents:

#+BEGIN_EXAMPLE
    (ns hello-bundler.core
      (:require [react]))

    (.log js/console react/Component)
#+END_EXAMPLE

Notice that we are requiring React as if it was a normal require and a normal namespace.

In order for this to work we need to set a couple of compiler options. Create a =build.edn= file with the following:

#+BEGIN_EXAMPLE
    {:main hello-bundler.core
     :output-to "out/index.js"
     :output-dir "out"
     :target :bundle
     :bundle-cmd {:none ["npx" "webpack" "./out/index.js" "-o" "out" "--mode=development"]
                  :default ["npx" "webpack" "./out/index.js" "-o" "out"]}
     :closure-defines {cljs.core/*global* "window"}} ;; needed for advanced
#+END_EXAMPLE

Our build will generate =out/index.js= which is exactly the entry file that Webpack is looking for. We'll write the bundler result back into the output directory.

Note the new =:target :bundle= option. This ensures that the generated code is compatible with popular JavaScript bundlers that can handle Node.js style =require=. It also sets a bunch of other sensible defaults like externs inference, so that advanced compilation will just work. =:bundle-cmd= is just an arbitrary shell command to run after the ClojureScript build completes. In the case of watching bundlers like Metro you probably won't bother with =:bundle-cmd=.

Let's see this in action, the following will build your project then start a REPL:

#+BEGIN_EXAMPLE
    clj -M -m cljs.main -co build.edn -v -c -r
#+END_EXAMPLE

Your default browser will open [[http://localhost:9000]]. Open the Developer Console, you should see that =React.Component= got logged.

At the REPL you can require =react= and interact with it:

#+BEGIN_EXAMPLE
    user> (require 'react)
#+END_EXAMPLE

*** Overriding a Foreign Library
  :PROPERTIES:
  :CUSTOM_ID: overriding-foreign-lib
  :END:

You may find that you want to use React from =node_modules= perhaps because the latest bundled version hasn't yet appeared on CLJSJS. Yet, you still want to use some ClojureScript React binding like Reagent. ClojureScript supports this out of the box.

To demonstrate this, change your =deps.edn= to the following:

#+BEGIN_EXAMPLE
    {:deps {org.clojure/clojurescript {:mvn/version "1.10.741"}
            reagent {:mvn/version "0.10.0" :exclusions [cljsjs/react cljsjs/react-dom]}}}
#+END_EXAMPLE

Change your source file to the following:

#+BEGIN_EXAMPLE
    (ns hello-bundler.core
      (:require [goog.dom :as gdom]
                [reagent.dom :as dom]))

    (defn simple-component []
      [:div
       [:p "I am a component!"]
       [:p.someclass
        "I have " [:strong "bold"]
        [:span {:style {:color "red"}} " and red "] "text."]])

    (dom/render [simple-component] (gdom/getElement "app"))
#+END_EXAMPLE

Rebuild your project, run the REPL:

#+BEGIN_EXAMPLE
    clj -M -m cljs.main -co build.edn -v -c -r
#+END_EXAMPLE

To verify that externs inference allows advanced compilation to work, let's make an advanced build. REPLs don't work under advanced compilation so you'll have to manually open [[http://localhost:9000]]:

#+BEGIN_EXAMPLE
    clj -M -m cljs.main -co build.edn -O advanced -v -c -s
#+END_EXAMPLE

That's it!

*** Building Webworkers
  :PROPERTIES:
  :CUSTOM_ID: webworkers
  :END:

When building webworkers with =:target :bundle=, you use webpack (or your preferred bundler) to add the webworker bootstrap.

So your build's =:target= will still be =:bundle= (not =:webworker=), but you will tell your bundler to build a webworker. For example, with webpack you add the =--target=webworker= argument to your =:bundle-cmd= entries.

You also need to define =cljs.core/global= as ="self"= (as opposed to ="window"= in browser builds).

An example =build-webworker.edn= might look like:

#+BEGIN_EXAMPLE
    {:main hello-bundler.webworker
     :output-to "out/worker/index.js"
     :output-dir "out/worker"
     :target :bundle
     :bundle-cmd {:none ["npx" "webpack" "out/worker/index.js" "-o" "out/worker/main.js" "--target=webworker" "--mode=development"]
                  :default ["npx" "webpack" "out/worker/index.js" "-o" "out/worker/main.js" "--target=webworker"]}
     :closure-defines {cljs.core/*global* "self"}} ;; needed for advanced
#+END_EXAMPLE

* News
** [2017-06-26] Welcome to ClojureScript News!
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-06-26-welcome.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-06-26-welcome
:CLOJURESCRIPT_SITE_AUTHOR: Alex Miller
:CLOJURESCRIPT_SITE_DATE: 2017-06-26
:CUSTOM_ID: content/news/2017-06-26-welcome
:END:

Welcome to the new ClojureScript news area! We'll have posts available here about important releases, features, and news.

** [2017-06-27] Faster Compilation/Runtime and Spec Caching Fixes
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-06-27-faster-compilation-runtime-and-spec-caching-fixes.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-06-27-faster-compilation-runtime-and-spec-caching-fixes
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2017-06-27
:CUSTOM_ID: content/news/2017-06-27-faster-compilation-runtime-and-spec-caching-fixes
:END:

Several exciting performance enhancements are in the ClojureScript 1.9.660 release. Some improvements speed up the compiler itself, others optimize the code generated by the compiler, and yet others fine tune data structures and common operations upon them.

*** Compiler Performance
  :PROPERTIES:
  :CUSTOM_ID: _compiler_performance
  :END:

With two small changes the compiler now compiles ClojureScript code much faster. Users have reported 20--40% faster compile times.

Don't forget to try =:parallel-build=, which is not enabled by default. This can further cut your compile times in half.

*** Code Performance
  :PROPERTIES:
  :CUSTOM_ID: _code_performance
  :END:

-  =:^const= Var values are now inlined

-  =sort=, =shuffle= is now 30-40% faster (thanks to =to-array= optimization)

-  =apply= is 200-400% faster

-  =defmulti= is now much faster in the case of a miss (200-1000%)

-  set and map equivalence is 100-200% faster

-  =reduce= on sets and maps is now ~100% faster

*** Correctness
  :PROPERTIES:
  :CUSTOM_ID: _correctness
  :END:

Many correctness fixes have been made, several of them bringing ClojureScript more in line with Clojure behavior. Other important fixes were made with respect to compilation caching; notably code defining Specs now works properly when caching is enabled.

#+BEGIN_QUOTE
  *NOTE*: that this release introduces a new warning for incorrect code which employs variadic signatures in protocol method implementations. Such code will continue to work with this release. Be sure to update any code or libraries that make use of this construct so that protocol implementations match some existing signature.
#+END_QUOTE

*** New Features
  :PROPERTIES:
  :CUSTOM_ID: _new_features
  :END:

-  A new =resolve= macro - like Clojure's but at compile-time

-  Modules support wildcard namespaces

-  New Closure language options =:es-2017=, =:es-next=

-  A new compiler option =:fn-invoke-direct= (a futher optimization extension to =:static-fns=)

-  You can use =js/Promise= and many more ES features and have Google Closure Compiler generate polyfills (=:rewrite-polyfills= compiler option)

You should definitely give this release a try on your code to see how it performs! We hope you enjoy this release!

For a complete list of updates in ClojureScript 1.9.660 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#19660][Changes]].

** [2017-07-07] Sneak Preview
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-07-07-sneak-preview.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-07-07-sneak-preview
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2017-07-07
:CUSTOM_ID: content/news/2017-07-07-sneak-preview
:END:

ClojureScript's sixth birthday is fast approaching and will land on the second day of [[http://2017.euroclojure.org][EuroClojure]]. To celebrate we will be publishing a series of posts over the next two weeks covering a variety of new and exciting features slated for the next release.

Stay tuned!

** [2017-07-10] Enhanced Code Splitting {amp} Loading
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-07-10-code-splitting.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-07-10-code-splitting
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2017-07-10
:CUSTOM_ID: content/news/2017-07-10-code-splitting
:END:

This is the first post in the [[file:2017-07-07-sneak-preview][Sneak Preview]] series.

As client applications increase in size it becomes desirable to optimize the time to load a logical screen. Network requests should be minimized while at the same the loaded code should be restricted to that which is absolutely necessary to produce a functioning screen. While tools like [[https://webpack.github.io][Webpack]] have popularized this optimization technique in the JavaScript mainstream, Google Closure Compiler and Library have supported this same optimization strategy in the form of Google Closure Modules for many years now.

Google Closure Modules also provide some unique advantages over tools like Webpack or [[http://rollupjs.org][Rollup]] which we will cover in the technical section of this post. In short, we optimally assign all sources to modules after which Google Closure Compiler employs dead code elimination (tree shaking) and cross module code motion to produce truly optimal splits.

While ClojureScript has provided basic integration with this facility for some time, the next release will feature greatly enhanced and comprehensive support for code splitting and asynchronous loading of these splits.

*** Terminology
  :PROPERTIES:
  :CUSTOM_ID: _terminology
  :END:

If you are familiar with Webpack terminology, in the following description please take note that *module* in this context refers to a *code split* or *chunk*.

By *entry point* we mean a source file which represents a logical entry point into your application (login, users, admin, etc.).

*** Enhanced Code Splitting
  :PROPERTIES:
  :CUSTOM_ID: _enhanced_code_splitting
  :END:

It is no longer necessary to hand-optimize module assignment of your sources. All sources will be optimally assigned to a module based upon the dependency graph of your application. If you have a module with many manual assignments you should now remove these. If you were using namespace wildcard matching, this is also no longer necessary. For details about how we assign an input to a particular module see the technical description below.

Concretely, the following is now an anti-pattern:

#+BEGIN_EXAMPLE
    {:modules
      {:vendor {:output-to "..."
                :entries '#{cljsjs.react reagent.* re-frame.*}}
       :main   {:output-to "..."
                :entries '#{myapp.core}
                :depends-on [:vendor]}}
#+END_EXAMPLE

Previously you would have to manually pin a source (=re-frame= in this case) and its dependencies to a module. Now all that is required is:

#+BEGIN_EXAMPLE
    {:modules
      {:vendor {:output-to "..."
                :entries '#{re-frame.core}
       :main   {:output-to "..."
                :entries '#{myapp.core}
                :depends-on [:vendor]}}
#+END_EXAMPLE

Another significant enhancement is that =:modules= now works under all optimization settings. By unifying =:modules= behavior under all compilation modes we eliminate a bit of incidental complexity around build configuration between development and production.

*** cljs.loader
  :PROPERTIES:
  :CUSTOM_ID: _cljs_loader
  :END:

Asynchronous loading of module splits is now standardized with the introduction of the =cljs.loader= namespace. If any entry point in your application needs to invoke the load of another module due to some user action, you can now do so with =cljs.loader=.

=cljs.loader= provides a shared Google Closure [[https://google.github.io/closure-library/api/goog.module.ModuleManager.html][ModuleManager]] singleton automatically initialized to your =:modules= graph regardless of the optimization level.

The following is a simple short example of =cljs.loader= functionality:

#+BEGIN_EXAMPLE
    (ns views.user
     (:require [cljs.loader :as loader]
               [goog.dom :as gdom]
               [goog.events :as events])
     (:import [goog.events EventType]))

    (events/listen (gdom/getElement "admin") EventType.CLICK
      (fn [e]
        (loader/load :admin
          (fn [e]
            ((resolve 'views.admin/init!))))))

    (loader/set-loaded! :user)
#+END_EXAMPLE

Note that this example shows how to call across module boundaries without having the compiler complain about functionality not present in this code split. This is possible thanks to the recent inclusion of static =resolve= to the standard library.

For a complete walk through of the enhanced =:modules= functionality please refer to the [[https://clojurescript.org/guides/code-splitting][new guide]].

*** Technical Description
  :PROPERTIES:
  :CUSTOM_ID: _technical_description
  :END:

The following highlights some interesting technical details of the enhanced modules functionality.

**** Module Assignment
   :PROPERTIES:
   :CUSTOM_ID: _module_assignment
   :END:

This section briefly describes the algorithm employed to automatically assign every source file to a module.

Assume a simplified module description like:

#+BEGIN_EXAMPLE
    {:modules {:module-a {:entries '#{foo.core}}
               :module-b {:entries '#{bar.core}}}
#+END_EXAMPLE

This will be transformed into a module description that includes the implicit base module =:cljs-base=.

#+BEGIN_EXAMPLE
    {:modules {:cljs-base {:entries []}
               :module-a  {:entries '#{foo.core}
                           :depends-on [:cljs-base]}
               :module-b  {:entries '#{bar.core}
                           :depends-on [:cljs-base]}}
#+END_EXAMPLE

We will then compute the depth of every module in the graph:

#+BEGIN_EXAMPLE
    {:modules {:cljs-base {:entries [] :depth 0}
               :module-a  {:entries '#{foo.core} :depth 1
                           :depends-on [:cljs-base]}
               :module-b  {:entries '#{bar.core} :depth 1
                           :depends-on [:cljs-base]}}
#+END_EXAMPLE

We then use this to compute a mapping from all depended upon inputs to a set of possible module assignments. For example we find all dependencies of =foo.core= and we assume they will go into =:module-a= - even =cljs.core=, the standard library.

But of course =:module-b= will also assign =cljs.core= to itself. So =cljs.core= module assignment is =[:module-a :module-b]=. However we can only choose one. To choose we first find all the common parent modules. Once found, we pick the module with the greatest =:depth= value.

Finally, any orphans will be assigned to =:cljs-base=.

Readers familiar with Webpack will note that this approach treats splits and split loading as two independent concerns. Thus split definition does not require editing sources nor the introduction of additional plugins.

**** Cross Module Code Motion
   :PROPERTIES:
   :CUSTOM_ID: _cross_module_code_motion
   :END:

Automatic module assignment pushes code upwards to produce code splits that match user expectations. However if we left it at that we would be missing a huge opportunity. Along with dead code elimination Google Closure Complier employs another useful optimization - *cross module code motion*. Individual program values (including functions and methods) which are free of side effects can be moved /back down/ the module graph.

A functional programming language like Clojure is well suited for this kind of optimization and the ClojureScript compiler carefully generates code in many cases to take advantage of this capability.

In practice this means that if some function and its dependencies present in =:cljs-base= are only ever used in =:module-a=, they will all be moved back to =:module-a=.

*** Conclusion
  :PROPERTIES:
  :CUSTOM_ID: _conclusion
  :END:

While Google documented these capabilities in [[http://shop.oreilly.com/product/0636920001416.do][Closure: The Definitive Guide]] published in 2010, we believe they still represent the state of the art. Please give these enhancements a try in the next release!

** [2017-07-12] ClojureScript is not an Island: Integrating Node Modules
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules
:CLOJURESCRIPT_SITE_AUTHOR: António Nuno Monteiro
:CLOJURESCRIPT_SITE_DATE: 2017-07-12
:CUSTOM_ID: content/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules
:END:

This is the second post in the [[https://clojurescript.org/news/2017-07-07-sneak-preview][Sneak Preview]] series.

ClojureScript has had first class JavaScript interop since its initial release in 2011. Similarly to Clojure, embracing the host has always been an explicit goal. While the above is true from a syntax standpoint, integrating with external JavaScript libraries historically came at the cost of some manual work [fn:1] ([[https://clojurescript.org/reference/compiler-options#foreign-libs][manually assembled]] bundles or packaging led by [[http://github.com/cljsjs/packages][community efforts]]).

*** A step towards better interaction with external JavaScript
  :PROPERTIES:
  :CUSTOM_ID: _a_step_towards_better_interaction_with_external_javascript
  :END:

The 2015 Google Summer of Code project for ClojureScript succeeded in making the interaction with foreign JavaScript modules easier. Relying on the [[https://developers.google.com/closure/compiler/][Google Closure Compiler]]'s then new ability to understand most widely known JavaScript module formats and convert them to Closure compatible JavaScript [fn:2], [[https://github.com/MNeise][Maria Geller]] successfully integrated those module features into ClojureScript, along with [[https://clojurescript.org/guides/javascript-modules#babel-transforms][custom preprocessing]] steps that allow using features such as the popular JavaScript compilation technology [[http://babeljs.io/][Babel]] from the comfort of your ClojureScript project [fn:3].

Since then, the Closure Compiler team added module /resolution/ support in 2016, which among other things enables consuming modules directly from a =node_modules= installation instead of having to feed Closure handcrafted module paths for conversion.

*** Seamless interaction with NPM dependencies
  :PROPERTIES:
  :CUSTOM_ID: _seamless_interaction_with_npm_dependencies
  :END:

We have built on Maria's modules work to account for this new Closure feature, and the next release of ClojureScript represents yet another major milestone in making arbitrary JavaScript modules accessible to every ClojureScript project by including substantial improvements to the way that ClojureScript interoperates with the NPM ecosystem.

[[https://anmonteiro.com/2017/03/requiring-node-js-modules-from-clojurescript-namespaces/][Requiring NPM modules from ClojureScript namespaces]] has been possible since ClojureScript version 1.9.518. However, Node.js supports multiple patterns for requiring CommonJS modules, and a common painpoint was people looking to require modules of the form ="react-dom/server"= from ClojureScript, which would not be a valid symbol for the =:require= spec.

In this release, we added support for string-based requires in the namespace form to solve the above problem. You can now require these types of modules from the comfort of your =ns= declaration.

Gluing it all together is the =:npm-deps= compiler flag. In it, we tell the compiler which dependencies it should be aware of. ClojureScript will take care of installing those dependencies and running them through the Closure Compiler conversion pipeline, including optimizations which we describe in more detail below.

**** A practical example
   :PROPERTIES:
   :CUSTOM_ID: _a_practical_example
   :END:

Given a =build.clj= file like the following:

#+BEGIN_SRC clojure
    (require '[cljs.build.api :as b])

    (b/build "src"
      {:output-dir "out"
       :output-to "out/main.js"
       :optimizations :none
       :main 'example.core
       :install-deps true
       :npm-deps {:react "15.6.1"
                  :react-dom "15.6.1"}})
#+END_SRC

Your simplest =src/example/core.cljs= file could look like the snippet below:

#+BEGIN_SRC clojure
    (ns example.core
      (:require [react :refer [createElement]]
                ["react-dom/server" :as ReactDOMServer :refer [renderToString]]))

    (js/console.log (renderToString (createElement "div" nil "Hello World!")))
#+END_SRC

Notice we don't have to declare ="react-dom/server"= anywhere. We can just require it. ClojureScript is now smart enough to find these CommonJS modules and process them into Google Closure Compiler compatible code.

*** This is a big deal
  :PROPERTIES:
  :CUSTOM_ID: _this_is_a_big_deal
  :END:

The implications of consuming JavaScript modules with Google Closure are huge: the external libraries used in a ClojureScript project are no longer just prepended to the generated bundle, but can now be subjected to all of Closure Compiler's optimizations, including dead code elimination and, in projects that take advantage of [[https://clojurescript.org/news/2017-07-10-code-splitting][code splitting]], cross module code motion. For example, in our tests React is appreciable smaller (~16%) under Closure's advanced compilation than it would be using existing popular JavaScript tooling [fn:4]. Additionally, if you have a mixed codebase of ClojureScript and JavaScript, not only can you now seamlessly consume those JavaScript portions of your code (including e.g. JSX transformations!), but also share and bundle their vendor dependencies with the ones your ClojureScript part uses.

**** Works on Node.js too!
   :PROPERTIES:
   :CUSTOM_ID: _works_on_node_js_too
   :END:

It's worth noting that the module processing feature in ClojureScript is mostly intended to be used in projects that target the browser, where dependencies will normally be bundled together. But that doesn't mean projects targeting Node.js can't also take advantage of this feature. In fact, we made it so that you can also seamlessly require Node modules in a local =node_modules= installation from your namespace declaration when targeting Node.js. ClojureScript will know that you're requiring a Node module and produce a =require= declaration, integrating with Node.js's own facilities for loading JavaScript modules.

*** Parting thoughts
  :PROPERTIES:
  :CUSTOM_ID: _parting_thoughts
  :END:

ClojureScript is, after almost 6 years, a platform relied upon by a great number of developers worldwide, and we want to continue to deliver on full interoperability with the host. By making sure that we integrate with the vast JavaScript ecosystem out there, we think these new features arriving in the next version of ClojureScript are a stepping stone in assuring ClojureScript's sustainability long term.

We hope you enjoy these new features as much as we do. Thanks for reading!

[fn:1] aside from the [[https://developers.google.com/closure/library/][Google Closure Library]] which was deeply integrated since ClojureScript's initial release.

[fn:2] the subset of JavaScript that the Closure Compiler needs to perform optimizations such as dead code elimination (tree shaking), variable name rewriting, constant folding and inlining, among others.

[fn:3] Maria also kept a regular blog whilst working on that project that you can read [[http://mneise.github.io/][here]].

[fn:4] in fact, the Reagent team is already testing [[https://reagent-project.github.io/reagent-site-npm-deps-test/][a version of their website]] to consume NPM modules. They also [[https://twitter.com/JuhoTeperi/status/885228578098601984][compared it]] to the previous version

** [2017-07-14] Checked Array Access
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-07-14-checked-array-access.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-07-14-checked-array-access
:CLOJURESCRIPT_SITE_AUTHOR: Mike Fikes
:CLOJURESCRIPT_SITE_DATE: 2017-07-14
:CUSTOM_ID: content/news/2017-07-14-checked-array-access
:END:

This is the third post in the [[https://clojurescript.org/news/2017-07-07-sneak-preview][Sneak Preview]] series.

Much of the history of the ClojureScript compiler can be characterized by the themes of pragmatic expediency, followed by successive refinement. This is nicely illustrated by the history of =aget=.

The first minimum viable implementation of =aget= was a simple function. Six years ago it looked like this:

#+BEGIN_EXAMPLE
    (defn aget [array i]
       (js* "return ~{array}[~{i}]"))
#+END_EXAMPLE

This employs the internal =js*= special form to directly emit JavaScript which uses subscript notation for element access. It looks roughly like this:

#+BEGIN_EXAMPLE
    function aget(array, i) {
      return array[i];
    }
#+END_EXAMPLE

#+BEGIN_QUOTE
  Note that =js*= is not intended to be used in application-level ClojureScript code.
#+END_QUOTE

In the early history of the compiler, =js*= was employed fairly heavily in the runtime functions that ship with the ClojureScript standard library. Over time, raw usage of =js*= was removed entirely in the standard library and hidden behind reusable macros.

As time moved on, our friend =aget= (as well as =aset=) was refined to more closely match Clojure by allowing it to access nested array structures by using variadic arguments.

Readers familiar with JavaScript will note that the above =aget= implementation works perfectly well for JavaScript objects. This fact, like =js*=, was also abused in the early days of the standard library. Unfortunately, due to insufficient documentation about alternatives, users began to mimic this internal detail.

But =aget= was never designed to support this particular use. The “=a=-” family of functions (including =aclone=, =amap=, =areduce=) are all meant for /arrays/, not /objects/. The additional arguments to =aget= are numeric array indices, not string property names. Nevertheless, perhaps to the lure of ease, forms like

#+BEGIN_EXAMPLE
    (aget #js {:foo 1} "foo")
#+END_EXAMPLE

became heavily used in the wild to avoid the name mangling that comes with dotted property access and =:advanced= compilation. It was an accident of implementation that this worked at all, but nevertheless it became very popular.

One problem that this creates is a challenge in further evolving =aget= to match its intended purpose. A few examples that come to mind include:

-  In Clojure, if you pass a non-integer array index to =aget=, it will round down to the nearest integer. It would be nice to make ClojureScript's =aget= match this behavior. This is easily achievable by employing =int= in the implementation, causing the emitted JavaScript to look like =array[ndx|0]=. But this would break existing code that uses =aget= for object property access.

-  In Clojure, if you pass a negative array index, or one that is otherwise out-of-bounds, you'll get an exception. It would be nice to consider adding such safety mechanisms to ClojureScript's =aget=. But again, any attempt to blindly treat the indices as numbers would run afoul of =aget= being passed string indices.

-  In the future, perhaps core library functions will have specs written for them. The same issues arise: The indices passed to =aget= should satisfy the =number?= predicate, but if that were done, lots of code in the wild would be deemed non-conformant.

#+BEGIN_QUOTE
  This is of course not the first, nor likely the last time some language mechanism's internals will be discovered to suit some purpose other than what was intended. There is an interesting discussion, in /The Evolution of Lisp/ by Guy L. Steele Jr. and Richard P. Gabriel, of the discovery that MacLisp's =ERRSET= and =ERR= primitives could be used as a flow control mechanism, but while also unfortunately trapping unexpected errors. This prompted the introduction of =THROW= and =CATCH= primitives to MacLisp in 1972. The authors go on to say that “the pattern of design (careful or otherwise), unintended use, and later redesign is common.”
#+END_QUOTE

What /should/ you use for object property access, if =aget= and =aset= are reserved for arrays? ClojureScript makes the Google Closure library readily accessible, and there are some nice facilities worth checking out in the =goog.object= namespace. In particular, [[https://google.github.io/closure-library/api/goog.object.html#get][=goog.object/get=]] and [[https://google.github.io/closure-library/api/goog.object.html#set][=goog.object/set=]] are appropriate APIs, suited for this purpose. For example, this does what you'd want:

#+BEGIN_EXAMPLE
    (goog.object/get #js {:foo 1} "foo")
#+END_EXAMPLE

In fact, =goog.object/get= is safer in that it has checks that the object being passed is not =nil= and that the field being accessed actually exists on the object, allowing you to supply an alternative “not found” value to return if not. If you need to do nested property access, there is a [[https://google.github.io/closure-library/api/goog.object.html#getValueByKeys][=goog.object/getValueByKeys=]] that can also be considered as a drop-in replacement for a variadic =aget= call.

The ClojureScript standard library itself had places where =aget= and =aset= were being misused for object access, and these have been cleaned up. It turns out that =goog.object/get= is sufficiently performant to replace nearly all uses of =aget= for object access. In the relatively few places where it is not (in highly performance-critical areas in the standard library implmentation), the compiler makes use of a new internal =unchecked-get= macro to get the job done.

We'd encourage you to revise code you control to to ensure that the =aget= and =aset= are used only for array access, and to consider using the facilities in =goog.object= (either directly, or indirectly via a library such as [[https://github.com/binaryage/cljs-oops][cljs-oops]]) to access object properties.

*** New Compiler Enhancements
  :PROPERTIES:
  :CUSTOM_ID: _new_compiler_enhancements
  :END:

Towards this end, the upcoming ClojureScript release includes a new =:checked-arrays= compiler option which you can set to either =:warn= or =:error=. With either setting, the compiler will emit a new =:invalid-array-access= warning that indicates---when known via type inference---that =aget= or =aset= is operating on non-arrays or being supplied non-numeric indices. Additionally, the runtime values passed to =aget= and =aset= are checked. If =:checked-arrays= is set to =:warn=, warning logs will be generated when incorrectly-typed values or out-of-bounds array indices are passed. If set to =:error=, exceptions will be thrown instead.

For maximum performance, all such checking is eliminated for =:advanced= builds, with array access compiling down to efficient JavaScript array subscript notation.

This new compiler option can be utilized to highlight instances where these APIs are used for object property access. For example, =(aget #js {:foo 1} "foo")= will cause this warning to be emitted:

#+BEGIN_EXAMPLE
    WARNING: cljs.core/aget, arguments must be an array followed by numeric indices, got [object string] instead (consider goog.object/get for object access) at line 1
#+END_EXAMPLE

To enable this new facility, simply add

#+BEGIN_EXAMPLE
    :checked-arrays :warn
#+END_EXAMPLE

to your ClojureScript [[https://clojurescript.org/reference/compiler-options][compiler options]].

By carefully using the APIs in the ClojureScript standard library as intended, this facilitates evolution of the library, both with respect to correctness and performance. This is something we can all benefit from!

** [2017-07-20] Simpler JavaScript Preprocessing
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-07-20-js-preprocessing-improvements.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-07-20-js-preprocessing-improvements
:CLOJURESCRIPT_SITE_AUTHOR: Juho Teperi
:CLOJURESCRIPT_SITE_DATE: 2017-07-20
:CUSTOM_ID: content/news/2017-07-20-js-preprocessing-improvements
:END:

This is the fourth post in the [[/news/2017-07-07-sneak-preview][Sneak Preview]] series.

Closure compiler can process AMD, CommonJS and ES6 modules giving wide support for [[/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules][the Node ecosystem]]. Even so, there are popular cases which Closure doesn't support directly, such as [[https://facebook.github.io/react/][React's]] [[https://facebook.github.io/react/docs/introducing-jsx.html][JSX]]. [fn:1] Maria Geller's Google Summer of Code work also addressed this based on a design outlined by David Nolen and a preprocessing hook has been present since [[https://github.com/clojure/clojurescript/blob/master/changes.md#1748][version 1.7.48]]. However, the original design makes integration with other build tools challenging, and we've revised the approach to simplify such integrations.

*** Motivation
  :PROPERTIES:
  :CUSTOM_ID: _motivation
  :END:

JavaScript libraries using JSX or other syntax extensions are usually packaged with the already processed code so they can be used without further ceremony. Still, there are practical cases where one might want to include such code in the project directly. For example, when converting a project from JavaScript to ClojureScript it's far easier to reuse the existing code than attempt to rewrite everything in one go. Also, building sophisticated user interfaces is a team effort and tools like JSX can make that process far more welcoming by giving designers familiar tools. By allowing ClojureScript to reach JSX and other popular syntactical affordances, the ClojureScript development process can be more inclusive.

*** JavaScript transformation
  :PROPERTIES:
  :CUSTOM_ID: _javascript_transformation
  :END:

In the original design, preprocessing was enabled by providing =:preprocess= to a [[/reference/compiler-options#foreign-libs][foreign-lib map]]. The value is a keyword dispatch for the =cljs.closure/js-transforms= multimethod. Users can implement a new multimethod case and, for example, use Java's built-in [[http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html][Nashorn JavaScript]] engine to run a JavaScript compiler like [[https://babeljs.io/][Babel]].

However, this approach creates complications for popular Clojure and ClojureScript build tools. The Clojure namespace that provides the preprocess multimethod must be loaded by the user before the ClojureScript compiler is run. While this may be feasible in an explicit build script, due to how both [[https://leiningen.org][Leiningen]] and [[http://boot-clj.com][Boot]] isolate the build to their own classpaths, this requirement simply isn't practical.

There are a few ways to work around the original design:

1. Provide a new configuration option to enumerate the namespaces to =require= before running the compiler.

2. Create a relation between the multimethod dispatch keyword, and the namespace that provides the implementation. For example, if the keyword is namespaced, the namespace part of the keyword could be used to =require= that namespace on demand.

Both of these solutions could be implemented at the build tools or in the ClojureScript compiler directly. The first option seems circuitous from an end user perspective, and while the second option highlights the fundamental problem, using keywords for this pattern seems unidiomatic. If we simply switch to symbols from keywords, we can align with existing precedents.

**** Preprocess symbol
   :PROPERTIES:
   :CUSTOM_ID: _preprocess_symbol
   :END:

The next version of ClojureScript will support symbols as the =:preprocess= option value. Using a fully qualified symbol makes it obvious that the value refers to a function, and the namespace part of the symbol can be used to automatically load the namespace on the user's behalf.

[[https://github.com/cljsjs/packages/blob/master/babel-standalone/README.md][cljsjs/babel-standalone]] has been updated, and provides an easy way to use Babel with ClojureScript tooling following this new pattern.

**** Conclusion
   :PROPERTIES:
   :CUSTOM_ID: _conclusion
   :END:

Users familiar with Clojure's philosophy know that we prioritize simplicity above most other qualities. But, simplicity is not always at odds with ease, and in fact, has long been been a language priority with respect to interoperability with the host.

While Clojure has boasted excellent integration with Java for some time, for ClojureScript, the friction between Google Closure and mainstream JavaScript practice have made this promise more challenging to deliver.

We believe we are closing the gap and that the vast ecosystem of JavaScript libraries can now finally be close at hand.

[fn:1] There is [[https://github.com/mihaip/react-closure-compiler][third-party compiler pass]] for Closure to support JSX

** [2017-07-28] Release Candidate: 1.9.854
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-07-28-release-candidate.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-07-28-release-candidate
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2017-07-28
:CUSTOM_ID: content/news/2017-07-28-release-candidate
:END:

Rather than delay further, we've decided to push out a release candidate containing all of the features we have announced so far and a number of features we simply haven't had time to cover in depth. To summarize the highlights:

*** Comprehensive Node Modules Support
  :PROPERTIES:
  :CUSTOM_ID: _comprehensive_node_modules_support
  :END:

Whether you prefer [[https://www.npmjs.com][npm]] or [[http://yarnpkg.com][yarn]], ClojureScript can now consume dependencies from =node_modules= directly. There will be cases that don't work, but there will be many cases that do. We're particularly interested in feedback around this new capability. We expect to widen the scope of libraries the ClojureScript compiler can consume gradually over time.

*** JavaScript Module Preprocessing Enhancements
  :PROPERTIES:
  :CUSTOM_ID: _javascript_module_preprocessing_enhancements
  :END:

The new release supports an enhanced approach to preprocessing JavaScript files which should remove friction with popular ClojureScript build tooling.

*** Checked Arrays
  :PROPERTIES:
  :CUSTOM_ID: _checked_arrays
  :END:

ClojureScript can now check array operations. This feature encourages users to write idiomatic code while paving the way for further alignment with Clojure semantics.

*** Overhauled Code Splitting
  :PROPERTIES:
  :CUSTOM_ID: _overhauled_code_splitting
  :END:

ClojureScript now ships with overhauled code-splitting functionality that eliminates the need for manual optimization. This feature is also coupled with a standard mechanism for loading code splits.

*** Global Exports for Foreign Libraries
  :PROPERTIES:
  :CUSTOM_ID: _global_exports_for_foreign_libraries
  :END:

This feature has not yet received a post, but foreign libraries can now declare what they export. This means that foreign libraries can be treated as regular namespaces with all of the usual features (=:refer=, =:rename=, etc.). This enhancement also provides a smoother transition path from [[https://cljsjs.github.io][CLJSJS]] dependencies to [[https://www.npmjs.com][npm]] dependencies. Finally, for users bundling their JavaScript dependencies with [[http://webpack.js.org][Webpack]], this feature makes consuming these foreign builds considerably more idiomatic.

*** Fixes, Changes, Enhancements
  :PROPERTIES:
  :CUSTOM_ID: _fixes_changes_enhancements
  :END:

Thanks to the efforts of the ClojureScript community, this release contains a large number of fixes, changes, and enhancements. For a full list [[https://github.com/clojure/clojurescript/blob/master/changes.md#19854][look here]].

** [2017-07-30] Global Exports for Foreign Libraries
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-07-30-global-exports.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-07-30-global-exports
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2017-07-30
:CUSTOM_ID: content/news/2017-07-30-global-exports
:END:

Integration with the [[https://www.npmjs.com][npm]] ecosystem promises to greatly reduce the friction around Closure-unaware JavaScript dependencies. However, this work is very much in progress and in no way precludes improving existing solutions to the problem of "foreign" dependencies.

ClojureScript's =:foreign-libs= option has long provided a way to include JavaScript libraries which cannot be expected to pass through Closure advanced compilation. Through community efforts like [[http://cljsjs.github.io][CLJSJS]], ClojureScript developers can reach functionality not readily provided by ClojureScript or Closure Library with relative ease.

However, the design of =:foreign-libs= has always had a glaring flaw - these libraries are assumed to be globally loaded. Any API exported by the foreign library had to be accessed through the global environment:

#+BEGIN_SRC clojure
    (ns foo
      (:require [cljsjs.react]))

    (def react js/React)
#+END_SRC

Thus foreign libraries supported none of the usual =:require= affordances like =:as=, =:refer=, =:rename=, etc.

While this may seem like a minor point, over the years users have reached further and further into the JavaScript ecosystem for functionality not provided elsewhere. For many projects this meant using tools like [[https://webpack.github.io][Webpack]] to package up all such dependencies into a single foreign library. While expedient, this approach leads to an unidiomatic style, and furthermore creates an obstacle should users try to migrate these dependencies to direct consumption from =node_modules= down the road.

In the next release we are introducing a simple new enhancement to the =:foreign-libs= compiler option - =:global-exports=. A foreign library entry can now declare which namespace maps to which globally exported name:

#+BEGIN_SRC clojure
    :foreign-libs [{:provides ["cljsjs.react"]
                    :global-exports '{cljsjs.react React}}
                   {:provides ["cljsjs.react.dom"]
                    :global-exports '{cljsjs.react.dom ReactDOM}}]
#+END_SRC

With this simple change =cljsjs.react= can now be treated as a regular namespace:

#+BEGIN_SRC clojure
    (ns foo
      (:require [cljsjs.react :as react :refer [createElement]))
#+END_SRC

Note that as =:global-exports= is a map of namespaces to global exports, users leveraging Webpack to make a single foreign library can easily map all the bundled libraries for idiomatic usage.

This also provides a gradual migration path to =node_modules= if so desired. For example, a user could create a =cljsjs.react= artifact with a declared =:npm-deps= on React. Since foreign library usage is now unified with normal namespace usage, you can switch to =node_modules= dependencies with no actual changes in your source code, just changes to your dependencies in your dependency management tool of choice (Maven, Lein, Boot).

We believe this feature addresses a long outstanding pain point and provides a smooth migration path to =node_modules= based dependencies. Please give it a try with ClojureScript 1.9.854 or later.

** [2017-08-16] 1.9.908 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-08-16-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-08-16-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2017-08-16
:CUSTOM_ID: content/news/2017-08-16-release
:END:

This release contains many bug fixes and addresses feedback from the 1.9.854 release candidate.

*** Simpler Module Loading
  :PROPERTIES:
  :CUSTOM_ID: _simpler_module_loading
  :END:

Besides several important fixes, a small bit of automatic configuration from the new module loading feature has been removed. Any module that will be loaded via =cljs.loader= must require it and must invoke =cljs.loader/set-loaded!= manually as the final statement. All existing documentation and examples from previous posts have been updated. This simplification now means downstream libraries can easily build higher level composable facilities upon =cljs.loader=.

*** Node Modules
  :PROPERTIES:
  :CUSTOM_ID: _node_modules
  :END:

We're extremely excited to see users enthusiastically giving =:npm-deps= a try even at this early stage. Several limitations have been discovered and addressed, and we've even contributed patches back to Closure Compiler to push things forward. There's still a significant amount of work to do, so we encourage you to keep trying different libraries and telling us about your experiences.

For a full list of enhancements, fixes, and changes [[https://github.com/clojure/clojurescript/blob/master/changes.md#19908][look here]].

** [2017-08-16] 1.9.908 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-08-16-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-08-16-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2017-08-16
:CUSTOM_ID: content/news/2017-08-16-release
:END:

This release contains many bug fixes and addresses feedback from the 1.9.854 release candidate.

*** Simpler Module Loading
  :PROPERTIES:
  :CUSTOM_ID: _simpler_module_loading
  :END:

Besides several important fixes, a small bit of automatic configuration from the new module loading feature has been removed. Any module that will be loaded via =cljs.loader= must require it and must invoke =cljs.loader/set-loaded!= manually as the final statement. All existing documentation and examples from previous posts have been updated. This simplification now means downstream libraries can easily build higher level composable facilities upon =cljs.loader=.

*** Node Modules
  :PROPERTIES:
  :CUSTOM_ID: _node_modules
  :END:

We're extremely excited to see users enthusiastically giving =:npm-deps= a try even at this early stage. Several limitations have been discovered and addressed, and we've even contributed patches back to Closure Compiler to push things forward. There's still a significant amount of work to do, so we encourage you to keep trying different libraries and telling us about your experiences.

For a full list of enhancements, fixes, and changes [[https://github.com/clojure/clojurescript/blob/master/changes.md#19908][look here]].
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./copy]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/copy
:CLOJURESCRIPT_SITE_AUTHOR:
:CLOJURESCRIPT_SITE_DATE:
:CUSTOM_ID: content/copy
:END:
This release contains many bug fixes and addresses feedback from the 1.9.854 release candidate.

*** Simpler Module Loading
  :PROPERTIES:
  :CUSTOM_ID: _simpler_module_loading
  :END:

Besides several important fixes, a small bit of automatic configuration from the new module loading feature has been removed. Any module that will be loaded via =cljs.loader= must require it and must invoke =cljs.loader/set-loaded!= manually as the final statement. All existing documentation and examples from previous posts have been updated. This simplification now means downstream libraries can easily build higher level composable facilities upon =cljs.loader=.

*** Node Modules
  :PROPERTIES:
  :CUSTOM_ID: _node_modules
  :END:

We're extremely excited to see users enthusiastically giving =:npm-deps= a try even at this early stage. Several limitations have been discovered and addressed, and we've even contributed patches back to Closure Compiler to push things forward. There's still a significant amount of work to do, so we encourage you to keep trying different libraries and telling us about your experiences.

For a full list of enhancements, fixes, and changes [[https://github.com/clojure/clojurescript/blob/master/changes.md#19908][look here]].

** [2017-10-03] 1.9.946 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2017-10-03-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2017-10-03-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2017-10-03
:CUSTOM_ID: content/news/2017-10-03-release
:END:

This release contains many bug fixes and addresses feedback from the 1.9.908 release. Important changes include parity with Clojure 1.9.0-beta1 and an updated Google Closure Compiler dependency. The later one in particular now means that ClojureScript has a dependency on JDK 8.

For a full list of enhancements, fixes, and changes [[https://github.com/clojure/clojurescript/blob/master/changes.md#19946][look here]].

** [2018-03-26] ClojureScript Command Line
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2018-03-26-clojurescript-command-line.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2018-03-26-clojurescript-command-line
:CLOJURESCRIPT_SITE_AUTHOR: Mike Fikes
:CLOJURESCRIPT_SITE_DATE: 2018-03-26
:CUSTOM_ID: content/news/2018-03-26-clojurescript-command-line
:END:

ClojureScript now has an exciting new command line capability called =cljs.main= which dramatically simplifies using ClojureScript for many common use cases. In this post, we'll take you through a quick tour of the capabilities being introduced.

*** Set up ClojureScript
  :PROPERTIES:
  :CUSTOM_ID: clojurescript-compiler
  :END:

In order to run these examples, you need to set up ClojureScript. You can do that either via the =clj= command line tool or by downloading the standalone JAR.

**** macOS or Linux: =clj=
   :PROPERTIES:
   :CUSTOM_ID: _macos_or_linux_clj
   :END:

1. [[https://clojure.org/guides/getting_started][Install the =clj=]] command line tool.

2. In your working directory, create a [[https://clojure.org/guides/deps_and_cli][=deps.edn=]] file with the following contents:

#+BEGIN_SRC clojure
    {:deps {org.clojure/clojurescript {:mvn/version "1.10.238"}}}
#+END_SRC

**** Windows
   :PROPERTIES:
   :CUSTOM_ID: _windows
   :END:

1. Download the ClojureScript JAR [[https://github.com/clojure/clojurescript/releases/download/r1.10.238/cljs.jar][=cljs.jar=]].

2. Place it in your working directory.

*** Starting a Browser REPL
  :PROPERTIES:
  :CUSTOM_ID: starting-a-browser-repl
  :END:

Let's jump right in! You can start up a browser REPL by running the following command

#+BEGIN_SRC sh
    clj -M -m cljs.main
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp cljs.jar cljs.main
#+END_SRC

When you do this, the REPL will start and will automatically launch a browser to connect back to it.

[[/images/content/news/2018-03-26-clojurescript-command-line/browser.png]]

You will see the following in the REPL terminal:

#+BEGIN_EXAMPLE
    ClojureScript 1.10.238
    cljs.user=>
#+END_EXAMPLE

We are now in an interactive environment, with the ability to control the page. Try the following in the REPL to cause an alert to pop up in your browser:

#+BEGIN_SRC clojure
    (js/alert "Hello CLJS!")
#+END_SRC

*** Creating a Browser App
  :PROPERTIES:
  :CUSTOM_ID: creating-a-browser-app
  :END:

Now, let's cobble together a simple browser-based ClojureScript app and explore the ability of =cljs.main= to compile your app's source.

Note that in the previous section, =cljs.main= synthetically-generated an =index.html= for us. We'll want to create a custom =index.html= for our app in the current directory:

#+BEGIN_EXAMPLE
    <html>
      <body>
        <canvas id="canvas" width="400" height="300"></canvas>
        <script src="out/main.js"></script>
      </body>
    </html>
#+END_EXAMPLE

Add the following source in =src/my_app/core.cljs= (or =src\my_app\core.cljs= if on Windows).

#+BEGIN_SRC clojure
    (ns my-app.core)

    (def ctx (-> js/document
                 (.getElementById "canvas")
                 (.getContext "2d")))

    (defn draw-shape [x y radius color]
      (set! (.-fillStyle ctx) color)
      (.beginPath ctx)
      (.arc ctx x y radius 0 (* 2 Math/PI))
      (.fill ctx))

    (draw-shape 150 150 100 "blue")
#+END_SRC

Now, let's use =cljs.main= to first compile this source (using =-c=), and, when done, start up a browser REPL (using =-r=), and additionally watch for changes in our source (using =-w=):

#+BEGIN_SRC sh
    clj -M -m cljs.main -w src -c my-app.core -r
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main -w src -c my-app.core -r
#+END_SRC

Note that we are also adding our =src= directory to the classpath.

When this launches, you should see a blue circle in your browser.

[[/images/content/news/2018-03-26-clojurescript-command-line/blue-circle.png]]

Try interacting with the app by drawing other circles. For example, try this in the REPL:

#+BEGIN_SRC clojure
    (my-app.core/draw-shape 350 200 50 "red")
#+END_SRC

[[/images/content/news/2018-03-26-clojurescript-command-line/blue-red-circle.png]]

What if you change your source? Change the =2= to a =1= in the =draw-shape= implementation, and refresh your browser. Now instead of circles, the app will draw semi-circles.

*** Creating a Node App
  :PROPERTIES:
  :CUSTOM_ID: creating-a-node-app
  :END:

In the previous sections, we were relying on =cljs.main= to establish a browser REPL environment. But, =cljs.main= has a command line flag (=-re=) that allows you to specify an alternate REPL environment.

For example, if have Node installed, you can use =cljs.main= to launch a Node-based REPL by supplying =-re node=:

#+BEGIN_SRC sh
    clj -M -m cljs.main -re node
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp cljs.jar cljs.main -re node
#+END_SRC

If you do this, you will be dropped directly into a Node-based REPL:

#+BEGIN_EXAMPLE
    ClojureScript 1.10.238
    cljs.user=> (+ 2 3)
    5
    cljs.user=> (exists? js/require)
    true
#+END_EXAMPLE

Let's make a small Node-based app. Replace the contents of our =my-app.core= namespace with

#+BEGIN_SRC clojure
    (ns my-app.core)

    (defn square [x]
      (* x x))

    (defn -main [& args]
      (-> args first js/parseInt square prn))
#+END_SRC

With this in place, let's run this app using =cljs.main= to run =-main= in a specified namespace (using =-m=):

#+BEGIN_SRC sh
    clj -M -m cljs.main -re node -m my-app.core 5
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main -re node -m my-app.core 5
#+END_SRC

Running this will automatically compile our namespace, launch Node, and execute our =-main=, passing our command line argument =5=, thus causing it to print =25=.

What if we'd like to produce a standalone JavaScript file that we can use with Node to do the same?

First, add one helper to the end of =my-app.core=:

#+BEGIN_SRC clojure
    (set! *main-cli-fn* -main)
#+END_SRC

Now we are going to compile a =simple= (using =-O=) build, targeting Node (using =-t=), specifying where we'd like our final output file (using =-o=):

#+BEGIN_SRC sh
    clj -M -m cljs.main -t node -O simple -o main.js -c my-app.core
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main -t node -O simple -o main.js -c my-app.core
#+END_SRC

With this, you can copy =main.js= to wherever you'd like and run

#+BEGIN_SRC sh
    node main.js 5
#+END_SRC

and it will print =25=.

*** Running Tests in Nashorn
  :PROPERTIES:
  :CUSTOM_ID: running-tests-in-nashorn
  :END:

The built-in Nashorn environment is accessible using =cljs.main=, and with it there is no need for any external JavaScript environment. Let's use this to run some tests.

First, add a new file for a =my-app.core-test= namespace

#+BEGIN_SRC clojure
    (ns my-app.core-test
      (:require
       [my-app.core]
       [clojure.test :refer [deftest is]]))

    (deftest square-test
      (is (== 25 (my-app.core/square 5))))
#+END_SRC

Let's run these tests under Nashorn (by specifying =-re nashorn=). To do things a little differently, let's use =-i= to load a resource, and =-e= to evaluate a form that will kick off our tests:

#+BEGIN_SRC sh
    clj -M -m cljs.main -re nashorn -i src/my_app/core_test.cljs -e "(cljs.test/run-tests 'my-app.core-test)"
#+END_SRC

On Windows

#+BEGIN_SRC sh
    java -cp "cljs.jar;src" cljs.main -re nashorn -i src\my_app\core_test.cljs -e "(cljs.test/run-tests 'my-app.core-test)"
#+END_SRC

With this, you will see

#+BEGIN_EXAMPLE
    Testing my-app.core-test

    Ran 1 tests containing 1 assertions.
    0 failures, 0 errors.
#+END_EXAMPLE

*** Other Affordances
  :PROPERTIES:
  :CUSTOM_ID: other-affordances
  :END:

The above took you through a quick tour covering most of the options available in =cljs.main=. There are other options available, and you can get help on them by running

#+BEGIN_SRC sh
    clj -M -m cljs.main -h
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp cljs.jar cljs.main -h
#+END_SRC

A couple of interesting options that might be useful are =-co= and =-ro=. They provide the ability to configure any compiler [[https://clojurescript.org/reference/compiler-options][compiler option]] or [[https://clojurescript.org/reference/repl-options][REPL option]], (which go under =-co=) and REPL-environment-specific options (which go under =-ro=). These can act as an "escape hatch" if you need to specify something for which =cljs.main= doesn't provide a command-line flag.

For example, the following will apply the =:repl-verbose= option (thus showing the JavaScript being emitted while using the REPL):

#+BEGIN_SRC sh
    clj -M -m cljs.main -co "{:repl-verbose true}" -re node -r
#+END_SRC

On Windows:

#+BEGIN_SRC sh
    java -cp cljs.jar cljs.main -co "{:repl-verbose true}" -re node -r
#+END_SRC

You can specify EDN directly on the command line, as shown above, or you can supply the names of files containing EDN. With this capability, you can pretty much use =cljs.main= to do anything you'd like with the ClojureScript compiler.

We hope you find the new =cljs.main= feature useful and that it simplifies many of the common tasks you need to accomplish with the ClojureScript compiler!

** [2018-03-26] 1.10.238 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2018-03-26-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2018-03-26-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2018-03-26
:CUSTOM_ID: content/news/2018-03-26-release
:END:

ClojureScript 1.10 is finally out!

Many enhancements have been made, including support for Java 9 and Java 10. Below, we'll take you through a quick tour of some of the major new features.

*** cljs.main
  :PROPERTIES:
  :CUSTOM_ID: _cljs_main
  :END:

ClojureScript now includes =cljs.main=, which brings many of the capabilities of =clojure.main= (and popularized via the [[https://clojure.org/guides/deps_and_cli][new Clojure CLI tools]]) to ClojureScript, along with special support for the additional considerations and capabilities of the ClojureScript environment, allowing you to compile or run ClojureScript code directly from the command line.

The =cljs.main= capability has allowed us to drastically simplify the experience for new users. Much of the complexity and ceremony in the previous version of the [[https://clojurescript.org/guides/quick-start][Quick Start]] guide has simply evaporated.

And for experienced ClojureScript users, =cljs.main= makes what should be easy operations, well... easy. Many things can now be done with just a command line flag or two, without any need for complicated setup.

You can read more about =cljs.main= at [[https://clojurescript.org/news/2018-03-26-clojurescript-command-line][ClojureScript Command Line]].

*** Shared AOT Cache
  :PROPERTIES:
  :CUSTOM_ID: _shared_aot_cache
  :END:

The shared AOT cache feature saves artifacts compiled from JARs so that they can be reused across your projects, or reused in the event that you do a clean build in a project. This can save time by avoiding recompiling code that does not change.

You can read more about this feature at [[https://clojurescript.org/news/2018-03-28-shared-aot-cache][Shared AOT Cache]].

*** Module Processing Improvements and Closure Update
  :PROPERTIES:
  :CUSTOM_ID: _module_processing_improvements_and_closure_update
  :END:

ClojureScript now uses the latest Closure Compiler release (v20180204), which includes many improvements for consuming Node modules. In addition to the Closure Compiler update, several changes were implemented on the ClojureScript side. Some of the improvements include:

-  CommonJS and ES6 modules can now require each other

-  Closure now detects and is able to remove more UMD wrappers

-  Node module support can be disabled by setting the =:npm-deps= option to =false= for cases where the =node_modules= directory exists but should not be used

*** Stable Names
  :PROPERTIES:
  :CUSTOM_ID: _stable_names
  :END:

A new compiler option, [[https://clojurescript.org/reference/compiler-options#stable-names][=:stable-names=]] has been introcuced. This reduces name churn between advanced builds and facilitates proper vendorization if you're using [[https://clojurescript.org/reference/compiler-options#modules][=:modules=]].

*** Enhanced Socket REPL and alpha pREPL
  :PROPERTIES:
  :CUSTOM_ID: _enhanced_socket_repl_and_alpha_prepl
  :END:

This release adds several =cljs.server.*= namespaces for integration with =-Dclojure.server.repl=, allowing for much richer ClojureScript Socket REPL capabilities.

In addition, support for pREPL has been added. This is similar to Socket REPL, but is instead EDN-based so that tooling can programatically consume REPL output.

The new Socket REPL and pREPL features require Clojure =1.10.0-alpha4= to be on the classpath.

*** core.specs.alpha
  :PROPERTIES:
  :CUSTOM_ID: _core_specs_alpha
  :END:

The [[https://github.com/clojure/core.specs.alpha][core.specs.alpha]] library has been ported to ClojureScript, and is available in this release as an opt-in feature. This library contains specs that describe core macros and functions. Support for the =ns= special form is additionally included.

To use this library, simply require the new =cljs.core.specs.alpha= namespace. By doing this, specs for =defn=, =let=, and other macros will be registered, and subsequent compilation of these macros will be subject to spec validation.

The following illustrates its use at the REPL. Let's say you accidentally attempt to refer /all/ symbols of a library, using a Clojure-specific feature that does not exist in ClojureScript:

#+BEGIN_EXAMPLE
     cljs.user=> (require '[clojure.set :refer :all])
     clojure.lang.ExceptionInfo: Don't know how to create ISeq from: clojure.lang.Keyword at line 1 ...
#+END_EXAMPLE

This error is a bit cryptic. Now, let's try again, but using =core.specs.alpha=:

#+BEGIN_EXAMPLE
    cljs.user=> (require 'cljs.core.specs.alpha)
    nil
    cljs.user=> (require '[clojure.set :refer :all])
    clojure.lang.ExceptionInfo: Call to cljs.core/require did not conform to spec:
    In: [0 1 :refer] val: :all fails spec: :cljs.core.specs.alpha/refer at:
    [:args :spec :libspec :lib+opts :options :refer] predicate: coll?
    ...
#+END_EXAMPLE

The resulting error is essentially indicating that =:all= is the problem and that =:refer= takes a collection as its argument.

This feature is still alpha, but we encourage you to give it a try and report any defects you might find!

*** Reducible Sequence Generators
  :PROPERTIES:
  :CUSTOM_ID: _reducible_sequence_generators
  :END:

With this ClojureScript release, the results of =iterate=, =repeat= and =cycle= are now directly reducible. This brings some great work that Alex Miller did for Clojure a [[http://insideclojure.org/2015/01/18/reducible-generators/][few years ago]] to ClojureScript. This means that you will get much better performance when reducing over the output of these functions.

Take, for example, a benchmark involving running =(transduce (take 64) + (iterate inc 0))= a total of 10,000 times when compiled with =:advanced= optimizations. You can try this benchmark on your machine, but we are seeing this run 4.5 times faster under V8 and SpiderMonkey, and 3.3 times faster on JavaScriptCore.

In addition, this provides a way to process large output without involving intermediate sequence generation, thus bypassing the lack of locals-clearing and inevitable head-holding that occurs in ClojureScript. This means you can now run programs like

#+BEGIN_EXAMPLE
    (transduce (comp (map inc) (filter odd?) (take 1e8)) + (iterate inc 0))
#+END_EXAMPLE

and they will consume very little memory. This example completes in around 10 seconds in the Node REPL, using just a few megabytes of RAM, whereas previously it would essentially never terminate, consuming gigabytes of RAM.

*** Map Entries
  :PROPERTIES:
  :CUSTOM_ID: _map_entries
  :END:

As an expediency, ClojureScript has been returning 2-element vectors for non-sorted persistent map entries. For many use cases, this is OK because map entries can be used as vectors. But, the opposite is not the case, and to pull this off, ClojureScript needed to add artificial support to persistent vectors for the =key= and =val= map entry functions.

In order to align with Clojure, ClojureScript now returns a dedicated map entry type for this case and eliminates the artifical vector support. One example illustrating higher fidelity with Clojure is that this allows ClojureScript to properly return =nil= when =empty= is applied to a map entry. (Since map entries have exactly two elements, it is impossible to have an empty map entry.)

While this certainly cleans things up, be on the lookout for code that incorrectly treats vectors as map entries. For example, while =(key (first {:a 1}))= and =(val (first {:a 1}))= are perfectly valid, =(key [:a 1])= and =(val [:a 1])= are incorrect and will result in a runtime exception.

Finally, using a dedicated map entry type can lead to performance improvements in some code that works with map entries. For example, in =:advanced= mode, this code

#+BEGIN_EXAMPLE
    (simple-benchmark [m (zipmap (range 100) (range))]
      (reduce (fn [a [k v]] (if (even? v) (+ a k) a)) 0 m) 100000)
#+END_EXAMPLE

runs 11% faster in JavaScriptCore, 18% faster in V8, and a whopping 105% faster in SpiderMonkey. And if you use the dedicated =key= and =val= functions instead of destructuring, the V8 performance goes to 44% faster and SpiderMonkey 112%.

For a complete list of updates in ClojureScript 1.10.238 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#110238][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.238:

-  Andrea Richiardi

-  Bruce Hauman

-  Dieter Komendera

-  Enzzo Cavallo

-  Erik Assum

-  Hendrik Poernama

-  Jannis Pohlmann

-  Jinseop Kim

-  John Newman

-  Juho Teperi

-  Levi Tan Ong

-  Mark Hepburn

-  Martin Klepsch

-  Mike Fikes

-  Oliver George

-  Paulus Esterhazy

-  Roman Scherer

-  Thomas Heller

-  Tim Pote

-  Tom Mulvaney

** [2018-03-28] Shared AOT Cache
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2018-03-28-shared-aot-cache.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2018-03-28-shared-aot-cache
:CLOJURESCRIPT_SITE_AUTHOR: Mike Fikes
:CLOJURESCRIPT_SITE_DATE: 2018-03-28
:CUSTOM_ID: content/news/2018-03-28-shared-aot-cache
:END:

When you compile ClojureScript code, several artifacts are produced, including JavaScript, analysis metadata, and source maps. These are cached locally, in an output subdirectory (typically “out” or “target”).

Since these artifacts are expensive to produce, it is tempting to include them in shipping library JARs. But, the artifacts vary, depending on the compiler version used as well as the build-affecting compiler options in effect (such as =:target=, =:elide-asserts=, or =:static-fns=), so this approach is infeasible.

A new feature in ClojureScript can effectively solve this problem: When enabled, compilation artifacts produced from JARs are placed in a shared cache. This means that you can compile, say, =core.async= 0.4.474 /once/.

The shared cache can be reused across the different ClojureScript projects you might have on your computer. It can also be used as a source to populate your output directory if you perform a “clean” in a project and build it from scratch. This can drastically reduce the build time, as you are only compiling the source in your project proper.

Since ClojureScript itself is typically a JAR dependency, the shared AOT cache mechanism is---in typical Lisp meta-circular fashion---applicable to ClojureScript /itself/, caching artifacts produced for =cljs.core= and other namespaces that ship with ClojureScript.

This enables a new feature of =cljs.main=: For certain use cases, like simply using it to run a script, evaluate a form with =-e=, or just fire up a REPL, =cljs.main= will use a /temporary/ output directory instead of dirtying the filesystem by creating an “out” directory where you ran =cljs.main=. The ability to use an AOT =cljs.core= makes this use case nice and zippy.

The AOT cache logic is smart enough to deal with different compiler versions, build-affecting options, and JAR names, and uses that information to store artifact variants separately in the cache. And, while the AOT cache feature is motiviated by the notion that code in shipping JARs is immutable, it recognizes that this does not hold in the case of snapshot JARs or locally deployed JAR revisions. In those cases, the change in a JAR's timestamp will invalidate the cache.

#+BEGIN_QUOTE
  *Note*

  The AOT cache logic cannot handle the case where shipping JARs employ macros that consult the ambient environment in order to affect the code generated for the source shipped in those JARs.

  An example might be the use of macros to cause the compiled code to reflect configuration, as is the case if you use =:external-config= with Figwheel or Dirac.

  In those situations, it is recommended that libraries and tooling employ =goog.define= instead, perhaps with the help of [[https://clojurescript.org/reference/compiler-options#closure-defines][=:closure-defines=]], as this makes JARs cache-friendly.
#+END_QUOTE

By default, this feature is disabled unless ClojureScript is being used via =cljs.main=. You can override the default by explicitly using the new [[https://clojurescript.org/reference/compiler-options#aot-cache][=:aot-cache=]] compiler option.

Since this strategy doesn't depend on AOT artifacts being included in shipping JARS, it should be amenable to [[https://clojure.org/news/2018/01/05/git-deps][Git Deps]]. Perhaps that will come in a future release of ClojureScript.

We encourage you to give this feature a try. Our hope is that this feature is one that you don't end up even thinking about, and that it just further helps get you to your day-to-day development!

** [2018-06-15] 1.10.312 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2018-06-15-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2018-06-15-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2018-06-15
:CUSTOM_ID: content/news/2018-06-15-release
:END:
*** Improved Externs Inference
  :PROPERTIES:
  :CUSTOM_ID: _improved_externs_inference
  :END:

Externs inference has been significantly improved in this release. See [[https://clojurescript.org/guides/webpack][ClojureScript with Webpack]] for details on what this improved support enables.

*** Closure Upgrades
  :PROPERTIES:
  :CUSTOM_ID: _closure_upgrades
  :END:

Closure Compiler has been upgraded to v20180610.

Additionally, changes have been made so that it is possible to upgrade to the latest Google Closure Library. (The revised code is simultaneously compatible with the latest Closure Library and the version that ClojureScript 1.10.238 depends on.)

*** Optimized =node_modules= Indexing
  :PROPERTIES:
  :CUSTOM_ID: _optimized_node_modules_indexing
  :END:

If you use =:npm-deps=, the indexing of =node_modules= should be much faster. (One test showed a 6-fold improvement in indexing speed.)

*** Improvements in Testing
  :PROPERTIES:
  :CUSTOM_ID: _improvements_in_testing
  :END:

Several improvements have been made to ensure that the compiler test suite passes on Windows. Additionally, Graal.js, the new JavaScript engine that ships with GraalVM is included in the test suite.

For a complete list of updates in ClojureScript 1.10.312 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#110312][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.312:

-  Andre Rauh

-  Dieter Komendera

-  Erik Assum

-  Jannis Pohlmann

-  Juho Teperi

-  Mike Fikes

-  Petter Eriksson

-  Pieter du Toit

-  Roman Scherer

** [2018-11-02] 1.10.439 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2018-11-02-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2018-11-02-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2018-11-02
:CUSTOM_ID: content/news/2018-11-02-release
:END:
*** Noteworthy Changes
  :PROPERTIES:
  :CUSTOM_ID: _noteworthy_changes
  :END:

Closure Compiler has been upgraded to v20180805.

The [[https://clojurescript.org/reference/compiler-options#npm-deps][=:npm-deps=]] compiler option now defaults to =false=. Previously, =:npm-deps= defaulted to =true=.

*** Improved Compiler Performance
  :PROPERTIES:
  :CUSTOM_ID: _improved_compiler_performance
  :END:

The compiler is now much faster when compared with the 1.10.339 release for both regular builds and when =:parallel-build= is set to =true=.

*** Warnings on Private Var Use
  :PROPERTIES:
  :CUSTOM_ID: _warnings_on_private_var_use
  :END:

ClojureScript will now warn on private var use.

Let's say you have a function intended for private use in a namespace:

#+BEGIN_SRC clojure
    (ns foo.core)

    (defn- some-impl [x]
      (inc x))
#+END_SRC

and you inadvertently use it from some other namespace, as in

#+BEGIN_SRC clojure
    (ns bar.core
     (:require [foo.core]))

    (foo.core/some-impl 3)
#+END_SRC

The compiler will now emit a helpful diagnostic:

#+BEGIN_EXAMPLE
    WARNING: var: foo.core/some-impl is not public
#+END_EXAMPLE

This is only a warning; the ClojureScript compiler continues to allow private var use, but now emits a new analysis warning, controllable via =:private-var-access=.

If var indirection is used instead, no warning will be emitted:

#+BEGIN_SRC clojure
    (#'foo.core/some-impl 3)
#+END_SRC

*** Function Return Type Inference
  :PROPERTIES:
  :CUSTOM_ID: _function_return_type_inference
  :END:

ClojureScript now infers function return types, propagating this information to call sites.

Consider these predicates:

#+BEGIN_SRC clojure
    (defn finite? [x]
      (not (infinite? x)))

    (defn big? [x]
      (and (pos? x)
           (finite? x)))
#+END_SRC

Previously, code like the following

#+BEGIN_SRC clojure
    (if (big? 11)
      "hi"
      "bye")
#+END_SRC

would emit defensive JavaScript that coerces the return value of =big?= to a Boolean by using =cljs.core.truth_=:

#+BEGIN_EXAMPLE
    (cljs.core.truth_(cljs.user.big_QMARK_.call(null,(11)))?"hi":"bye")
#+END_EXAMPLE

Now, the compiler instead infers that =finite?= always returns a Boolean value, and therefore so does =big?=, and emits more efficient code:

#+BEGIN_EXAMPLE
    ((cljs.user.big_QMARK_.call(null,(11)))?"hi":"bye")
#+END_EXAMPLE

With inference like this, it is no longer necessary to manually add a =^boolean= type hint to a predicate used in performance-critical code, so long as the return value can be infered from the predicate function body.

In general, any inferred types will automatically flow from function bodies outward, such as an inferred numeric type in the following example:

#+BEGIN_SRC clojure
    (defn foo [x]
      (+ x 3))
#+END_SRC

If =foo= is used in a context where types are checked, as in

#+BEGIN_SRC clojure
    (+ (foo 1) "a")
#+END_SRC

you will now see a warning that properly reflects the type:

#+BEGIN_EXAMPLE
    WARNING: cljs.core/+, all arguments must be numbers, got [number string] instead
#+END_EXAMPLE

Previously, without a type hint on =foo=, the compiler would produce a warning that indicates a type of =any= instead of =number=.

*** Graal.JS REPL Environment
  :PROPERTIES:
  :CUSTOM_ID: _graal_js_repl_environment
  :END:

ClojureScript now ships with a Graal.JS REPL environment. This is a new Java-based REPL environment which is similar to the existing Nashorn REPL environment, but instead uses the new [[https://github.com/graalvm/graaljs][Graal.JS]] JavaScript engine that ships as part of GraalVM.

The Graal.JS REPL environment automatically configures the Graal.JS engine to allow Polyglot calls to other languages that may be installed.

If you have the GraalVM version of Java on your path, to use this new REPL environment with =cljs.main=, simply specify =--repl-env graaljs=:

#+BEGIN_EXAMPLE
    $ clj -M --main cljs.main --repl-env graaljs --repl
    ClojureScript 1.10.439
    cljs.user=> (.eval js/Polyglot "R" "sum(1:100)")
    5050
    cljs.user=> (.eval js/Polyglot "ruby" "(1..100).reduce(:+)")
    5050
#+END_EXAMPLE

In addition to Polyglot support, the Graal.JS engine is much faster than Nashorn, approaching the performance of the other leading JavaScript engines, especially when warmed up and the JVM has had an opportunity to optimize hotspots.

Since GraalVM hasn't yet been released and things could still change, this new REPL environment should be considered beta. We encourage you to give it a try!

*** Updates to Spec
  :PROPERTIES:
  :CUSTOM_ID: _updates_to_spec
  :END:

This release includes many updates to Spec, bringing changes and fixes that have been made to the Clojure implementation of Spec to ClojureScript.

*** Updates to AST Representation
  :PROPERTIES:
  :CUSTOM_ID: _updates_to_ast_representation
  :END:

The internal AST representation has been updated to match =tools.analyzer=. This will simplify things for tooling that works with the AST generated by ClojureScript.

*** Change List
  :PROPERTIES:
  :CUSTOM_ID: _change_list
  :END:

For a complete list of updates in ClojureScript 1.10.439 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.439][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.439:

-  Ambrose Bonnaire-Sergeant

-  Erik Assum

-  Eugene Kostenko

-  Henry Widd

-  Jordan Biserkov

-  Juho Teperi

-  Mike Fikes

-  Oliver Eidel

-  Ray McDermott

-  Thomas Spellman

*** Grant Support
  :PROPERTIES:
  :CUSTOM_ID: _grant_support
  :END:

Thanks to [[https://www.clojuriststogether.org][Clojurists Together]] and its supporting members for funding a significant amount of work that went into this release!

For details see

-  [[https://www.clojuriststogether.org/news/july-2018-monthly-update/][July 2018 Monthly Update]]

-  [[https://www.clojuriststogether.org/news/june-2018-monthly-update/][June 2018 Monthly Update]]

-  [[https://www.clojuriststogether.org/news/may-2018-monthly-update/][May 2018 Monthly Update]]

** [2019-01-31] 1.10.516 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2019-01-31-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2019-01-31-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2019-01-31
:CUSTOM_ID: content/news/2019-01-31-release
:END:
*** Noteworthy Changes
  :PROPERTIES:
  :CUSTOM_ID: _noteworthy_changes
  :END:

Spec instrumentation (=cljs.spec.test.alpha/instrument= and related functionality) no longer requires =test.check=. If you use =cljs.spec.test.alpha/check=, the data generation functionality of =test.check= is needed; in that case you need to require the =clojure.test.check= and =clojure.test.check.properties= namespaces.

Keywords used in the =cljs.spec.test.alpha/check= API pertaining to Spec's use of =test.check= are now qualified with =clojure.spec.test.check=, thus aligning with Clojure. The previous way of qualifying with =clojure.test.check= is still supported.

*** Clojure 1.10 Features
  :PROPERTIES:
  :CUSTOM_ID: _clojure_1_10_features
  :END:

**** Improved Exception Messages and Printing
   :PROPERTIES:
   :CUSTOM_ID: _improved_exception_messages_and_printing
   :END:

The [[https://www.clojure.org/reference/repl_and_main#_error_printing][improved exception infrastructure]] added in Clojure 1.10 has been ported to ClojureScript with this release.

**** Protocols via Metadata
   :PROPERTIES:
   :CUSTOM_ID: _protocols_via_metadata
   :END:

The ability to add protocols via metadata (for protocols defined with the =:extend-via-metadata true= directive) has been ported to ClojureScript with this release.

**** Datafy and Nav
   :PROPERTIES:
   :CUSTOM_ID: _datafy_and_nav
   :END:

The =clojure.datafy= namespace has been ported to ClojureScript, along with associated protocols in the =clojure.core.protocols= namespace.

*** clojure.edn Namespace
  :PROPERTIES:
  :CUSTOM_ID: _clojure_edn_namespace
  :END:

A new =clojure.edn= namespace is added with this release which delegates to =cljs.reader= for functionality. This facilitates writing portable Clojure / ClojureScript source making use of =clojure.edn/read= and =clojure.edn/read-string=.

*** Type Inference Improvements
  :PROPERTIES:
  :CUSTOM_ID: _type_inference_improvements
  :END:

**** Predicate-Induced Type Inference
   :PROPERTIES:
   :CUSTOM_ID: _predicate_induced_type_inference
   :END:

The type inference algorithm will now consider core predicates when inferring the types of locals used in conditional expressions.

For example, in

#+BEGIN_SRC clojure
    (if (string? x)
      (inc x)
      10)
#+END_SRC

because =x= satisfies =string?=, it will be inferred to be of string type in the then branch (and thus cause a warning to be emitted because =inc= is being applied to it).

Because =cond= and =when= are macros built on top of =if=, predicate-induced inference also works as expected for expressions involving =cond= and =when=.

In addition to core predicates, predicate-induced type inference also works for =instance?= checks. So, for example testing =(instance? Atom x)= will result in =x= being inferred of type =cljs.core/Atom=.

**** Truthy-Induced Inference
   :PROPERTIES:
   :CUSTOM_ID: _truthy_induced_inference
   :END:

In situations where a value could potentially be =nil= (represented by the symbol =clj-nil= in type tags), if a simple symbol referring to such a value is used as the test in a conditional, the type inference algorithm will infer that the value cannot be =nil= in the then branch.

This is perhaps best illustrated by way of example. Let's say you have the following function:

#+BEGIN_SRC clojure
    (defn f [x]
      (when (even? x)
        (inc x)))
#+END_SRC

This function's return type is =#{number clj-nil}=, meaning that either a number or =nil= can be returned.

The following function, which uses =f= and would previously be inferred as returning =#{number clj-nil}=, is now inferred as returning =number=:

#+BEGIN_SRC clojure
    (defn g [y]
      (let [z (f y)]
        (if z
          z
          17)))
#+END_SRC

In fact, owing to the way the =or= macro expands, the expression =(or (f 1) 17)= is now inferred as being simply =number=.

**** Improved =loop= / =recur= Inference
   :PROPERTIES:
   :CUSTOM_ID: _improved_loop_recur_inference
   :END:

The type-inferrence algorithm will now consider =recur= parameter types when inferring =loop= local types.

For example, in

#+BEGIN_SRC clojure
    (loop [x "a"]
      (if (= "a" x)
       (recur 1)
       (+ 3 x)))
#+END_SRC

the local =x= would previously be inferred to be of string type (and this would cause a warning to be emitted for the expression adding it to =3=). Now, the compiler will infer =x= to be either string or numeric (and thus the warning will no longer appear).

**** Multi-Arity and Variadic Function Return Type Inference
   :PROPERTIES:
   :CUSTOM_ID: _multi_arity_and_variadic_function_return_type_inference
   :END:

ClojureScript 1.10.439 added [[https://clojurescript.org/news/news#_function_return_type_inference][function return type inference]], but this capability only worked for single-arity functions. This release extends this capability to multi-arity and variadic functions.

Furthermore, the inferred return type will properly vary if different arities return different types. For example,

#+BEGIN_SRC clojure
    (defn foo
      ([x] 1)
      ([x y] "a"))
#+END_SRC

then the expression =(foo true)= will be inferred to be of numeric type while =(foo :a :b)= will be inferred to be of string type.

*** Spec Improvements
  :PROPERTIES:
  :CUSTOM_ID: _spec_improvements
  :END:

Several improvements in the Spec implementation are in this release, making it easier to spec functions in the standard core library, as well as improving instrumentation performance when a large number of functions in a codebase have specs.

*** Improved Performance
  :PROPERTIES:
  :CUSTOM_ID: _improved_performance
  :END:

**** Chunked-Seq support for Ranges
   :PROPERTIES:
   :CUSTOM_ID: _chunked_seq_support_for_ranges
   :END:

ClojureScript now supports chunked-seqs for ranges. An example where this capability improves performance is

#+BEGIN_SRC clojure
    (reduce + (map inc (map inc (range (* 1024 1024)))))
#+END_SRC

which is evaluated 5 times faster in V8, 7 times in SpiderMonkey, and 2 times in JavaScriptCore.

**** Improved =re-seq= Performance
   :PROPERTIES:
   :CUSTOM_ID: _improved_re_seq_performance
   :END:

=re-seq= performance has been improved, with a speedup of 1.5 or more under major JavaScript engines.

**** Optimized String Expression Concatenation
   :PROPERTIES:
   :CUSTOM_ID: _optimized_string_expression_concatenation
   :END:

Generally, arguments supplied to the =str= function are first coerced to strings before being concatenated. With this release, unnecessary coercion is eliminated for arguments that are inferred to be of string type, leading to more compact codegen as well as a speed boost.

For example, in

#+BEGIN_SRC clojure
    (defn foo [x y]
      (str (+ x y)))

    (str (name :foo/bar) "-" (foo 3 2))
#+END_SRC

the last =str= expression is evaluated 3 times faster in V8 and 4 times faster in JavaSriptCore as a result of the improved codgen.

*** Change List
  :PROPERTIES:
  :CUSTOM_ID: _change_list
  :END:

For a complete list of updates in ClojureScript 1.10.516 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.516][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.516:

-  Anton Fonarev

-  Enzzo Cavallo

-  Erik Assum

-  Eugene Kostenko

-  Martin Kučera

-  Michiel Borkent

-  Oliver Caldwell

-  Sahil Kang

-  Thomas Heller

-  Thomas Mulvaney

-  Timothy Pratley

-  Will Acton

** [2019-11-18] 1.10.597 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2019-11-18-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2019-11-18-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2019-11-18
:CUSTOM_ID: content/news/2019-11-18-release
:END:
*** Noteworthy Changes
  :PROPERTIES:
  :CUSTOM_ID: _noteworthy_changes
  :END:

-  The behavior of =set/union= and =into= is now aligned with Clojure.

-  =subvec= argument checking is now aligned with Clojure.

-  =apply= =vector= on an array now properly clones the array.

*** Google Closure Namespace Analysis
  :PROPERTIES:
  :CUSTOM_ID: _google_closure_namespace_analysis
  :END:

The compiler now produces analysis metadata for Google Closure namespaces. This means that for these namespaces:

-  REPL facilities like =doc=, =dir=, =apropos=, /etc./, will now work.

-  Argument lists are available, thus enabling arity checking.

-  Return types are available, enhancing type inference.

-  Warnings on private var usage will be generated.

To illustrate, let's =(require '[goog.crypt :as crypt])= and explore it at the REPL:

Now, =(dir crypt)= will list the functions in that namespace:

#+BEGIN_EXAMPLE
    byteArrayToHex
    byteArrayToString
    hexToByteArray
    ...
#+END_EXAMPLE

Docstrings are available; =(doc crypt/hexToByteArray)= produces:

#+BEGIN_EXAMPLE
    -------------------------
    goog.crypt/hexToByteArray
    ([hexString])
      /**
     * Converts a hex string into an integer array.
    ...
#+END_EXAMPLE

Arity information is available. Passing an incorrect argument count to one of the functions, produces an arity warning. For example, =(crypt/hexToByteArray "abc" 123)= generates:

#+BEGIN_EXAMPLE
    WARNING: Wrong number of args (2) passed to goog.crypt/hexToByteArray at line 1 <cljs repl>
#+END_EXAMPLE

*** Type Inference Improvements
  :PROPERTIES:
  :CUSTOM_ID: _type_inference_improvements
  :END:

Several improvements to ClojureScript's type inference are in this release.

**** Direct field access for keyword lookup on records
   :PROPERTIES:
   :CUSTOM_ID: _direct_field_access_for_keyword_lookup_on_records
   :END:

This is easily explained by way of example:

#+BEGIN_SRC clojure
    (defrecord Complex [re im])

    (let [x (->Complex 1.1 2.7)]
       (:re x))
#+END_SRC

The code generated for the last expression will be =x.re=. This can be anywhere between 66% and 450% faster.

**** =count= specializations for string and array
   :PROPERTIES:
   :CUSTOM_ID: _count_specializations_for_string_and_array
   :END:

If you apply =count= to a value that is statically inferred to be either a string or an array, the JavaScript generated will involve direct access to the =length= field instead of a runtime call to =count=.

For example =(count "abc")= will cause ="abc".length= to be emitted. Depending on context, this could be several orders of magnitude faster.

**** =simple-= / =qualified-</emphasis>= predicate-induced inference
   :PROPERTIES:
   :CUSTOM_ID: _simple_qualified_predicate_induced_inference
   :END:

If =simple-keyword?= or =qualified-keyword?= is satisfied for a local then that local is inferred to be a keyword. Similarly =simple-symbol?= or =qualified-symbol?= results in a local being as a symbol.

This essentially broadens the existing predicate-induced inferrence for =keyword?= and =symbol?= to these additional core predicates.

**** Thread predicate-induced inference through =and=
   :PROPERTIES:
   :CUSTOM_ID: _thread_predicate_induced_inference_through_and
   :END:

This type inference improvement is perhaps best explained by way of an example. For the following code

#+BEGIN_SRC clojure
    (and (string? x) (zero? (count x)))
#+END_SRC

the compiler will now know that, if the first clause in the =and= above is satisfied, then, in the second clause, =x= must be of type string. Combined with the =count= specialization mentioned above, this causes efficient JavaScript to be generated:

#+BEGIN_EXAMPLE
    typeof x === "string" && x.length === 0
#+END_EXAMPLE

**** Not inferring on =implements?=
   :PROPERTIES:
   :CUSTOM_ID: _not_inferring_on_implements
   :END:

This is an internal, yet important, optimization for the standard library: When the =implements?= predicate is satisfied on a local, the compiler generates more efficient function dispatch code for expressions involving that local.

**** Improperly widened cross-param =loop= / =recur= inference
   :PROPERTIES:
   :CUSTOM_ID: _improperly_widened_cross_param_loop_recur_inference
   :END:

A corner-case involving =loop= / =recur= widening inference was fixed where incorrect inferrence can occur if a =loop=-bound local is used as a =recur= target.

**** Dynamic Vars are now properly inferred as having type =any=
   :PROPERTIES:
   :CUSTOM_ID: _dynamic_vars_are_now_properly_inferred_as_having_type_any
   :END:

An inference bug was fixed where dynamic Vars were incorrectly inferred as having the type of their initialization value. This was incorrect because dynamic Vars can be re-bound at runtime with values of types that differ from the initialization value type.

*** Performance Improvements
  :PROPERTIES:
  :CUSTOM_ID: _performance_improvements
  :END:

**** Optimize =assoc= on =IAssociative= values
   :PROPERTIES:
   :CUSTOM_ID: _optimize_assoc_on_iassociative_values
   :END:

An optimization in the core =assoc= function makes it faster when =assoc= ing onto =IAssociative= values (the common case).

For example, =assoc= ing a key-value onto a map can be 24% faster in V8 and 11% faster in JavaScript core, a great perf boost for this frequently used core function.

**** Tag =coll= as =not-native= in =ci-reduce=
   :PROPERTIES:
   :CUSTOM_ID: _tag_coll_as_not_native_in_ci_reduce
   :END:

This is an important internal optimization affecting the standard library which improves performance when reducing collections which are =IIndexed= and =ICounted=.

**** Improve perf of =cljs.source-map.base64/encode=
   :PROPERTIES:
   :CUSTOM_ID: _improve_perf_of_cljs_source_map_base64encode
   :END:

This improves the performance of a function heavily used in the generation of source maps, improving the performance by 17% in one of our measurements.

*** Change List
  :PROPERTIES:
  :CUSTOM_ID: _change_list
  :END:

For a complete list of updates in ClojureScript 1.10.597 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.597][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.597:

-  Dieter Komendera

-  Erik Assum

-  Herald

-  Martin Kavalar

-  Martin Kučera

-  Michiel Borkent

-  Roman Liutikov

-  Seçkin Kükrer

-  Thomas Mulvaney

** [2020-04-24] Embracing JavaScript Tools
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2020-04-24-bundle-target.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2020-04-24-bundle-target
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2020-04-24 10:35:00
:CUSTOM_ID: content/news/2020-04-24-bundle-target
:END:

ClojureScript 1.10.741 includes a new streamlined way to integrate with the existing JavaScript ecosystem - the bundle target. With this target, the output of the ClojureScript compiler can be immediately handed off to a JavaScript bundler like [[https://webpack.js.org][Webpack]], [[https://facebook.github.io/metro/][Metro]], or any other build tool that understands Node.js =require=. ClojureScript projects using this new target can freely integrate libraries from =node_modules= without handwritten externs or additional configuration, yet still fully leverage REPL-driven development and advanced compilation for the optimizable parts of their application.

While the impact on ease of development for ClojureScript projects is obviously significant, we believe that the benefits for the ClojureScript ecosystem are even more exciting. You can now publish ClojureScript libraries that depend directly on the JavaScript ecosystem without additional ceremony and be confident that the whole community can benefit regardless of what other JavaScript and ClojureScript build tools they may prefer.

If you want to cut to the chase and walk through a tutorial, head over to the [[file:xref/../../guides/webpack][new guide]]. For some history and context, read on.

Over the years we've implemented and shipped a variety of features to help integration with the JavaScript ecosystem, but the end result has, in truth, felt more like a patchwork of solutions than something cut from whole cloth. Some of this can be attributed to trying to work around JavaScript existing tooling rather than embracing it. ClojureScript has invested heavily in the advanced compilation capabilities of the decade-old [[https://developers.google.com/closure/compiler][Google Closure Compiler]] project, and it seemed natural to pursue processing Node modules through it.

But after nearly three years since we first shipped Node module processing via Closure, it's apparent that too few of the most popular libraries can be subjected to advanced optimizations. While we still believe there's promise here, the ClojureScript community will have to show the rest of the world the way by developing compelling JavaScript libraries that can be readily consumed by popular JavaScript tools, yet still be subjected to Closure's phenomenal tree shaking and code splitting when building with ClojureScript. The success of projects like [[https://rollupjs.org/guide/en/][Rollup.js]] has shown that JavaScript developers are not adverse to adhering to a stricter style if it leads to significant benefits. In the meantime we need a simpler and, yes, easier way to get things done.

In [[https://clojurescript.org/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules][António Nuno Monteiro's original post]] about Node module processing there's a fairly short paragraph about how under Node.js we actually generate Node.js =require= statements for libraries we know are coming from =node_modules=. This was a fantastic idea resulting in a very idiomatic experience when interacting with Node.js. Over the next couple of years it became apparent that using ClojureScript for Node.js was often simpler than web development. No longer, the bundle target approach embraces the fact that nearly all modern JavaScript dependency resolution is either Node.js =require= or ES6 import.

Still, this only solves part of the problem. We need to apply advanced optimizations to ClojureScript generated JavaScript. Which leads us to something we call "externs inference". One of the tradeoffs with Closure's compilation model is that integrating libraries not intended for Closure consumption requires a manual and error-prone process of writing externs - files which prevent Closure from renaming properties and declarations from libraries it will not actually see. Because of an early decision by Rich Hickey to mark global variables in ClojureScript as such, and the fact that Clojure provides a simple but effective type propagation algorithm across a local scope which ClojureScript also implements, tracking the usage of "foreign" values is not as tricky as it would seem.

Combining our approach for Node.js and externs inference leads us directly to the bundle target. Of course now it all probably seems pretty obvious - but juggling various design goals can easily obscure the simple answer. By taking two distinct things - on the one hand, ClojureScript, on the other, JavaScript tools - and actually allowing them to remain distinct - we can arrive at something more than the sum of the parts. At the same time, none of these choices precludes passing everything through Closure Compiler if more JavaScript libraries begin adopting a code style amenable to aggressive dead code elimination.

This feature is the result of many discussions and inspiration from some great projects in the ClojureScript community - in particular [[https://github.com/drapanjanas/re-natal][re-natal]] and [[https://shadow-cljs.org][shadow-cljs]].

Happy hacking!

** [2020-04-24] 1.10.741 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2020-04-24-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2020-04-24-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2020-04-24 10:30:00
:CUSTOM_ID: content/news/2020-04-24-release
:END:

We're happy to announce a new release of ClojureScript. If you're an existing user of ClojureScript please read over the following release notes carefully, there are two very significant changes. First, ClojureScript now ships with greatly enhanced support for integration with popular JavaScript bundling tools such as Webpack and Metro. Second, due to continuing changes to Google Closure Compiler and Library, we've decided to drop support for the Rhino and Nashorn REPLs to lower the maintenance burden around releases.

*** Noteworthy Changes
  :PROPERTIES:
  :CUSTOM_ID: _noteworthy_changes
  :END:

-  Closure Compiler has been updated to =v20200112=

-  Closure Library has been updated to =0.0-20191016-6ae1f72f=

-  Rhino, Nashorn, and GraalJS REPLs have been removed

The latest Closure Compiler & Library releases included a number of breaking changes which significantly increased the maintenance burden for this release. Given Closure Compiler & Library's recent pace of change, we've decided to focus our energies on the essential browser and Node.js REPLs. We've also begun enrichening the CLI & REPL APIs to ease third party efforts to target these JavaScript environments.

*** New Core Features
  :PROPERTIES:
  :CUSTOM_ID: _new_core_features
  :END:

*** JavaScript Bundler Support
  :PROPERTIES:
  :CUSTOM_ID: _javascript_bundler_support
  :END:

-  =:target :bundle=

-  =:bundle-cmd=

-  =:target-fn=

-  A new =--install-deps= CLI option

We're happy to announce a significant new feature - the =:bundle= target. This target generates output that can be fed directly into popular JavaScript bundlers such as Webpack and Metro (for React Native). Not only does this greatly ease usage of Node modules, library creators can now distribute ClojureScript artifacts that depend on Node modules and be confident that users can consume these artifacts regardless of which build tool they may prefer.

There's much more to say about the =:bundle= target, and we'll be releasing a separate post and guide soon.

**** Iterator Support
   :PROPERTIES:
   :CUSTOM_ID: _iterator_support
   :END:

It is now possible to call =seq= on any object implementing JavaScript's Iterator protocol. A new core predicate, =cljs.core/js-iterable?= is introduced with this feature.

For example, =(js-iterable? (js/Set.))= is =true= and

#+BEGIN_SRC clojure
    (-> (doto (js/Set.) (.add 1) (.add 2))
      seq)
#+END_SRC

can now produce =(1 2)=.

**** Symbol Support
   :PROPERTIES:
   :CUSTOM_ID: _symbol_support
   :END:

A new core predicate =cljs.core/js-symbol?= has been added and printing has been revised to allow printing of symbols:

#+BEGIN_EXAMPLE
    cljs.user=> (js/Symbol "abc")
    #object[Symbol(abc)]
#+END_EXAMPLE

*** Warning Improvements
  :PROPERTIES:
  :CUSTOM_ID: _warning_improvements
  :END:

Single arity arithmetic operations will now warn on bad arguments:

#+BEGIN_EXAMPLE
    cljs.user=> (+ "foo")
    WARNING: cljs.core/+, all arguments must be numbers, got [string] instead at line 1 <cljs repl>
#+END_EXAMPLE

*** Performance Improvements
  :PROPERTIES:
  :CUSTOM_ID: _performance_improvements
  :END:

-  =re-pattern=, =re-matches=, and =re-find= are now faster

-  Code gen better facilitates protocol static dispatch inlining

-  Fast initial prompt for browser REPL

-  Output size minimized for trivial "Hello World" programs

*** Change List
  :PROPERTIES:
  :CUSTOM_ID: _change_list
  :END:

For a complete list of updates in ClojureScript 1.10.741 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.741][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.741:

-  Camilo Polymeris

-  Colin Kahn

-  Dieter Komendera

-  Dominic Monroe

-  Roman Liutikov

** [2021-04-06] 1.10.844 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2021-04-06-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2021-04-06-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2021-04-06 10:30:00
:CUSTOM_ID: content/news/2021-04-06-release
:END:

We're happy to announce a new release of ClojureScript. If you're an existing user of ClojureScript please read over the following release notes carefully.

*** Noteworthy & Breaking Changes
  :PROPERTIES:
  :CUSTOM_ID: _noteworthy_breaking_changes
  :END:

-  Closure Compiler has been updated to =v20210302=

-  Closure Library has been updated to =0.0-20201211-3e6c510d=

Note that the latest Closure Library release includes breaking changes that may impact your code:

-  =goog.debug.Logger.Level= has been renamed to =goog.Logger.Level= and the =goog.log.Level/getLogger= function now takes an additional argument.

-  The following JavaScript type checking predicates have been removed: =goog/isString=, =goog/isArray=, =goog/isFunction=, =goog/isNumber=, and =goog/isBoolean=.

-  Closure namespace loading logic has been revised, necessitating updates to some REPLs.

*** New Core Features
  :PROPERTIES:
  :CUSTOM_ID: _new_core_features
  :END:

**** Library Property Namespaces
   :PROPERTIES:
   :CUSTOM_ID: _library_property_namespaces
   :END:

When consuming a JavaScript library which is exposed as a JavaScript object, you can now specify a property of this object to be used as a first-class namespace in ClojureScript. To do this, you use the =$= delimiter.

For example, the =SubLib= property of a library object provided by =npm-lib= can be treated as a namespace like so:

#+BEGIN_SRC clojure
    (ns foo
      (:require [npm-lib$SubLib :as sub-lib :refer [...]]))
#+END_SRC

If needed, you can also employ string-based requires:

#+BEGIN_SRC clojure
    (ns foo
      (:require ["@npm/lib$SubLib" :as sub-lib :refer [...]]))
#+END_SRC

This feature can also be used to access =default= exports:

#+BEGIN_SRC clojure
    (ns foo
      (:require [npm-lib$default :as npm-lib :refer [...]]))
#+END_SRC

The =$= delimiter is only needed to access the top-level object property; any nested properties are accessed via =.= as in the following example:

#+BEGIN_SRC clojure
    (ns foo
      (:require [react-native$NativeModules.SomeBridge :as woz]))
#+END_SRC

*** Notable Fixes
  :PROPERTIES:
  :CUSTOM_ID: _notable_fixes
  :END:

**** Accurate file name and line numbers in =cljs.test=
   :PROPERTIES:
   :CUSTOM_ID: _accurate_file_name_and_line_numbers_in_cljs_test
   :END:

Instead of inaccurately inferring file name and line numbers from the call stack in =do-report=, they are now captured during macro-expansion based on metadata.

**** =sort= and =sort-by= retain meta
   :PROPERTIES:
   :CUSTOM_ID: _sort_and_sort_by_retain_meta
   :END:

This simple change makes =sort= and =sort-by= consistent with Clojure. For example, the following evaluates to ={:a true}=:

#+BEGIN_SRC clojure
    (meta (sort (with-meta (range 10) {:a true})))
#+END_SRC

**** Floating point issues with =range=
   :PROPERTIES:
   :CUSTOM_ID: _floating_point_issues_with_range
   :END:

Some floating point issues were addressed for =range=, making, for example =(range 0 (+ 1 (/ 9)) (/ 9))= have 10 elements and =(nth (range 0 1 0.1) 6)= properly evaluate to =0.6=.

**** =#inst= parsing and printing, reflect proleptic Gregorian
   :PROPERTIES:
   :CUSTOM_ID: _inst_parsing_and_printing_reflect_proleptic_gregorian
   :END:

JavaScript employs a proleptic Gregorian date system and some bugs in ClojureScript's =#inst= support is now fixed for very old dates with respect to parsing and printing =#inst= values.

*** Performance Improvements
  :PROPERTIES:
  :CUSTOM_ID: _performance_improvements
  :END:

**** Reduce code generated by destructure macro for maps
   :PROPERTIES:
   :CUSTOM_ID: _reduce_code_generated_by_destructure_macro_for_maps
   :END:

The code generated to implement map destructuring was optimized by introducing a shared helper to handle kw-args, reducing a portion of the Closure-optimized output from 35 bytes down to 5, a nice savings since map destructuring is frequently employed in code.

*** Change List
  :PROPERTIES:
  :CUSTOM_ID: _change_list
  :END:

For a complete list of updates in ClojureScript 1.10.844 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.844][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.844:

-  Arne Brasseur

-  Erik Assum

-  Hyunwoo Nam

-  Matthew Huebert

-  Thomas Heller

** [2021-05-24] 1.10.866 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2021-05-24-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2021-05-24-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2021-05-24 10:30:00
:CUSTOM_ID: content/news/2021-05-24-release
:END:

We're happy to announce a new release of ClojureScript. If you're an existing user of ClojureScript please read over the following release notes carefully.

*** Noteworthy Changes
  :PROPERTIES:
  :CUSTOM_ID: _noteworthy_changes
  :END:

-  Closure Compiler has been updated to =v20210505=

*** New Core Features
  :PROPERTIES:
  :CUSTOM_ID: _new_core_features
  :END:

**** =and= / =or= Optimization as Compiler Pass
   :PROPERTIES:
   :CUSTOM_ID: _and_or_optimization_as_compiler_pass
   :END:

ClojureScript generates efficient JavaScript for =and= / =or=, employing =&&= / =||= when applied to Boolean values. Previously these optimizations were implemented directly by the =and= / =or= macros. With this release they are instead implemented during a compiler pass.

A consequence of moving these optimizations to the code generation phase is that the resulting simplified =and= / =or= macros are compatibile with code walking libraries like =core.async=.

**** Support Macros that Expand to =require= Statements
   :PROPERTIES:
   :CUSTOM_ID: _support_macros_that_expand_to_require_statements
   :END:

#+BEGIN_QUOTE
  *NOTE:* this change been reverted in following releases as it was discovered later (after many tests, including ClojureScript Canary) that there are many scenarios which cannot work. It will not be reintroduced.
#+END_QUOTE

This release allows macros that expand to =require= statements to be present in the code as is illustrated in the following example:

#+BEGIN_SRC clojure
    (ns foo.bar
      (:require-macros [foo.baz :refer [macro-that-expands-to-require]]))
    (macro-that-expands-to-require)
#+END_SRC

*** Notable Fixes
  :PROPERTIES:
  :CUSTOM_ID: _notable_fixes
  :END:

**** Support =IAssociative= =-contains-key?= Protocol Check in =contains?=
   :PROPERTIES:
   :CUSTOM_ID: _support_iassociative_contains_key_protocol_check_in_contains
   :END:

The =IAssociative= protocol defines =-contains-key?=, which facilitates directly testing whether a key is in an associative collection. The core =contains?= function has been revised with this release to make such a call for collections that implement the =IAssociative= protocol.

**** Higher-Order Checked Arrays
   :PROPERTIES:
   :CUSTOM_ID: _higher_order_checked_arrays
   :END:

With this release, the [[https://clojurescript.org/news/2017-07-14-checked-array-access][checked array access]] feature is extended for higher-order uses of =aget= and =aset=. For example,

#+BEGIN_SRC clojure
    (apply aget [(into-array [0]) 100])
#+END_SRC

will now trigger a warning or error at runtime if this feature is enabled via [[https://clojurescript.org/reference/compiler-options#checked-arrays][compiler configuration]].

*** Change List
  :PROPERTIES:
  :CUSTOM_ID: _change_list
  :END:

For a complete list of updates in ClojureScript 1.10.866 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.866][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.866:

-  Arne Brasseur

-  Dieter Komendera

-  Dominic Monroe

-  Erik Assum

-  Wilker Lúcio

** [2021-11-04] 1.10.891 Release
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/news/2021-11-04-release.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/news/2021-11-04-release
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2021-11-04 10:30:00
:CUSTOM_ID: content/news/2021-11-04-release
:END:

We're happy to announce a new release of ClojureScript. If you're an existing user of ClojureScript please read over the following release notes carefully.

*** Noteworthy Changes
  :PROPERTIES:
  :CUSTOM_ID: _noteworthy_changes
  :END:

-  Closure Compiler has been updated to =v20210808=

-  Google Closure has been updated to =0.0-20211011-0726fdeb=

*** Google Closure Library, goog.module & global access
  :PROPERTIES:
  :CUSTOM_ID: _google_closure_library_goog_module_global_access
  :END:

You should no longer assume that Google Closure Library namespaces can be reached globally because some dependency may have already loaded it. For proper usage of Google Closure Library namespaces, an explicit require is always necessary.

Some ClojureScript libraries assume that because =cljs.core= loaded =goog.object=, it would be safe to refer to such definitions directly, i.e. =goog.object/get= without the necessary require. This pattern can be useful in the writing of macros so that users can elide a require. However, this is now an anti-pattern and will fail.

Google has slowly been converting various namespaces to the =goog.module= format which does not export globally as =goog.provide= does. In order to future proof - ClojureScript now always loads =goog.module= in accordance with Closure's guidelines as Closure Library may decide to convert any namespace into a =goog.module= at any time and simply drop support for global definition for that namespace.

To ease the transition for the most common cases, ClojureScript has a new compiler flag to restore the old behavior - =:global-goog-object&array=.

Note the above guidance does not apply to ClojureScript libraries. To understand why, we briefly answer some related questions.

**** Will ClojureScript use =goog.module=?
   :PROPERTIES:
   :CUSTOM_ID: _will_clojurescript_use_goog_module
   :END:

No. Clojure style REPL driven development is best supported by the original Google Closure namespace conventions. By representing namespaces as nested JavaScript objects, we effectively get late bound environments that are semantically close to Clojure's vars which permit highly interactive development workflows.

Like ES modules, the =goog.module= format is simply incompatible with REPL driven development. In both cases the module is effectively a function closure, precise redefinition is simply not a part of the design. The complexities and tradeoffs for interactive development are readily apparent when comparing typical JavaScript "hot-reloading" workflows and the development experience available to Clojure developers.

**** What if Closure Compiler deprecates =goog.provide=?
   :PROPERTIES:
   :CUSTOM_ID: _what_if_closure_compiler_deprecates_goog_provide
   :END:

Fortunately Google Closure Compiler is very mature. Unlike currently popular JavaScript tools it does not need exports to understand what to tree-shake. Closure Compiler works on objects and their properties. Even if Closure Compiler removed =goog.provide=, we could simply provide our own analogous constructs and Closure Compiler would still be able to provide all the usual advanced optimizations.

*** Change List
  :PROPERTIES:
  :CUSTOM_ID: _change_list
  :END:

For a complete list of updates in ClojureScript 1.10.891 see [[https://github.com/clojure/clojurescript/blob/master/changes.md#1.10.891][Changes]].

*** Contributors
  :PROPERTIES:
  :CUSTOM_ID: _contributors
  :END:

Thanks to all of the community members who contributed to ClojureScript 1.10.891:

-  Chance Russell

* Privacy
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/privacy.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/privacy
:CLOJURESCRIPT_SITE_AUTHOR: Rich Hickey
:CLOJURESCRIPT_SITE_DATE: 2021-08-25
:CUSTOM_ID: content/privacy
:END:
** PRIVACY POLICY
  :PROPERTIES:
  :CUSTOM_ID: _privacy_policy
  :END:

Cognitect, Inc. ("*Cognitect,*" "*we,*" or "*us*") provides the website located at www.clojurescript.org (the "*Website*"). We value and respect your privacy. This "*Privacy Policy*" demonstrates our commitment to your right of privacy and explains how we use, disclose and protect the Personal Information (as defined below) of users ("*you,*" "*User,*" or "*your*") of the Website. By visiting the Website, you expressly consent to the use and disclosure of your Personal Information as described below. If you do not agree with the terms set out in this Privacy Policy, please do not visit the Website.

** WHAT INFORMATION DO WE COLLECT?
  :PROPERTIES:
  :CUSTOM_ID: _what_information_do_we_collect
  :END:

Personal information is data that can be used to identify or contact a single person ("*Personal Information*"). We generally collect or receive Personal Information when you visit the ask.clojure.org domain on the Website in the following ways: - when you voluntarily provide information to us, such as when you post questions, answers, or content on our forum or knowledgebase, or contact us; - we collect information automatically through use of our Website; and - other parties, such as GitHub, may provide information to us or grant us access to information which can be reasonably linked to you.

Each of these methods is described in more detail below: - Information You Voluntarily Choose to Provide - The Personal Information we collect from you will vary depending on the services you are using, parts of the Website you are visiting, and how you access those services and/or Website. The Personal Information you provide to us may include any information you submit to us through email and post on our knowledgebase and forum. - You agree not to submit information that contain or reference, and understand and agree we have no obligations or liability with respect to: (i) information that can identify an individual in relation to any past, present, or future physical or mental health or condition, provision of health care, or payment for the provision of health care, including, but not limited to, diagnoses, treatment information, medical test results, and prescription information; and/or (ii) an individual's race, ethnic origin, political opinions, religious or philosophical beliefs, genetic data, biometric data, sex life or sexual orientation. Without limiting the generality of the foregoing, you acknowledge in no event will Cognitect be liable to you or any third party for any direct, indirect, incidental, lost profits, remote, cover, exemplary, consequential, special, or punitive damages, regardless of the foreseeability of such damages resulting from your submission of any such information. - Information Collected Automatically When You Use the Website Like most websites, we collect basic web traffic information (such as IP addresses) to monitor overall usage of our Website, understand Website traffic patterns, and identify if there are problems on the Website. - Information We Receive from Others In some cases, other parties provide us with Personal Information about you, or allow us to collect Personal Information about you. Although we cannot control your privacy settings at those websites or how those other parties protect your privacy, once we receive information about you through those websites, we will treat it in accordance with this Privacy Policy. - You may also be able to link an account from third-party websites, such as GitHub, to our Website. This may allow you to use your credentials from the other site or service to sign in to certain features on our Website. If you link your account from a third-party site or service, we may collect information from those third-party accounts, and any information that we collect will be governed by this Privacy Policy.

** HOW DO WE USE YOUR PERSONAL INFORMATION?
  :PROPERTIES:
  :CUSTOM_ID: _how_do_we_use_your_personal_information
  :END:

We use your Personal Information: - to provide the services or information you request; - to develop, deliver, and improve our services, user experience and other offerings; - to communicate with you regarding your use of the Website and/or Product; - to measure the effectiveness of our content; - to monitor performance of the Websites; - to monitor and moderate online community interactions on the Website (for example, questions, answers and posts on our knowledgebase and forum); - to protect our rights and the rights of our Website visitors; - to protect the vital interests of the Company, you, or our other Website visitors (for example, in the event of an emergency); and - for internal auditing purposes. We also collect information in an aggregated form that does not, on its own, permit direct association with any specific individual. We may collect, use, transfer, and disclose aggregated or otherwise non-personal information for any purpose.

** HOW DO WE USE COOKIES?
  :PROPERTIES:
  :CUSTOM_ID: _how_do_we_use_cookies
  :END:

We do not use cookies on the Website.

** WHEN MAY A THIRD PARTY RECEIVE ACCESS TO YOUR PERSONAL INFORMATION?
  :PROPERTIES:
  :CUSTOM_ID: _when_may_a_third_party_receive_access_to_your_personal_information
  :END:

Cognitect will not disclose your Personal Information to any third parties except: - to our professional advisers, accountants, insurers, lawyers and auditors on a confidential basis; - if Cognitect or its assets are or may be acquired by a third party, the information may be provided to that third party and its advisors; - in exceptional circumstances, Cognitect may be required or permitted by law to disclose Personal Information, for example where such disclosure is necessary to meet any applicable law, regulation, legal process or other legal obligation; detect, investigate and help prevent security, fraud or technical issues; and/or protect the rights, property or safety of Cognitect, our employees or other users of the Website.; or - otherwise with your consent.

Cognitect does not sell your Personal Information.

Cognitect may disclose your Personal Information to Cognitect's parent company, affiliated legal entities, subsidiaries and any other businesses with whom we are under common corporate control (collectively the "*Affiliates*"). All of our Affiliates that receive your information from us will comply with the terms of this Privacy Policy with respect to their use and disclosure of such information.

** HOW DOES COGNITECT KEEP YOUR INFORMATION SECURE?
  :PROPERTIES:
  :CUSTOM_ID: _how_does_cognitect_keep_your_information_secure
  :END:

Cognitect is committed to keeping your information secure. We endeavor to take all reasonable steps to keep secure any information that we hold about you, and to keep this information accurate and up to date. Your information is stored on secure servers that are protected in controlled facilities. Other than the sharing of information outlined in this Privacy Policy, personally identifiable information is not accessible by the public, and we require our employees and data processors to respect the confidentiality of any Personal Information. Any personally identifiable information on user profiles is private.

** CHILDREN'S PRIVACY
  :PROPERTIES:
  :CUSTOM_ID: _childrens_privacy
  :END:

We do not direct our Website to children (usually considered to be under the age of 13, depending on the country where you reside). We also do not intentionally collect Personal Information from children through our Website. If you are the parent or guardian of a child and you believe that we have inadvertently received Personal Information about that child, please contact us as described in the Contact Us section of this Privacy Policy and we will take reasonable steps to remove the information from our records.

** GAINING ACCESS TO, UPDATING DELETING YOUR INFORMATION OR WITHDRAWING CONSENT
  :PROPERTIES:
  :CUSTOM_ID: _gaining_access_to_updating_deleting_your_information_or_withdrawing_consent
  :END:

If at any time you want to request, update, correct or remove Personal Information, you are welcome to submit a request to [[mailto:support@cognitect.com][support@cognitect.com]]. We may ask you to verify your identity before we can act on your request. If you are aware of changes or inaccuracies in your Personal Information, you should inform us of such changes so that our records may be updated or corrected.

We may reject requests that are unreasonably repetitive, require disproportionate technical effort (for example, developing a new system or fundamentally changing an existing practice), risk the privacy of others, or would be extremely impractical (for instance, requests concerning information residing on backup systems).

Where we can provide information access and correction, we will do so, except where it would require a disproportionate effort. We aim to maintain our services in a manner that protects information from accidental or malicious destruction. Because of this, after you delete information from our services, we may not immediately delete residual copies from our active servers and may not remove information from our backup systems.

Where consent is required for our use of your Personal Information as described herein, you have the right to withdraw or decline your consent and cease your use of the Website. If you decide to withdraw your consent, such withdrawal will not affect the lawfulness of processing based on consent before such withdrawal.

** CALIFORNIA PRIVACY RIGHTS
  :PROPERTIES:
  :CUSTOM_ID: _california_privacy_rights
  :END:

California Civil Code Sec. 1798.100, et seq. (also known as the California Consumer Privacy Act of 2018) ("*CCPA*") provides certain rights to California residents regarding their Personal Information. A California resident has the right to request that we disclose certain information, including: (1) the categories of Personal Information we have collected about that California resident, (2) the categories of sources from which the Personal Information is collected, (3) the business or commercial purpose for collecting or selling the Personal Information, (4) the categories of third parties with whom Cognitect shares Personal Information, and (5) the specific pieces of Personal Information we have collected about the resident. A California resident has the right to request that we delete his/her Personal Information. Finally, a California resident has the right not to be discriminated against for exercising his/her privacy rights under the CCPA. You can request such Personal Information and change your Personal Information by emailing us at [[mailto:support@cognitect.com][support@cognitect.com]].

Pursuant to California Civil Code Section 1789.3, California users are entitled to the following consumer rights notice: California residents may reach the Compliant Assistance Unit of the Division of Consumer Services for the California Department of Consumer Affairs by mail at 1625 North Market Blvd., Sacramento, CA 95834, or by telephone at (916) 445-1254 or (800) 952-5210.

** LINKS TO OTHER WEBSITES
  :PROPERTIES:
  :CUSTOM_ID: _links_to_other_websites
  :END:

The Website contains links to other websites. These third-party websites have separate and independent privacy policies. The privacy policies and applicable terms of use of the third-party websites will govern your interaction with such third-party websites. We encourage you to review the privacy policy of linked sites, as Cognitect is not responsible or liable for the practices, content, and/or privacy policies of those third-party websites. Nonetheless, we seek to protect the integrity of our Website and welcome any feedback about these third-party websites.

** DATA RETENTION
  :PROPERTIES:
  :CUSTOM_ID: _data_retention
  :END:

We will retain your Personal Information only for as long as reasonably necessary for the purposes set out above, considering criteria such as applicable rules on statute of limitations, legal requirements and the duration of your use of the Website and receipt of our services.

** INTERNATIONAL USERS & USERS FROM THE EUROPEAN UNION
  :PROPERTIES:
  :CUSTOM_ID: _international_users_users_from_the_european_union
  :END:

This section of the Privacy Policy applies only if you use the Website or services covered by this Privacy Policy from a country that is a Member State of the European Union and supplements the information in this Privacy Policy.

We process information defined as personal data under applicable data protection law ("*Personal Data*") for the purposes set out in this Privacy Policy, as described above. - Legal Basis for Processing Personal Data: Our legal basis to process Personal Data, such as for the purposes listed above in the "How Do We Use Your Personal Information?" section, includes processing that is: - necessary to comply with legal requirements (for example, to comply with applicable accounting rules and to make mandatory disclosures to law enforcement); - protection of the vital interests of a natural person (for example, in the event of an emergency); - necessary for our legitimate interests (for example, to manage our relationship with you and to improve the Website and our services); and - based on your consent (for example, to communicate with you about the Website and services), which may subsequently be withdrawn at any time (by contacting us at [[mailto:support@cognitect.com][support@cognitect.com]]) without affecting the lawfulness of processing based on consent before its withdrawal. - In some instances, you may be required to provide us with Personal Data for processing as described above, in order for us to be able to provide you all of our services, and for you to use all the features of the Website. - Please be aware your Personal Data may be collected, managed, transferred to, processed, and stored or accessed in a country different other than your country of residence. In addition, we may make other disclosures of your Personal Data outside of your country of residence, for example, in the event we receive a legal or regulatory request from a foreign law enforcement body. We will always take steps designed to ensure any transfer of such information outside your country of residence is carefully managed to protect your rights and interests by implementing appropriate safeguards to protect your Personal Data. Data protection laws in any such country may be different from those laws of your country of residence. By visiting the Website and accepting this Privacy Policy, you consent to the transfer of your information, including Personal Data, to such country(ies) as set forth in this Privacy Policy.

-  From time to time, Personal Information we collect from data subjects in the European Economic Area or Switzerland ("EEA or Switzerland") may be transferred to, stored, processed or accessed by us outside of the EEA or Switzerland, for example, the United States. We will always take steps to ensure any transfer of such information outside the EEA or Switzerland is carefully managed to protect your rights and interests by implementing appropriate safeguards to protect your Personal Data.

-  If you would like to find out more about these safeguards in respect of processing your Personal Data and the means by which you can obtain a copy of them, please contact us at [[mailto:support@cognitect.com][support@cognitect.com]].

-  Your Rights: In addition to the rights to access, amend or delete your Personal Data as set out above, you may be entitled, in accordance with applicable law, to object to or request the restriction of processing of your Personal Data, and to request portability of your own Personal Data. Requests should be submitted to [[mailto:support@cognitect.com][support@cognitect.com]].

-  If you consider that our processing of your Personal Data infringes applicable law, you may lodge a complaint with a competent supervisory authority, which may be the authority in your Member State of residence or work.

** FUTURE REVISIONS
  :PROPERTIES:
  :CUSTOM_ID: _future_revisions
  :END:

Cognitect's Website and activities may continue to grow and change. Because of this, from time to time, our Privacy Policy will be reviewed and revised. You should check this page occasionally to ensure you are familiar with those changes. Whenever we change our Privacy Policy we will post an updated version on our Website, including the last date of revision.

This Privacy Policy was last revised on August 25, 2021.

** CONTACT US
  :PROPERTIES:
  :CUSTOM_ID: _contact_us
  :END:

If you have any questions about how we handle your Personal Information and protect your privacy, please feel free to contact us at [[mailto:support@cognitect.com][support@cognitect.com]] or call us at 919.283.2748. You may also mail requests to:

Cognitect

101 W. Chapel Hill Street., Suite 300

Durham, NC 27701

USA
* Reference
** Advanced Compilation
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/advanced-compilation.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/advanced-compilation
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/advanced-compilation
:END:

If you are targeting traditional JavaScript clients (web browsers) it's important to think about advanced compilation from the very beginning. Otherwise you will inevitably find yourself going through issues that could have been easily avoided with a little bit of up front preparation. In general do not wait to try an advanced build, you should always periodically generate a production build to catch issues sooner.

*** Avoid Foreign Libraries
  :PROPERTIES:
  :CUSTOM_ID: avoid-foreign-libraries
  :END:

It's best to simply avoid foreign libraries if a solution exists either in Google Closure Library or in an existing ClojureScript library. Foreign libraries must supply externs for advanced compilation to work consistently.

Of course, in some cases foreign libraries cannot be avoided.

*** Using Foreign Libraries
  :PROPERTIES:
  :CUSTOM_ID: using-foreign-libraries
  :END:

If you must use a foreign library use a curated one like those provided by [[http://cljsjs.github.io][CLJSJS]]. These come packaged with externs so that you do not have to supply them yourself.

Occasionally you may find yourself needing a foreign library which has not been prepackaged.

*** Providing externs
  :PROPERTIES:
  :CUSTOM_ID: providing-externs
  :END:

When working with a foreign library which does not supply externs take the time to write an externs file for the API you intend to use. Externs files are surprisingly simple to provide. For example if the foreign library has some property =Foo.bar= that you wish to access your externs file should have the following entry:

#+BEGIN_EXAMPLE
    Foo.bar;
#+END_EXAMPLE

If the foreign library has some method =Foo.baz= that you wish to invoke your externs file should have the following entry:

#+BEGIN_EXAMPLE
    Foo.baz = function() {};
#+END_EXAMPLE

Sometimes there will not be a top level API but rather some method naming convention, that is, an ad-hoc Interface / Protocol. In these cases define your externs using Object:

#+BEGIN_EXAMPLE
    Object.foo = function() {};
    Object.bar = function() {};
#+END_EXAMPLE

Of course sometimes you will miss an extern entry and the the production file will produce a cryptic error. Thanks to a couple of Closure compiler options these issues are no longer difficult to debug.

*** Access from JavaScript
  :PROPERTIES:
  :CUSTOM_ID: access-from-javascript
  :END:

If you'd like to access ClojureScript code from JavaScript, then you will need to cope with the fact that advanced compilation will munge the JavaScript representation of your Var names. This can be easily addressed by adding =:export= metadata to Vars that should be consumable from JavaScript.

For example, if you have a =square= function, you can annotate it with =^:export= as follows:

#+BEGIN_EXAMPLE
    (ns my-math.core)

    (defn ^:export square [x]
      (* x x))
#+END_EXAMPLE

With this, you can call your =square= function from JavaScript as follows:

#+BEGIN_EXAMPLE
    my_math.core.square(3);
#+END_EXAMPLE

This works by including [[https://google.github.io/closure-library/api/goog.html#exportSymbol][=goog.exportSymbol=]] calls in the emitted JavaScript wherever =:export= meta is associated with a Var.

#+BEGIN_QUOTE
  *Note*

  For each exported Var, an additional un-renamed alias is established which points to the Closure-munged name. Munged names continue to be used internally within the optimized code.

  The =^:export= facility is for (and only for) providing external access to Vars via un-renamed aliases. If instead you'd like to debug optimized code which is using shortened names, consider =:pseudo-names= and =:pretty-print=, which are described in the following section.
#+END_QUOTE

You can individually export the Vars associated with protocol methods. In this example, =bar= and =quux= will be exported:

#+BEGIN_EXAMPLE
    (defprotocol IFoo
      (^:export bar [this])
      (baz [this x])
      (^:export quux [this x y]))
#+END_EXAMPLE

*** Fixing Advanced Compilation Issues
  :PROPERTIES:
  :CUSTOM_ID: fixing-advanced-compilation-issues
  :END:

Change your production build to use two additional options =:pseudo-names true= and =:pretty-print true=. Now your error will show a name that corresponds to the name in the original source. Add an externs entry for this missed case.

For more information about the specifics of =:foreign-libs= compiler option syntax consult [[file:dependencies]].

** Bootstrapping the Compiler
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/bootstrapping.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/bootstrapping
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/bootstrapping
:END:

See [[https://github.com/swannodette/cljs-bootstrap]]

Current status:

-  ClojureScript can now compile both its analyzer & compiler w/o errors. Can eval non-trivial ClojureScript exprs from within the JS host.

-  Performance reading, analysis & compilation within bootstrapped ClojureScript has been optimized to be roughly within a factor of 2 of ClojureScript JVM (varying perf between engines).

-  Master is successfully being used in various contexts:

   -  [[https://github.com/swannodette/cljs-bootstrap][cljs-bootstrap]]

   -  [[https://twitter.com/bus_kanaka/status/616026801412804608][Node.js REPL]]

   -  [[http://clojurescript.net][Browser REPL]]

   -  [[https://github.com/mfikes/replete][iOS REPL: Replete]]

   -  [[https://github.com/tahmidsadik112/Replicator][Android REPL: Replicator]]

   -  [[https://github.com/mfikes/planck][OS X REPL: Planck]]

   -  [[https://jellea.github.io/QuilFiddle/][QuilFiddle]]

   -  [[https://roman01la.github.io/threejs-cljs-playground/][Threejs playground]]

   -  [[https://github.com/ScalaConsultants/replumb][Library for bootstrapped REPLs: Replumb]]

   -  [[http://crepl.thegeez.net][crepl: collaborative repl]]

   -  [[https://github.com/anmonteiro/lumo][Desktop REPL: Lumo]]

   -  [[https://github.com/viebel/klipse][Embeddable clojurescript repl: KLIPSE]]

   -  [[https://ctford.github.io/klangmeister][Musical live coding environment: Klangmeister]]

The following enumerates the remaining tasks:

-  Ensure perf is good.

-  Ensure defects are addressed. Many have =bootstrap= label: [[https://clojure.atlassian.net/issues/?jql=%20project%20%3D%20CLJS%20AND%20labels%20%3Dbootstrap][JIRA Query]]

-  Determine if shared bootstrap REPL code will be included and implement.

/* you can use the [[https://github.com/cljsinfo/api-refs/tree/catalog#-clojurescript-api-reference][CLJS API reference]] to help identify imported macros and related Clojure types/

*** cljs-in-cljs from 2012
  :PROPERTIES:
  :CUSTOM_ID: cljs-in-cljs-from-2012
  :END:

As a point of reference, [[https://github.com/kanaka/clojurescript]] is a previous project to bootstrap the ClojureScript compiler. It is fairly dated since it was forked from the main tree on Nov 16th, 2012, however, it was self-hosting and allowed for a fully browser-based REPL (original version of [[http://clojurescript.net/]]). A presentation of the project from Clojure West 2013 is here: [[http://www.infoq.com/presentations/cljs-in-cljs]]

** Compiler Options
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/compiler-options.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/compiler-options
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/compiler-options
:END:

Here is the list of compiler options that can be passed to the ClojureScript compiler.

*** Common Options
  :PROPERTIES:
  :CUSTOM_ID: common-options
  :END:

**** :asset-path
   :PROPERTIES:
   :CUSTOM_ID: asset-path
   :END:

When using =:main= it is often necessary to control where the entry point script attempts to load scripts from due to the configuration of the web server. =:asset-path= is a relative URL path not a file system path. For example, if your output directory is =:output-dir "resources/public/js/compiled/out"= but your webserver is serving files from ="resources/public"= then you want the entry point script to load scripts from "js/compiled/out".

#+BEGIN_SRC clojure
    :asset-path "js/compiled/out"
#+END_SRC

**** :bundle-cmd
   :PROPERTIES:
   :CUSTOM_ID: bundle-cmd
   :END:

When using =:target :bundle=, set shell commands to be run after a build. This command is not parameterizable. You should provide both =:none= which will be run after dev builds, and =:default= which will be run after builds passed through Closure Compiler. The command should be one that exits, i.e. you cannot use this to launch a watcher.

#+BEGIN_SRC clojure
    :bundle-cmd {:none ["npx" "webpack" "--mode=development"]
                 :default ["npx" "webpack"]}
#+END_SRC

**** :checked-arrays
   :PROPERTIES:
   :CUSTOM_ID: checked-arrays
   :END:

If set to =:warn= or =:error=, checks inferred types and runtime values passed to =aget= and =aset=. Inferred type mismatches will result in the =:invalid-array-access= warning being triggered. Logs when incorrect values are passed if set to =:warn=, throws if set to =:error=. May be set to a =false=-y value to disable this feature.

This setting does not apply if =:optimizations= is set to =:advanced=.

#+BEGIN_SRC clojure
    :checked-arrays :warn
#+END_SRC

**** :externs
   :PROPERTIES:
   :CUSTOM_ID: externs
   :END:

Configure externs files for external libraries. The files are searched for in the current working directory and on the classpath.

For this option, and those below, you can find a very good explanation at: [[http://lukevanderhart.com/2011/09/30/using-javascript-and-clojurescript.html]]

Defaults to the empty vector =[]=.

#+BEGIN_SRC clojure
    :externs ["jquery-externs.js"]
#+END_SRC

**** :foreign-libs
   :PROPERTIES:
   :CUSTOM_ID: foreign-libs
   :END:

Adds dependencies on foreign libraries. Be sure that the url returns a HTTP Code 200.

Defaults to the empty vector =[]=

#+BEGIN_SRC clojure
    :foreign-libs [{ :file "http://example.com/remote.js"
                     :provides  ["my.example"]
                     :global-exports '{my.example MyExample}}
                   { :file "./resources/js/local.js"
                     :provides ["my.other.example"]}
                   { :file "./path/to/directory/"
                     ;; :provides will be automatically generated based on
                     ;; each .js filename. E.g: your.dep.js file will
                     ;; provides ["your.dep"]. Custom defined :provides in
                     ;; this case will be overwritten.
                    }]
#+END_SRC

Each element in the =:foreign-libs= vector should be a map, where the keys have these semantics:

-  =:file= Indicates the URL to the library. This can be either local path or remote url to the dependency file. If local path is a directory instead of a file, the compiler will recursively go through all =.js= files within the directory and automatically assign a =:provides= values based on the =.js= filename. E.g: =your.js.deps.js= results in computed =:provides= =["your.js.deps"]=, and your custom =:provides= will be overwritten by the generated =:provides=.

-  =:file-min= (Optional) Indicates the URL to the minified variant of the library. This will be used in preference to =:file= if [[optimizations][=:optimizations=]] is set to either =:simple= or =:advanced=.

-  =:provides= A synthetic namespace that is associated with the library. This is typically a vector with a single string, but it has the capability of specifying multiple namespaces (typically used only by Google Closure libraries).

-  =:requires= (Optional) A vector explicitly identifying dependencies (=:provides= values from other foreign libs); used to form a topological sort honoring dependencies.

-  =:module-type= (Optional) indicates that the foreign lib uses a given module system. Can be one of =:commonjs=, =:amd=, =:es6=. Note that if supplied, =:requires= is not used (as it is implicitly determined). For more info see [[file:xref/../javascript-module-support][JavaScript Module Support (Alpha)]].

-  =:preprocess= (Optional) Used to preprocess / transform code in other dialects (JSX, etc.). The value can be either a symbol or a keyword. If symbol is provided, it should resolve to a function that takes two parameters: js-module and options maps. Compiler will require the namespace to which the symbol refers if it is not yet loaded. If value is keyword, it is used as dispatch value for =cljs.clojure/js-transforms= multimethod. For more info see [[file:xref/../javascript-library-preprocessing][JavaScript Library Preprocessing]].

-  =:global-exports= (Optional) used to map provided namespaces to globally exported values. The keys may be symbols or strings. If present the foreign library can be used idiomatically when required, i.e. support for =:refer=, =:rename=, =:as=, etc.

[[:global-goog-object&array]] === :global-goog-object&array

Defaults to =false=. If =true= load =goog.object= and =goog.array= as global namespaces rather than as =goog.module= namespaces.

**** :install-deps
   :PROPERTIES:
   :CUSTOM_ID: install-deps
   :END:

If =true= automatically install all declared =:npm-deps= including those declared in upstream dependencies.

**** :main
   :PROPERTIES:
   :CUSTOM_ID: main
   :END:

Specifies an entry point namespace. When combined with optimization level =:none=, =:main= will cause the compiler to emit a single JavaScript file that will import *goog/base.js*, the JavaScript file for the namespace, and emit the required =goog.require= statement. This permits leaving HTML markup identical between dev and production.

#+BEGIN_SRC clojure
    :main "foo.bar"
#+END_SRC

Also see =:asset-path=.

#+BEGIN_QUOTE
  *Note*

  Note: This will result in the main namespace, along with the transitive closure of all =:require=d namespaces to be loaded into your JavaScript environment. If you have other non-referenced namespaces that need to be loaded, consider either =:require=ing them or manually loading them by issuing the appropriate additional =goog.require= statements.
#+END_QUOTE

**** :modules
   :PROPERTIES:
   :CUSTOM_ID: modules
   :END:

A new option for emitting Google Closure Modules. Closure Modules supports splitting up an optimized build into N different modules. If =:modules= is supplied it replaces the single =:output-to=. A module needs a name, an individual =:output-to= file path, =:entries= a set of namespaces, and =:depends-on= a set of modules on which the module depends. An example follows:

#+BEGIN_SRC clojure
    {:optimizations :advanced
     :source-map true
     :output-dir "resources/public/js"
     :modules {
       :common
         {:output-to "resources/public/js/common.js"
          :entries #{"com.foo.common"}}
       :landing
         {:output-to "resources/public/js/landing.js"
          :entries #{"com.foo.landing"}
          :depends-on #{:common}}
       :editor
         {:output-to "resources/public/js/editor.js"
          :entries #{"com.foo.editor"}
          :depends-on #{:common}}}}
#+END_SRC

Any namespaces not in an =:entries= set will be moved into the default module =:cljs-base=. However thanks to cross module code motion, Google Closure can move functions and methods into the modules where they are actually used. This process is somewhat conservative so if you know that you want to keep some code together do this via =:entries=.

The =:cljs-base= module defaults to being written out to =:output-dir= with the name "cljs\_base.js". This may be overridden by specifying a =:cljs-base= module describing /only/ =:output-to=.

Take careful note that a namespace may only appear once across all module =:entries=.

=:modules= fully supports =:foreign-libs=. =:foreign-libs= are always put into dependency order before any Google Closure compiled source.

Source maps are fully supported, an individual one will be created for each module. Just supply =:source-map true= (see example) as there is no single source map to name.

**** :npm-deps
   :PROPERTIES:
   :CUSTOM_ID: npm-deps
   :END:

Control NPM dependencies. A map of NPM package names (keywords or strings) to the desired versions, or a Boolean value. A =node_modules= directory will be indexed and used if set to a truthy value. Defaults to =false=. (In ClojureScript 1.10.339 and earlier, defaulted to =true=.) See also =:install-deps=.

#+BEGIN_QUOTE
  *Caution*

  The =:npm-deps= feature is in alpha status for optimized builds. When applying Closure optimizations, NPM dependencies are passed through Closure Compiler and not all NPM libraries contain Closure-compatible code.

  A reliable alternative can be found with [[file:xref/../../guides/webpack][ClojureScript with Webpack]].
#+END_QUOTE

#+BEGIN_SRC clojure
    :npm-deps {"lodash" "4.17.4"}
#+END_SRC

**** :optimizations
   :PROPERTIES:
   :CUSTOM_ID: optimizations
   :END:

The optimization level. May be =:none=, =:whitespace=, =:simple=, or =:advanced=. Only =:none= and =:simple= are supported for bootstrapped ClojureScript.

=:none= is the recommended setting for development, while =:advanced= is the recommended setting for production, unless something prevents it (incompatible external library, bug, etc.).

For a detailed explanation of the different optimization modes see [[https://developers.google.com/closure/compiler/docs/compilation_levels][Closure Compiler Compilation Levels]].

The [[https://github.com/dcodeIO/node.js-closure-compiler-externs][node.js externs]] may also serve as useful examples.

When the [[main][=:main= option]] is not used, =:none= requires manual code loading and hence a separate HTML from the other options.

Defaults to =:none=.

#+BEGIN_SRC clojure
    :optimizations :none
#+END_SRC

**** :output-to
   :PROPERTIES:
   :CUSTOM_ID: output-to
   :END:

The path to the JavaScript file that will be output.

#+BEGIN_SRC clojure
    :output-to "resources/public/js/main.js"
#+END_SRC

**** :output-dir
   :PROPERTIES:
   :CUSTOM_ID: output-dir
   :END:

Sets the output directory for temporary files used during compilation. Defaults to "out".

#+BEGIN_SRC clojure
    :output-dir "resources/public/js/out"
#+END_SRC

**** :preloads
   :PROPERTIES:
   :CUSTOM_ID: preloads
   :END:

Developing ClojureScript commonly requires development time only side effects such as enabling printing, logging, and connecting REPLs. =:preloads= permits loading such side effect boilerplate right after =cljs.core=. For example you can make a development namespace for enabling printing in browsers:

#+BEGIN_SRC clojure
    (ns foo.dev)

    (enable-console-print!)
#+END_SRC

Now you can configure your development build to load this side effect prior to your main namespace with the following compiler options:

#+BEGIN_SRC clojure
    {:preloads '[foo.dev]
     :main 'foo.core
     :output-dir "out"}
#+END_SRC

=:preloads= must be a sequence of symbols that map to existing namespaces discoverable on the classpath. Note the leading quote is not necessary when using Leiningen - values in =project.clj= are implicitly quoted.

#+BEGIN_QUOTE
  *Note*

  For =:optimizations :none=, a =:main= option must be specified for preloads to work.
#+END_QUOTE

**** :pretty-print
   :PROPERTIES:
   :CUSTOM_ID: pretty-print
   :END:

Determines whether the JavaScript output will be tabulated in a human-readable manner. Defaults to true.

#+BEGIN_SRC clojure
    :pretty-print false
#+END_SRC

**** :source-map
   :PROPERTIES:
   :CUSTOM_ID: source-map
   :END:

See [[file:source-maps][Source-maps]]. Under optimizations =:none= the valid values are =true= and =false=, with the default being =true=. Under all other optimization settings must specify a path to where the source map will be written.

Under =:none=:

#+BEGIN_SRC clojure
    :source-map false
#+END_SRC

Otherwise:

#+BEGIN_SRC clojure
    :source-map "path/to/source/map.js.map"
#+END_SRC

**** :stable-names
   :PROPERTIES:
   :CUSTOM_ID: stable-names
   :END:

Ensures reduced name churn between advanced builds thus proper vendorization if you're using =:modules=.

#+BEGIN_SRC clojure
    :stable-names true
#+END_SRC

**** :target
   :PROPERTIES:
   :CUSTOM_ID: target
   :END:

Valid options are =:nodejs=, =:webworker=, =:bundle=, and =:none=.

The default (no =:target= specified) implies browsers are being targeted.

Have a look [[file:xref/../../../guides/quick-start#running-clojurescript-on-nodejs][here]] for more information on how to run your code in nodejs.

=:webworker= produces a bootstrap script suitable for loading with Web Workers.

The =:bundle= target is to support dependencies in =node_modules=. The output generated by ClojureScript will need to be passed on to some other JavaScript tool (i.e. Webpack, Metro) that can handle the Node.js style =require= imports generated for these dependencies.

The =:none= target causes output to be generated that has no dependency on any particular execution environment.

#+BEGIN_SRC clojure
    :target :nodejs
#+END_SRC

**** :verbose
   :PROPERTIES:
   :CUSTOM_ID: verbose
   :END:

Emit details and measurements from compiler activity.

#+BEGIN_SRC clojure
    :verbose true
#+END_SRC

*** Less Common Options
  :PROPERTIES:
  :CUSTOM_ID: less-common-options
  :END:

**** :anon-fn-naming-policy
   :PROPERTIES:
   :CUSTOM_ID: anon-fn-naming-policy
   :END:

Strategies for how the Google Closure compiler does naming of anonymous functions that occur as r-values in assignments and variable declarations. Defaults to =:off=.

#+BEGIN_SRC clojure
    :anon-fn-naming-policy :unmapped
#+END_SRC

The following values are supported:

-  =:off= Don't give anonymous functions names.

-  =:unmapped= Generates names that are based on the left-hand side of the assignment. Runs after variable and property renaming, so that the generated names will be short and obfuscated.

-  =:mapped= Generates short unique names and provides a mapping from them back to a more meaningful name that's based on the left-hand side of the assignment.

**** :aot-cache
   :PROPERTIES:
   :CUSTOM_ID: aot-cache
   :END:

Defaults to =true= if ClojureScript is being used via =cljs.main=, and =false= otherwise or if ClojureScript is being used as a [[https://clojure.org/guides/deps_and_cli#_using_git_libraries][git dep]]. Controls whether the shared AOT cache is used for compiler artifacts produced from JARs.

#+BEGIN_SRC clojure
    :aot-cache true
#+END_SRC

**** :browser-repl
   :PROPERTIES:
   :CUSTOM_ID: browser-repl
   :END:

Automatically inject components required by the standard browser REPL. When launching the browser REPL this default to true.

#+BEGIN_SRC clojure
    :browser-repl true
#+END_SRC

**** :cache-analysis
   :PROPERTIES:
   :CUSTOM_ID: cache-analysis
   :END:

Experimental. Cache compiler analysis to disk. This enables faster cold build and REPL start up times.

For REPLs, defaults to =true=. Otherwise, defaults to =true= if and only if =:optimizations= is =:none=.

#+BEGIN_SRC clojure
    :cache-analysis true
#+END_SRC

**** :closure-defines
   :PROPERTIES:
   :CUSTOM_ID: closure-defines
   :END:

Set the values of Closure libraries' variables annotated with [[https://developers.google.com/closure/compiler/docs/js-for-compiler#tag-define][@define]] or with the =cljs.core/goog-define= helper macro. A common usage is setting =goog.DEBUG= to false:

#+BEGIN_SRC clojure
    :closure-defines {"goog.DEBUG" false}
#+END_SRC

You can also use symbols:

#+BEGIN_SRC clojure
    :closure-defines {my.cool-ns/some-def true}
#+END_SRC

Note when using Lein the quote is unnecessary due to implicit quoting.

#+BEGIN_QUOTE
  *Note*

  For =:optimizations :none=, a =:main= option must be specified for defines to work, and only =goog-define= defines are affected. =:closure-defines= currently does not have any effect with =:optimizations :whitespace=.
#+END_QUOTE

You can use the variables set in =:closure-defines= to eliminate parts of your code at compile time (DCE). However, to do so you must use =if= or =cond= in combination with an =identical?= comparison. Any other forms (such as =case= or =condp=) will work correctly at runtime, but the javascript output will contain the dead code branches.

For example, if you want to make a localized build of your application which only contains the translation messages relevant for the locale:

#+BEGIN_SRC clojure
    (def messages
      (cond
        (identical? js/goog.LOCALE "nl") i18n.nl/messages
        (identical? js/goog.LOCALE "fr") i18n.fr/messages
        :else i18n.en/messages))
#+END_SRC

**** :closure-extra-annotations
   :PROPERTIES:
   :CUSTOM_ID: closure-extra-annotations
   :END:

Define extra JSDoc annotations that a closure library might use so that they don't trigger compiler warnings.

#+BEGIN_SRC clojure
    :closure-extra-annotations #{"api"}
#+END_SRC

**** :closure-output-charset
   :PROPERTIES:
   :CUSTOM_ID: closure-output-charset
   :END:

Configure the output character set. May be:

-  =iso-8859-1=

-  =us-ascii=

-  =utf-16=

-  =utf-16be=

-  =utf-16le=

-  =utf-8=

Defaults to =utf-8=

#+BEGIN_SRC clojure
    :closure-output-charset "iso-8859-1"
#+END_SRC

**** :closure-warnings
   :PROPERTIES:
   :CUSTOM_ID: closure-warnings
   :END:

Configure warnings generated by the Closure compiler. A map from Closure warning to configuration value, only =:error=, =:warning= and =:off= are supported.

#+BEGIN_SRC clojure
    :closure-warnings {:externs-validation :off}
#+END_SRC

The following Closure warning options are exposed to ClojureScript:

#+BEGIN_SRC clojure
    :access-controls
    :ambiguous-function-decl
    :analyzer-checks
    :check-eventful-object-disposal
    :check-regexp
    :check-types
    :check-useless-code
    :check-variables
    :closure-dep-method-usage-checks
    :conformance-violations
    :const
    :constant-property
    :debugger-statement-present
    :deprecated
    :deprecated-annotations
    :duplicate-message
    :duplicate-vars
    :es3
    :es5-strict
    :externs-validation
    :extra-require
    :fileoverview-jsdoc
    :function-params
    :global-this
    :internet-explorer-checks
    :invalid-casts
    :j2cl-checks
    :jsdoc-missing-type
    :late-provide
    :lint-checks
    :message-descriptions
    :misplaced-msg-annotation
    :misplaced-type-annotation
    :missing-getcssname
    :missing-override
    :missing-polyfill
    :missing-properties
    :missing-provide
    :missing-require
    :missing-return
    :missing-sources-warnings
    :module-load
    :msg-conventions
    :non-standard-jsdoc
    :report-unknown-types
    :strict-missing-properties
    :strict-missing-require
    :strict-module-dep-check
    :strict-requires
    :suspicious-code
    :too-many-type-params
    :tweaks
    :type-invalidation
    :undefined-names
    :undefined-variables
    :underscore
    :unknown-defines
    :unnecessary-escape
    :unused-local-variable
    :unused-private-property
    :use-of-goog-base
    :violated-module-dep
    :visiblity
#+END_SRC

See the [[https://github.com/google/closure-compiler/wiki/Warnings][Closure Compiler Warning wiki]] for detailed descriptions.

**** :compiler-stats
   :PROPERTIES:
   :CUSTOM_ID: compiler-stats
   :END:

Report basic timing measurements on compiler activity.

Defaults to =false=.

#+BEGIN_SRC clojure
    :compiler-stats true
#+END_SRC

**** :deps-cmd
   :PROPERTIES:
   :CUSTOM_ID: deps-cmd
   :END:

Set the command to install =node_modules=. Only ="npm"= and ="yarn"= supported.

#+BEGIN_SRC clojure
    :deps-cmd "yarn"
#+END_SRC

**** :elide-asserts
   :PROPERTIES:
   :CUSTOM_ID: elide-asserts
   :END:

This flag will cause all =(assert= /x/ =)= calls to be removed during compilation, including implicit =assert=s associated with =:pre= and =:post= conditions. Useful for production. Default is always false even in advanced compilation. Does NOT specify =goog.asserts.ENABLE_ASSERTS=, which is different and used by the Closure library.

#+BEGIN_QUOTE
  *Note*

  Note that, with JVM ClojureScript, it is not possible to dynamically set =*assert*= to false at runtime; this compiler flag must explicitly be used to effect the elision. With self-hosted ClojureScript, on the other hand, setting =*assert*= will cause =asserts= to be elided as in Clojure.
#+END_QUOTE

**** :elide-strict
   :PROPERTIES:
   :CUSTOM_ID: elide-strict
   :END:

Whether to elide =use strict= statements in JavaScript output. Defaults to =true=.

#+BEGIN_SRC clojure
    :elide-strict false
#+END_SRC

**** :fingerprint
   :PROPERTIES:
   :CUSTOM_ID: fingerprint
   :END:

Defaults to =false=. Whether to enable fingerprinting, which will append a content SHA to output file names. An =manifest.edn= is generated to =:output-dir= for mapping fingerprinted file names. This is especially useful when using =:modules= and =:source-map= options, as the fingerprinted file names will be appropriately referenced.

#+BEGIN_SRC clojure
    :fingerprint true
#+END_SRC

**** :fn-invoke-direct
   :PROPERTIES:
   :CUSTOM_ID: fn-invoke-direct
   :END:

Requires =:static-fns true=. This option emits slightly different code that can speed up your code around 10-30%. Higher order function that don't implement the =IFn= protocol are normally called with =f.call(null, arg0, arg1 …​)=. With this option enabled the compiler calls them with a faster =f(arg0, arg1 …​= instead.

#+BEGIN_QUOTE
  *Caution*

  The =:fn-invoke-direct= feature is in alpha status. For some libraries such as Reagent, =:fn-invoke-direct= is known to generate incorrect code.
#+END_QUOTE

#+BEGIN_SRC clojure
    :fn-invoke-direct true
#+END_SRC

#+BEGIN_SRC clojure
    :elide-asserts true
#+END_SRC

**** :hashbang
   :PROPERTIES:
   :CUSTOM_ID: hashbang
   :END:

When using =:target :nodejs= the compiler will emit a shebang as the first line of the compiled source, making it executable. When your intention is to build a node.js module, instead of executable, use this option to remove the shebang.

#+BEGIN_SRC clojure
    :hashbang false
#+END_SRC

**** :infer-externs
   :PROPERTIES:
   :CUSTOM_ID: infer-externs
   :END:

Enables automatically generating externs for interop calls to JavaScript. Defaults to =false=. For more info see [[file:xref/../../guides/externs#externs-inference][Externs (Alpha)]]

#+BEGIN_SRC clojure
    :infer-externs true
#+END_SRC

**** :language-in and :language-out
   :PROPERTIES:
   :CUSTOM_ID: language-in-and-language-out
   :END:

Configure the input and output languages for the closure library. May be:

-  =:ecmascript-next= identical to =:es-next=

-  =:ecmascript-2017= identical to =:es-2017=

-  =:ecmascript-2016= identical to =:es-2016=

-  =:ecmascript-2015= identical to =:es-2015=, =:ecmascript6=, =:es6=, =:ecmascript6-strict=, =:es6-strict=

-  =:ecmascript6-typed= identical to =:es6-typed=

-  =:ecmascript5= identical to =:es5=

-  =:ecmascript5-strict= identical to =:es5-strict=

-  =:ecmascript3= identical to =:es3=

-  =:no-transpile=

=:language-in= defaults to =:ecmascript5= =:language-out= defaults to =:no-transpile=

#+BEGIN_SRC clojure
    :language-in  :ecmascript5
    :language-out :no-transpile
#+END_SRC

**** :libs
   :PROPERTIES:
   :CUSTOM_ID: libs
   :END:

Adds dependencies on external js libraries, i.e. Google Closure-compatible javascript files with correct =goog.provides()= and =goog.requires()= calls. Note that files in these directories will be watched and a rebuild will occur if they are modified.

Paths or filenames can be given. Relative paths are relative to the current working directory (usually project root).

Defaults to the empty vector =[]=

#+BEGIN_SRC clojure
    :libs ["closure/library/third_party/closure"
           "src/js"
           "src/org/example/example.js"]
#+END_SRC

**** :nodejs-rt
   :PROPERTIES:
   :CUSTOM_ID: nodejs-rt
   :END:

Flag to disable Node.js runtime support. Useful when not targeting Node.js but rather targeting JavaScript tools which understand Node.js style =require= conventions

#+BEGIN_SRC clojure
    :nodejs-rt false
#+END_SRC

**** :optimize-constants
   :PROPERTIES:
   :CUSTOM_ID: optimize-constants
   :END:

When set to =true=, constants, such as keywords and symbols, will only be created once and will be written to a separate file (=cljs/core/constants.js=). The compiler will emit a reference to the constant as defined in the constants table instead of creating a new object for it. This option is mainly intended to be used for a release build since it can increase performance due to decreased allocation. Defaults to =true= under =:advanced= optimizations otherwise to =false=.

#+BEGIN_SRC clojure
    :optimize-constants true
#+END_SRC

**** :output-wrapper
   :PROPERTIES:
   :CUSTOM_ID: output-wrapper
   :END:

Wrap the Javascript output to avoid clobbering globals. There are four possible value types:

1. Function - Takes one argument, the compiled javascript output. Should return some other valid javascript output. For the simplest case, just string concatenate the javascript output with something akin to #3 (the default wrapper)

2. String - Some =format= interpolation compatible string. For example, ="(function(){%s};)()"=. =format= receives the compiled javascript output as the second argument and nothing else.

3. Truthy - Wrap with the default =(function(){…​};)()=

4. Falsey - Don't wrap. This is the default.

#+BEGIN_SRC clojure
    ;; function
    (fn [js-output]
      (str "(function(){" js-output "};).call(window);"))

    ;; string
    "(function(){%s};).call(window);"

    ;; truthy
    true

    ;; falsey
    false
#+END_SRC

**** :package-json-resolution
   :PROPERTIES:
   :CUSTOM_ID: package-json-resolution
   :END:

Configures which =package.json= entries (e.g. ="browser"=, ="module"= or ="main"=) are used in which order when resolving dependencies on (and between) NPM packages.

Defaults to

-  =:nodejs= (=["main"]=) if the =:target= is =:nodejs=

-  =:webpack= (=["browser", "module", "main"]=) else

Can also take a custom vector of entries such as =["browser", "main"]=.

**** :parallel-build
   :PROPERTIES:
   :CUSTOM_ID: parallel-build
   :END:

When set to =true=, compile source in parallel, utilizing multiple cores.

#+BEGIN_SRC clojure
    :parallel-build true
#+END_SRC

**** :preamble
   :PROPERTIES:
   :CUSTOM_ID: preamble
   :END:

Prepends the contents of the given files to each output file. Files should reside on the classpath. Only valid with optimizations other than =:none=.

Defaults to the empty vector =[]=

#+BEGIN_SRC clojure
    :preamble ["license.js"]
#+END_SRC

**** :print-input-delimiter
   :PROPERTIES:
   :CUSTOM_ID: print-input-delimiter
   :END:

Determines whether comments will be output in the JavaScript that can be used to determine the original source of the compiled code.

Defaults to false.

#+BEGIN_SRC clojure
    :print-input-delimiter false
#+END_SRC

**** :process-shim
   :PROPERTIES:
   :CUSTOM_ID: process-shim
   :END:

Defaults to

-  =false= if =:target= is =:nodejs=

-  =true= else

Automatically provide a shim for Node.js =process.env= containing a single Google Closure define, =NODE_ENV= with ="development"= as the default value. In production =NODE_ENV= will be set to ="production"=. If set to =false= all of the stated behavior is disabled.

**** :pseudo-names
   :PROPERTIES:
   :CUSTOM_ID: pseudo-names
   :END:

With =:advanced= mode optimizations, determines whether readable names are emitted. This can be useful when debugging issues in the optimized JavaScript and can aid in finding missing [[externs][externs]]. Defaults to false.

#+BEGIN_SRC clojure
    :pseudo-names true
#+END_SRC

**** :recompile-dependents
   :PROPERTIES:
   :CUSTOM_ID: recompile-dependents
   :END:

For correctness the ClojureScript compiler now always recompiles dependent namespaces when a parent namespace changes. This prevents corrupted builds and swallowed warnings. However this can impact compile times depending on the structure of the application. This option defaults to =true=.

#+BEGIN_SRC clojure
    :recompile-dependents false
#+END_SRC

**** :rename-prefix
   :PROPERTIES:
   :CUSTOM_ID: rename-prefix
   :END:

Specifies a prefix that will be prepended to all variables. Can be used when [[file:xref/../../guides/code-splitting][Code Splitting]] to prevent interference with other code in JavaScript's global scope.

#+BEGIN_SRC clojure
    :rename-prefix "prefix"
#+END_SRC

**** :rewrite-polyfills
   :PROPERTIES:
   :CUSTOM_ID: rewrite-polyfills
   :END:

If set to true, the google closure compiler will add polyfills (for example when you use native javascript =Promise=). *This requires =:language-in= to be set to =:es6= or higher or it will silently be ignored!*

#+BEGIN_SRC clojure
    :language-in  :es6
    :rewrite-polyfills true
#+END_SRC

**** :source-map-asset-path
   :PROPERTIES:
   :CUSTOM_ID: source-map-asset-path
   :END:

Provides fine grained control over the =sourceMappingURL= comment that is appended to generated JavaScript files when source mapping is enabled.

**** :source-map-path
   :PROPERTIES:
   :CUSTOM_ID: source-map-path
   :END:

Set the path to source files references in source maps to avoid further web server configuration.

#+BEGIN_SRC clojure
    :source-map-path "public/js"
#+END_SRC

This option affects the =sources= entry of the emitted source map V3 JSON file.

#+BEGIN_SRC clojure
    :source-map-asset-path "http://foo.com/public/js/out"
#+END_SRC

**** :source-map-timestamp
   :PROPERTIES:
   :CUSTOM_ID: source-map-timestamp
   :END:

Add cache busting timestamps to source map urls. This is helpful for keeping source maps up to date when live reloading code.

#+BEGIN_SRC clojure
    :source-map-timestamp true
#+END_SRC

**** :spec-skip-macros
   :PROPERTIES:
   :CUSTOM_ID: spec-skip-macros
   :END:

Whether to disable spec macro checking. Defaults to =false=.

#+BEGIN_SRC clojure
    :spec-skip-macros true
#+END_SRC

**** :static-fns
   :PROPERTIES:
   :CUSTOM_ID: static-fns
   :END:

Employs static dispatch to specific function arities in emitted JavaScript, as opposed to making use of the =call= construct. Defaults to false except under advanced optimizations. Useful to have set to false at REPL development to facilitate function redefinition, and useful to set to true for release for performance.

This setting does not apply to the standard library, which is always compiled with =:static-fns= implicitly set to true.

#+BEGIN_SRC clojure
    :static-fns true
#+END_SRC

#+BEGIN_QUOTE
  *Note*

  To enable static dispatch for calls to declared functions, supply =:arglists= meta. For example, if =(declare foo)= preceeds =(foo 1 2)=, dynamic dispatch will be employed. If instead =(declare ^{:arglists '([x y])} foo)= preceeds =(foo 1 2)=, static dispatch will be employed if =:static-fns= is enabled.
#+END_QUOTE

**** :target-fn
   :PROPERTIES:
   :CUSTOM_ID: target-fn
   :END:

Set an arbitrary Clojure function to generate the development main entry point JavaScript file. Must be a symbol representing a Clojure function that exists in a namespace on the classpath. Only used under =:optimization :none=.

#+BEGIN_SRC clojure
    :target-fn 'some.custom.dev-bootstrap
#+END_SRC

**** :warnings
   :PROPERTIES:
   :CUSTOM_ID: warnings
   :END:

This flag will turn on/off compiler warnings for references to undeclared vars, wrong function call arities, etc. Can be a boolean for enabling/disabling common warnings, or a map of specific warning keys with associated booleans. Defaults to true.

#+BEGIN_SRC clojure
    :warnings true
    ;; OR
    :warnings {:fn-deprecated false} ;; suppress this warning
#+END_SRC

The following warnings are supported:

-  =:declared-arglists-mismatch=, declared =:arglists= mismatch defined

-  =:dynamic=, dynamic binding of non-dynamic var

-  =:extend-type-invalid-method-shape=, method arities must be grouped together

-  =:extending-base-js-type=, JavaScript base type extension

-  =:fn-arity=, invalid invoke arity

-  =:fn-deprecated=, deprecated function usage

-  =:fn-var=, var previously bound to fn changed to different type

-  =:infer-warning=, warnings related to externs inference

-  =:invalid-arithmetic=, invalid arithmetic

-  =:invalid-array-access=, invalid use of =aget= or =aset=

-  =:invalid-protocol-symbol=, invalid protocol symbol

-  =:invoke-ctor=, type constructor invoked as function

-  =:js-shadowed-by-local=, name shadowed by a local

-  =:multiple-variadic-overloads=, multiple variadic arities

-  =:munged-namespace=, namespace name contains a reserved JavaScript keyword

-  =:ns-var-clash=, namespace clashes with var

-  =:overload-arity=, duplicate arities

-  =:preamble-missing=, missing preamble

-  =:private-var-access=, private var access from another namespace

-  =:protocol-deprecated=, deprecated protocol usage

-  =:protocol-duped-method=, duplicate protocol method implementation

-  =:protocol-impl-recur-with-target=, target passed in recur to protocol method head

-  =:protocol-impl-with-variadic-method=, protocol impl employs variadic signature

-  =:protocol-invalid-method=, protocol method does not match declaration

-  =:protocol-multiple-impls=, protocol implemented multiple times

-  =:protocol-with-overwriting-method=, protocol method overwrites other protocol method

-  =:protocol-with-variadic-method=, protocol declares variadic signature

-  =:redef=, var redefinition

-  =:single-segment-namespace=, single segment namespace

-  =:variadic-max-arity=, arity greater than variadic arity

-  =:undeclared-ns=, var references non-existent namespace

-  =:undeclared-ns-form=, namespace reference in ns form that does not exist

-  =:undeclared-protocol-symbol=, undeclared protocol referred

-  =:undeclared-var=, undeclared var

-  =:unprovided=, required namespace not provided

-  =:unsupported-js-module-type=, unsupported JavaScript module type

-  =:unsupported-preprocess-value=, unsupported foreign lib preprocess value

**** :watch-fn
   :PROPERTIES:
   :CUSTOM_ID: watch-fn
   :END:

Is a function that will be called after a successful build.

*Only available for =cljs.build.api/watch=*

#+BEGIN_SRC clojure
    :watch-fn (fn [] (println "Updated build"))
#+END_SRC

** Dependencies
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/dependencies.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/dependencies
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/dependencies
:END:

*This guide requires ClojureScript 1.10.238 or later and assumes familiarity with the [[file:xref/../../guides/quick-start][Quick Start]]*.

Every non-trivial ClojureScript application will eventually need to consume code created by others. ClojureScript developers can of course take advantage of code authored using ClojureScript. However, ClojureScript developers can also consume arbitrary JavaScript code, whether or not it was written with ClojureScript in mind.

This guide assumes you've worked through the [[file:xref/../../../guides/quick-start][Quick Start]] guide, and are equipped with the dependencies introduced there.

*** Consuming JavaScript Code
  :PROPERTIES:
  :CUSTOM_ID: consuming-javascript-code
  :END:

While you can consume any JavaScript code, the optimal mechanism for including that code is not always the same. The following sections explore the various options for utilizing third party JavaScript code.

**** Closure Library
   :PROPERTIES:
   :CUSTOM_ID: closure-library
   :END:

The easiest JavaScript code to consume is that of Google's [[https://github.com/google/closure-library][Closure Library]] (GCL), which is automatically bundled with ClojureScript. GCL is a massive collection of JavaScript code organized into namespaces much like ClojureScript code itself. Thus, you can require a namespace from GCL in the same fashion as a ClojureScript namespace. The following example demonstrates basic usage:

#+BEGIN_SRC clojure
    (ns hello-world.core
      (:require [goog.dom :as dom]
                [goog.dom.classes :as classes]
                [goog.events :as events])
      (:import [goog Timer]))

    (let [element (dom/createDom "div" "some-class" "Hello, World!")]
      (classes/enable element "another-class" true)
      (-> (dom/getDocument)
        .-body
        (dom/appendChild element))
      (doto (Timer. 1000)
        (events/listen "tick" #(.warn js/console "still here!"))
        (.start)))
#+END_SRC

See [[http://clojurescriptmadeeasy.com/blog/when-do-i-use-require-vs-import.html][this blog post]] on the difference between =:import= and =:require= for closure libs.

The gist of it is: use =:import= for Closure classes and enums, and use =:require= for everything else.

**** External JavaScript Libraries
   :PROPERTIES:
   :CUSTOM_ID: external-javascript-libraries
   :END:

In cases where GCL doesn't contain the functionality you want, or you'd otherwise like to take advantage of a third party JavaScript library, you can use the code directly.

Let's consider the case where we want to use a fancy JavaScript library called yayQuery. To utilize a JavaScript library, simply reference the JavaScript as normal. Whether the file is loaded externally or inline makes no difference, both will be applied in the same fashion at runtime. To make things simple, we'll define this library inline:

#+BEGIN_EXAMPLE
    <script type="text/javascript">
        yayQuery = function() {
            var yay = {};
            yay.sayHello = function(message) {
                console.log(message);
            }
            yay.getMessage = function() {
                return 'Hello, world!';
            }
           return yay;
        };
    </script>
#+END_EXAMPLE

To use this library from ClojureScript, we can simply refer to the symbols directly. If you build the following code using ={:optimizations :none}=, everything will work fine and you will see a message in your JavaScript console.

#+BEGIN_SRC clojure
    (ns hello-world.core)

    (let [yay (js/yayQuery)]
      (.sayHello yay (.getMessage yay)))
#+END_SRC

While this works fine with unoptimized code, it will fail when we use advanced optimizations. Try compiling the same code with ={:optimizations :advanced}= and reload your browser. You will receive an error message similar to the following (it may not be exactly as below):

#+BEGIN_EXAMPLE
    Uncaught TypeError: sa.B is not a function
#+END_EXAMPLE

Why did this happen? When using advanced optimizations, the Google Closure Compiler will rename symbols. In most cases, this is not a problem, as all instances of the same symbol will be renamed consistently. However, in this case the external symbol (the name in the JavaScript code) is /separate/ from our compilation unit, so the names no longer match. Fortunately, we have options for resolving this issue without losing all of the benefits of advanced compilation.

***** Using Externs
    :PROPERTIES:
    :CUSTOM_ID: using-externs
    :END:

To fix compilation without modifying your source code at all, you can add an externs file. An externs file defines the symbol names in a given library, and is used by Google Closure Compiler to determine which symbols must not be renamed. Here's a minimal externs file for our yayQuery library:

#+BEGIN_EXAMPLE
    var yayQuery = function() {}
    yayQuery.sayHello = function(message) {}
    yayQuery.getMessage = function() {}
#+END_EXAMPLE

Assuming this file is named as =yayquery-externs.js=, you can reference it as follows in your =build.edn= file:

#+BEGIN_SRC clojure
    {:output-to "out/main.js"
     :externs ["yayquery-externs.js"]
     :optimizations :advanced})
#+END_SRC

It is important to understand that all paths referenced in the =:externs= vector /must be on the classpath/. For example you might have placed the above externs file under a =resources= directory. Then when using the standalone ClojureScript JAR you must launch your build script with the following:

#+BEGIN_SRC sh
    clj -M -m cljs.main -co build.edn -c
#+END_SRC

Recompile with the externs file referenced, and your code should work again without any modifications. Note that for many popular JavaScript libraries, you may be able to find externs files which have already been created by the library authors or the broader community. These files are useful for any developer taking advantage of Google Closure Compiler, even those not using ClojureScript.

***** Using String Names
    :PROPERTIES:
    :CUSTOM_ID: using-string-names
    :END:

For simple cases where you only reference a small number of JavaScript symbols, you can also change your source code to reference code by string name. Google Closure Compiler will never rename strings, so this style will work without needing to create an externs file. The code below will work in advanced compilation mode even without externs:

#+BEGIN_SRC clojure
    (let [yay ((goog.object.get js/window "yayQuery"))]
      ((goog.object.get yay "sayHello") ((goog.object.get yay "getMessage"))))
#+END_SRC

Careful readers may notice above that we are referencing =js/window= just as we did =js/yayQuery= in the failing example. It works in this case because Google Closure Compiler ships out of the box with a number of externs for browser APIs. These are enabled by default.

**** Bundling JavaScript Code
   :PROPERTIES:
   :CUSTOM_ID: bundling-javascript-code
   :END:

To maximize efficiency of content delivery, you can bundle JavaScript code along with your compiled ClojureScript code.

***** Google Closure Compiler Compatible Code
    :PROPERTIES:
    :CUSTOM_ID: google-closure-compiler-compatible-code
    :END:

If your external JavaScript code has been written to be compatible with Google Closure Compiler, and exposes its namespaces using =goog.provide=, the most efficient way to include it is to bundle it using =:libs=. This bundling mechanism takes full advantage of advanced mode compilation, renaming symbols in the external JavaScript library and eliminating dead code. Let's adapt our yayQuery library from previous examples, as below:

#+BEGIN_EXAMPLE
    goog.provide('yq');

    yq.debugMessage = 'Dead Code';

    yq.yayQuery = function() {
        var yay = {};
        yay.sayHello = function(message) {
            console.log(message);
        };
        yay.getMessage = function() {
            return 'Hello, world!';
        };
        return yay;
    };
#+END_EXAMPLE

This code is mostly identical to the previous inline version, but is now packaged within a "namespace" exposed using =goog.provide=. The library can be referenced easily in ClojureScript:

#+BEGIN_SRC clojure
    (ns hello-world.core
      (:require [yq]))

    (let [yay (yq/yayQuery)]
      (.sayHello yay (.getMessage yay)))
#+END_SRC

To build the bundled output, use the following command:

#+BEGIN_SRC clojure
    clj -M -m cljs.main -co build.edn -O advanced -c
#+END_SRC

Because this code is compatible with advanced compilation, there is no need to create externs. If you look at the compiled output, you'll see that the functions have been renamed and the unreferenced =debugMessage= has been completely eliminated by Google Closure Compiler.

While an extremely efficient way to bundle external JavaScript, most popular libraries are not compatible with this approach.

***** Bundling "Foreign" JavaScript Code
    :PROPERTIES:
    :CUSTOM_ID: bundling-foreign-javascript-code
    :END:

If the code you wish to bundle has not been authored with Google Closure Compiler compatibility in mind, you can include it as a foreign library. Foreign libraries are included in your final output, but are not passed through advanced compilation. Let's consider a version of yayQuery which does not include a =goog.provide=:

#+BEGIN_EXAMPLE
    yayQuery = function() {
        var yay = {};
        yay.sayHello = function(message) {
            console.log(message);
        };
        yay.getMessage = function() {
            return 'Hello, world!';
        };
        return yay;
    };
#+END_EXAMPLE

Using code in foreign libraries from ClojureScript is very similar to using code that's been included directly in the page via a =<script>= tag, with one key difference:

#+BEGIN_SRC clojure
    (ns hello-world.core
      (:require [yq]))

    (let [yay (js/yayQuery)]
      (.sayHello yay (.getMessage yay)))
#+END_SRC

Notice the presence of =:require= in the =ns= declaration. This references a "namespace" called =yq=, but there is no corresponding =goog.provide= in the yayQuery file. In the case of foreign libraries, the "namespace" is provided in the build configuration. As long as the name in the =:provides= key matches what you =:require= and is unique across referenced libraries, you can name it anything you please:

#+BEGIN_SRC clojure
    {:output-to "out/main.js"
     :externs ["yayquery-externs.js"]
     :foreign-libs [{:file "yayquery.js"
                     :provides ["yq"]}]}
#+END_SRC

Note that we have re-introduced our externs file here. Though the foreign library is bundled, it must otherwise be referenced exactly as if the script had been included externally.

**** CLJSJS
   :PROPERTIES:
   :CUSTOM_ID: cljsjs
   :END:

The previous sections have discussed the various ways of integrating with any external JavaScript code. Finding the best way to integrate a library can be tricky, especially if you have to procure externs. Fortunately, for many of the most common JavaScript libraries, there is an easier way. The [[http://cljsjs.github.io/][CLJSJS]] project automatically packages up external JavaScript libraries in a way that's directly supported by the ClojureScript compiler. It will automatically package the best version of a library in a given context (including minified libraries when using advanced optimizations, for example), and automatically includes the appropriate externs.

Let's say we've outgrown our beloved yayQuery library, and want to use jQuery instead. This is one of the many popular libraries which has been pre-packaged. We can fetch a copy as below:

#+BEGIN_SRC sh
    curl -O https://clojars.org/repo/cljsjs/jquery/1.9.0-0/jquery-1.9.0-0.jar
#+END_SRC

If you take a peek inside the downloaded JAR file (=unzip jquery-1.9.0-0.jar deps.cljs=), you'll see the contents of the bundled =deps.cljs= file:

#+BEGIN_SRC clojure
    {:foreign-libs
     [{:file "cljsjs/development/jquery.inc.js",
       :file-min "cljsjs/production/jquery.min.inc.js",
       :provides ["cljsjs.jquery"]}],
     :externs ["cljsjs/common/jquery.ext.js"]}
#+END_SRC

If you followed along with the previous sections, this should all be quite clear at this point. The =:provides= data tells us all we need to reference this code:

#+BEGIN_SRC clojure
    (ns hello-world.core
      (:require [cljsjs.jquery]))

    (.text (js/$ "body") "Hello, World!")
#+END_SRC

The build file in this case is incredibly simple, as the library reference is entirely contained in the JAR which we'll reference when we invoke the script:

#+BEGIN_SRC clojure
    {:output-to "out/main.js"}
#+END_SRC

Compile the code as below (note the addition of the JAR in our class path), and you should see the message display when you load your browser:

#+BEGIN_SRC sh
    clj -M -m cljs.main -co build.edn -O advanced -c
#+END_SRC

***** Replacing a (transitive) CLJSJS dependency with another build of the library
    :PROPERTIES:
    :CUSTOM_ID: replacing-a-transitive-cljsjs-dependency-with-another-build-of-the-library
    :END:

Sometimes you have a transitive dependency on a CLJSJS library but want to include the dependency manually or use a custom build of it. In that case you need to do two things: (1) exclude the dependency with =:exclusions= and (2) create an empty namespace with the cljsjs name so that the build does not break.

For example =om= depends on =cljsjs/react=. To include a custom build you need:

#+BEGIN_SRC clojure
    ;; project.cljs
    ;; ...
    :dependencies [[org.omcljs/om "0.9.0" :exclusions [cljsjs/react]] ;; ...
#+END_SRC

#+BEGIN_SRC clojure
    ;; src/cljsjs/react.cljs
    (ns cljsjs.react)
#+END_SRC

#+BEGIN_EXAMPLE
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js"></script>
    <script src="resources/public/js/compiled/your_cljs_code.js" type="text/javascript"></script>
#+END_EXAMPLE

*** Consuming ClojureScript Code
  :PROPERTIES:
  :CUSTOM_ID: consuming-clojurescript-code
  :END:

The ability to consume any JavaScript library makes ClojureScript an incredibly flexible and powerful language for writing JavaScript applications. Of course, ClojureScript developers can also easily include ClojureScript libraries authored by others.

**** Using Libraries Directly
   :PROPERTIES:
   :CUSTOM_ID: using-libraries-directly
   :END:

Let's make use of [[https://github.com/Prismatic/schema][Schema]], a ClojureScript library which enables us to validate complex data types. First, we need to procure a copy of the library:

#+BEGIN_SRC sh
    curl -O https://clojars.org/repo/prismatic/schema/0.4.0/schema-0.4.0.jar
#+END_SRC

As with CLJSJS libraries, everything is packaged in a JAR file which we will reference in our class path when compiling. Unlike CLJSJS libraries, though, ClojureScript library JARs contain no externs or =deps.cljs= mappings.

Using the library is simple. Note that ClojureScript code and Clojure macros are packaged in the same library:

#+BEGIN_SRC clojure
    (ns hello-world.core
      (:require [schema.core :as s :include-macros true]))

    (def Data {:a {:b s/Str :c s/Int}})

    (s/validate Data {:a {:b "Hello" :c "World"}})
#+END_SRC

Our build script is even simpler:

#+BEGIN_SRC clojure
    {:output-to "out/main.js"}
#+END_SRC

Now, we can run the build. Simply reference the JAR as below:

#+BEGIN_SRC sh
    clj -M -m cljs.main -co build.edn -c
#+END_SRC

Load up your browser, and you'll see a helpful validation error from Schema in your JavaScript console. Change the =:c= key to an integer value and rebuild if you'd like to see this error go away.

** Documentation
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/documentation.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/documentation
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-30
:CUSTOM_ID: content/reference/documentation
:END:
*** API Documentation
  :PROPERTIES:
  :CUSTOM_ID: _api_documentation
  :END:

-  [[http://cljs.info/cheatsheet/][ClojureScript Cheatsheet]]

-  [[http://cljs.github.io/api/][ClojureScript Syntax and API Reference]]

-  [[file:javascript-api][JavaScript API]]

*** Reference Documentation
  :PROPERTIES:
  :CUSTOM_ID: _reference_documentation
  :END:

-  [[file:compiler-options][Compiler Options]]

-  [[file:repl-options][REPL Options]]

-  [[file:dependencies][Dependencies]]

-  [[file:packaging-foreign-deps][Packaging Foreign Dependencies]]

-  [[file:repl-and-main][The REPL and main entry points]]

-  [[file:repl][REPL and Evaluation Environments]]

-  [[file:advanced-compilation][Advanced Compilation]]

-  [[file:bootstrapping][Bootstrapping the Compiler]]

-  [[file:google-closure-library][Google Closure Library]]

-  [[file:source-maps][Source Maps]]

-  [[file:javascript-module-support][JavaScript Module Support (Alpha)]]

-  [[file:javascript-library-preprocessing][JavaScript Library Preprocessing]]

-  [[file:javascript-api][JS API]]

** Google Closure Library
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/google-closure-library.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/google-closure-library
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/google-closure-library
:END:

ClojureScript projects always auto-include the [[https://developers.google.com/closure/library/][Google Closure Library]], a massive library built and used by Google on many of their products (Gmail, Docs, etc). It has low-level utilities for DOM manipulation, server communication, animation, data structures, unit testing, rich-text editing, and UI widgets/controls.

-  [[http://google.github.io/closure-library/api/][Google Closure Library API Reference]]

*** Try the wrapper libraries first!
  :PROPERTIES:
  :CUSTOM_ID: try-the-wrapper-libraries-first
  :END:

You may first want to consider the following ClojureScript libraries which wrap some functionality from Google Closure Library. Their source code also serves as good examples of how to use Closure directly.

| ClojureScript wrapper                                       | Closure Libraries                                                                                                                                                                                                                         |
|-------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [[https://github.com/andrewmcveigh/cljs-time][cljs-time]]   | [[https://google.github.io/closure-library/api/goog.date.html][goog.date]]                                                                                                                                                                |
| [[https://github.com/r0man/cljs-http][cljs-http]]           | [[https://google.github.io/closure-library/api/goog.net.XhrIo.html][goog.net.XhrIo]], [[https://google.github.io/closure-library/api/goog.Uri.html][goog.uri]]                                                                            |
| [[https://github.com/JulianBirch/cljs-ajax][cljs-ajax]]     | [[http://google.github.io/closure-library/api/goog.net.XhrIo.html][goog.net.XhrIo]], [[http://google.github.io/closure-library/api/goog.Uri.html][goog.uri]], [[http://google.github.io/closure-library/api/goog.json.html][goog.json]]   |
| [[https://funcool.github.io/cuerdas/latest/][cuerdas]]      | [[https://google.github.io/closure-library/api/goog.string.html][goog.string]]                                                                                                                                                            |
| [[https://github.com/lambdaisland/glogi][glögi]]            | [[https://google.github.io/closure-library/api/goog.log.html][goog.log]]                                                                                                                                                                  |

/* included in ClojureScript's core library/

*** Using Google Closure directly
  :PROPERTIES:
  :CUSTOM_ID: using-google-closure-directly
  :END:

Some helpful blog posts:

-  [[http://clojurescriptmadeeasy.com/blog/do-not-forget-about-google-closure.html][ClojureScript Made Easy - Don't forget about Google Closure]]

-  [[http://clojurescriptmadeeasy.com/blog/when-do-i-use-require-vs-import.html][ClojureScript Made Easy - When do I use :require vs :import?]]

To use Google Closure in your ClojureScript code, the rule is to use:

-  =:import= for Closure classes (which are also namespaces, like =goog.Uri=) and enums

-  =:require= for everything else

*** Import a class
  :PROPERTIES:
  :CUSTOM_ID: import-a-class
  :END:

This is only for when you would like to refer directly to a class which is /also/ a namespace, otherwise just use =:require= in your =ns= form or use the =require= REPL helper.

#+BEGIN_SRC clojure
    (ns example.core
      (:import goog.Uri))
#+END_SRC

#+BEGIN_SRC clojure
    ;; in REPL
    (import 'goog.Uri)
    (Uri. "http://example.com")
    ;;=> #<http://example.com>
#+END_SRC

*** Import an enum
  :PROPERTIES:
  :CUSTOM_ID: import-an-enum
  :END:

#+BEGIN_SRC clojure
    (ns example.core
      (:import [goog.events EventType]))
#+END_SRC

#+BEGIN_SRC clojure
    ;; in REPL
    (import '[goog.events EventType])
    EventType.CLICK
    ;;=> "click"
#+END_SRC

*** Requiring a function
  :PROPERTIES:
  :CUSTOM_ID: requiring-a-function
  :END:

#+BEGIN_SRC clojure
    (ns example.core
      (:require [goog.math :as math]))
#+END_SRC

#+BEGIN_SRC clojure
    ;; in REPL
    (require '[goog.math :as math])
    (math/clamp -1 0 5)
    ;;=> 0
#+END_SRC

#+BEGIN_QUOTE
  *Warning*

  Sometimes symbols are *not auto-included* when requiring their parent namespace. This happens when those symbols are in their own file and require specific inclusion
#+END_QUOTE

#+BEGIN_SRC clojure
    (ns example.core
      (:require
        [goog.string :as gstring]
        goog.string.format))
#+END_SRC

#+BEGIN_SRC clojure
    ;; in REPL
    (require '[goog.string :as gstring])
    (require 'goog.string.format)

    (goog.string.format "%05d" 123)
    ;;=> 00123

    ;; or use the alias
    (gstring/format "%05d" 123)
    ;;=> 00123
#+END_SRC

*** Searching for Examples
  :PROPERTIES:
  :CUSTOM_ID: searching-for-examples
  :END:

You can look for =cljs= files on Github that use =goog.dom= with the following search:

#+BEGIN_EXAMPLE
    Search GitHub: "goog.dom extension:cljs"
#+END_EXAMPLE

Or you can search Google Closure Library on Github for keywords pertaining to a function it might have:

#+BEGIN_EXAMPLE
    Search Closure Library on Github: "hours minutes"
#+END_EXAMPLE

** JavaScript API
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/javascript-api.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/javascript-api
:CLOJURESCRIPT_SITE_AUTHOR: Mike Fikes
:CLOJURESCRIPT_SITE_DATE: 2017-12-06
:CUSTOM_ID: content/reference/javascript-api
:END:

The implementation of ClojureScript collections define several JavaScript functions that can be called from ClojureScript using JavaScript interop or directly from JavaScript. This page describes those functions which are officially stable and publicly-consumable.

*** indexOf
  :PROPERTIES:
  :CUSTOM_ID: indexOf
  :END:

**** Syntax
   :PROPERTIES:
   :CUSTOM_ID: _syntax
   :END:

#+BEGIN_SRC clojure
    (.indexOf coll search-value)
    (.indexOf coll search-value from-index)
#+END_SRC

**** Parameters
   :PROPERTIES:
   :CUSTOM_ID: _parameters
   :END:

=coll= - a collection satisfying the =sequential?= predicate.

=search-value= - the value to search for.

=from-index= - an optional starting index.

**** Description
   :PROPERTIES:
   :CUSTOM_ID: _description
   :END:

Gets the index of a value in a sequential collection, or =-1= if not found. By default, search proceeds from the beginning, unless an optional starting index is supplied.

**** Examples
   :PROPERTIES:
   :CUSTOM_ID: _examples
   :END:

#+BEGIN_SRC clojure
    (.indexOf [1 2 3 5 7] 5) ;; 3
    (.indexOf [1 2 3 5 7] 4) ;; -1
    (.indexOf [1 2 3 5 2] 2 3) ;; 4
#+END_SRC

*** lastIndexOf
  :PROPERTIES:
  :CUSTOM_ID: lastIndexOf
  :END:

**** Syntax
   :PROPERTIES:
   :CUSTOM_ID: _syntax_2
   :END:

#+BEGIN_SRC clojure
    (.lastIndexOf coll search-value)
    (.lastIndexOf coll search-value from-index)
#+END_SRC

**** Parameters
   :PROPERTIES:
   :CUSTOM_ID: _parameters_2
   :END:

=coll= - a collection satisfying the =sequential?= predicate.

=search-value= - the value to search for.

=from-index= - an optional starting index.

**** Description
   :PROPERTIES:
   :CUSTOM_ID: _description_2
   :END:

Gets the last index of a value in a sequential collection, or =-1= if not found. By default, search proceeds from the end, unless an optional starting index is supplied.

**** Examples
   :PROPERTIES:
   :CUSTOM_ID: _examples_2
   :END:

#+BEGIN_SRC clojure
    (.lastIndexOf [1 2 3 5 2 7] 2) ;; 4
    (.lastIndexOf [1 2 3 5 2 7] 4) ;; -1
    (.lastIndexOf [1 2 3 5 2 7] 2 3) ;; 1
#+END_SRC

** JavaScript Library Preprocessing
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/javascript-library-preprocessing.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/javascript-library-preprocessing
:CLOJURESCRIPT_SITE_AUTHOR: Maria Geller
:CLOJURESCRIPT_SITE_DATE: 2016-10-03
:CUSTOM_ID: content/reference/javascript-library-preprocessing
:END:

ClojureScript allows you to add a custom transformation step for JavaScript libraries. This means that you are able to include JavaScript libraries in your project which are written in a dialect or make use of a JavaScript syntax extension. In order to effect the desired code transformation a =defmethod= which satisfies =cljs.closure/js-transforms= must be provided to the =:preprocess= option of the foreign library. For example, you can transform a JavaScript library using JSX into regular React function calls as follows:

#+BEGIN_SRC clojure
    (require '[cljs.build.api :as b]
             '[clojure.java.io :as io])
    (refer 'cljs.closure :only '[js-transforms])
    (import 'javax.script.ScriptEngineManager)

    (defmethod js-transforms :jsx [ijs opts]
      (let [engine (doto (.getEngineByName (ScriptEngineManager.) "nashorn")
                     (.eval (io/reader (io/file "babel.min.js")))
                     (.put "input" (:source ijs)))]
        (assoc ijs :source
          (.eval engine (str "Babel.transform(input, {presets: ['react']}).code")))))

    (b/build "src"
      {:main 'my-project.core
       :output-to "out/my_project.js"
       :output-dir "out"
       :foreign-libs [{:file "libs/example.js"
                       :provides ["my.example"]
                       :preprocess :jsx}]})
#+END_SRC

The example above uses Babel to transform the JavaScript code by loading a minified version of [[https://github.com/Daniel15/babel-standalone][babel-standalone]] using Nashorn. The =js-transforms= method gets and returns an object which satisfies the =IJavaScript= protocol. The object can be a plain map or a record with keys like =:url=, =:provides=, =:requires= and =:source=. The second argument which is passed to =js-transforms= is a map with the compiler options. The JavaScript preprocessing happens before [[file:xref/../javascript-module-support][module conversion]], however, both steps are independent of each other and can be used in disjunction.

** JavaScript Module Support (Alpha)
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/javascript-module-support.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/javascript-module-support
:CLOJURESCRIPT_SITE_AUTHOR: Maria Geller
:CLOJURESCRIPT_SITE_DATE: 2016-09-24
:CUSTOM_ID: content/reference/javascript-module-support
:END:

This page explains how to include a JavaScript module into a ClojureScript project. Please keep in mind that the functionalities described in this guide are still considered to be in alpha.

*** Motivation
  :PROPERTIES:
  :CUSTOM_ID: motivation
  :END:

In addition to code optimization and dependency management, the Google Closure compiler can also convert common JavaScript modules into Google Closure modules. Having a Google Closure module instead of a JavaScript module has the following advantages:

-  Google Closure modules are included into source code optimizations

-  no need to specify externs

*** Including a JavaScript module
  :PROPERTIES:
  :CUSTOM_ID: including-a-javascript-module
  :END:

Following, we will see how we can include the following simple CommonJS module into a ClojureScript project.

#+BEGIN_EXAMPLE
    // calculator.js
    var calculator = {
        add: function (a, b) {
            return a + b;
        },
        subtract: function (a, b) {
            return a - b;
        }
    };

    module.exports = calculator;
#+END_EXAMPLE

**** Adding a JavaScript module to your project configuration
   :PROPERTIES:
   :CUSTOM_ID: adding-a-javascript-module-to-your-project-configuration
   :END:

If you want to include a JavaScript module into your project you need to add it as a foreign library and specify its module type using the =:module-type= compiler option. The module types that are currently supported are *CommonJS*, *AMD* and *ECMAScript 6*. Respectively, the values that can be specified for the =:module-type= compiler option are =:commonjs=, =:amd= and =:es6=. For example, the compiler options for the CommonJS module shown above are as follows:

#+BEGIN_SRC clojure
    :foreign-libs [{:file "resources/libs/calculator.js"
                    :provides ["calculator"]
                    :module-type :commonjs}]
#+END_SRC

**** Using a JavaScript module in your code
   :PROPERTIES:
   :CUSTOM_ID: using-a-javascript-module-in-your-code
   :END:

You can include a JavaScript module into a ClojureScript namespace by using the name that you've specified for the module with the =:provides= compiler option. For the CommonJS module shown above we've specified the name =calculator=. We can now use the module in our ClojureScript code in the same way as we would use modules from the [[file:xref/../google-closure-library][Google Closure Library]].

#+BEGIN_SRC clojure
    (ns my-project.core
      (:require [calculator :as calc]))

    (enable-console-print!)

    (println (calc/add 4 5))
#+END_SRC

*** Limitations
  :PROPERTIES:
  :CUSTOM_ID: limitations
  :END:

**** Restrictions imposed by the Google Closure compiler
   :PROPERTIES:
   :CUSTOM_ID: restrictions-imposed-by-the-google-closure-compiler
   :END:

The Google Closure compiler expects its JavaScript input to conform to a few restrictions when using optimization levels =:simple= or =:advanced=. This means if you would like to use either of those optimization levels your JavaScript module has to conform to the restrictions imposed by the Google Closure compiler. See [[https://developers.google.com/closure/compiler/docs/limitations]] for more details about the restrictions.

**** Specifying module dependencies
   :PROPERTIES:
   :CUSTOM_ID: specifying-module-dependencies
   :END:

If your JavaScript module depends on other modules you need to add those modules to the project configuration as well. This can be infeasible for larger projects with many different modules. In this case you might want to try to bundle your project first and then include it as a single module.

**** Node.js modules
   :PROPERTIES:
   :CUSTOM_ID: node.js-module
   :END:

The [[https://nodejs.org/api/modules.html][Node.js module specification]] varies slightly from the [[http://wiki.commonjs.org/wiki/Modules/1.1#Module_Identifiers][CommonJS specification]] in that the module identifier that is passed to =require()= doesn't always need to be an absolute or relative path. This makes it difficult for the Google Closure compiler to resolve the dependencies of a node module since the compiler was implemented following the standard CommonJS specification. Therefore, it might not be possible for a node module to be converted to a Google Closure module.

** Packaging Foreign Dependencies
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/packaging-foreign-deps.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/packaging-foreign-deps
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/packaging-foreign-deps
:END:

This page explains how to package non-Closure compatible JavaScript libraries for ClojureScript consumption. Before packaging a library make sure that it has not already been packaged by someone else. [[http://cljsjs.github.io][CLJSJS]] is a promising community driven effort to provide a curated set of dependencies. To avoid duplication of effort and dependency conflicts it's recommended to contribute to a combined effort such as CLJSJS.

When packaging a non-Closure compatible library for ClojureScript consumption make sure to include the development version of the library, the production version of the library, and an externs file. For example if you were packaging React for consumption the directory structure should probably look like the following:

#+BEGIN_EXAMPLE
    src/deps.cljs
    src/react/react.js
    src/react/react.min.js
    src/react/externs.js
#+END_EXAMPLE

Note that you must specify *deps.cljs*

A *deps.cljs* file for React might look like the following:

#+BEGIN_SRC clojure
    {:foreign-libs
      [{:file "react/react.js"
        :file-min "react/react.min.js"
        :provides ["com.facebook.React"]}]
     :externs ["react/externs.js"]}
#+END_SRC

Now users can simply add your JAR like any other dependency in their *pom.xml* or *project.clj* and require the =com.facebook.React= namespace in their ClojureScript source to import React. It's important to understand the namespace in this case is completely synthetic - foreign dependencies are always loaded globally.

JARs may contain as many foreign libraries as you like just add more entries to the =:foreign-libs= vector.

=:file-min= is completely optional but the above pattern is recommended for the best experience for library consumers.

For a full example see [[https://github.com/swannodette/react-cljs][react-cljs]].

If your foreign library has dependencies then you must enumerate them in a =:requires= vector.

#+BEGIN_SRC clojure
    {:foreign-libs
      [{:file "jquery/jquery.js"
        :file-min "jquery/jquery.min.js"
        :provides ["org.jquery.jQuery"]}
       {:file "jquery/ui/core.js"
        :file-min "jquery/ui/core.min.js"
        :provides ["org.jquery.ui.Core"]
        :requires ["org.jquery.jQuery"]}
       {:file "jquery/ui/autocomplete.js"
        :file-min "jquery/ui/autocomplete.min.js"
        :provides ["org.jquery.ui.Autocomplete"]
        :requires ["org.jquery.ui.Core"]}]
     :externs ["jquery/jquery.js" "jquery/jquery.ui.js"]}
#+END_SRC

** The REPL and main entry points
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/repl-and-main.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/repl-and-main
:CLOJURESCRIPT_SITE_AUTHOR: ClojureScript Team
:CLOJURESCRIPT_SITE_DATE: 2018-03-26
:CUSTOM_ID: content/reference/repl-and-main
:END:

*This guide requires ClojureScript 1.10.238 or later and assumes familiarity with the [[file:xref/../../guides/quick-start][Quick Start]]*.

*** The cljs.main namespace
  :PROPERTIES:
  :CUSTOM_ID: _the_cljs_main_namespace
  :END:

The =cljs.main= namespace provides functions that allow ClojureScript programs and interactive sessions to be launched via Java's application launcher tool =java=.

This guide is also easily used with any other Clojure build tool that supports the Clojure CLI =-m= flag.

For example with =clj=:

#+BEGIN_SRC sh
    clj -M -m cljs.main ...
#+END_SRC

*** cljs.main --help
  :PROPERTIES:
  :CUSTOM_ID: _cljs_main_help
  :END:

The =cljs.main/main= entry point accepts a variety of arguments and flags.

-  With no options or args, runs an interactive Read-Eval-Print Loop

-  init options:

   -  =-co=, =--compile-opts= /edn/ Options to configure the build, can be an EDN string or system-dependent path-separated list of EDN files / classpath resources. Options will be merged left to right.

   -  =-d=, =--output-dir= /path/ Set the output directory to use. If supplied, =cljsc_opts.edn= in that directory will be used to set ClojureScript compiler options

   -  =-re=, =--repl-env= /env/ The REPL environment to use. Built-in supported values: =node=, =browser=. Defaults to =browser=

   -  =-ro=, =--repl-opts= /edn/ Options to configure the repl-env, can be an EDN string or system-dependent path-separated list of EDN files / classpath resources. Options will be merged left to right.

   -  =-t=, =--target= /name/ The JavaScript target. Configures environment bootstrap and defaults to =browser=. Supported values: =node= or =nodejs=, =webworker=, =none=

-  init options only for =--main= and =--repl=:

   -  =-e=, =--eval= /string/ Evaluate expressions in string; print non-=nil= values

   -  =-i=, =--init= /path/ Load a file or resource

   -  =-v=, =--verbose= /bool/ If =true=, will enable ClojureScript verbose logging

-  init options only for =--compile=:

   -  =-O=, =--optimizations= /level/ Set optimization level, only effective with =--compile= main option. Valid values are: =none=, =whitespace=, =simple=, =advanced=

   -  =-o=, =--output-to= /file/ Set the output compiled file

   -  =-w=, =--watch= /path/ Continuously build, only effective with the =--compile= main option. Specifies a system-dependent path-separated list of directories to watch.

-  main options:

   -  =-= Run a script from standard input

   -  =-c=, =--compile= /[ns]/ Run a compile. If optional namespace specified, use as the main entry point. If =--repl= follows, will launch a REPL after the compile completes. If =--server= follows, will start a web server that serves the current directory after the compile completes.

   -  =-h=, =--help=, =-?= Print this help message and exit

   -  =-m=, =--main= /ns/ Call the =-main= function from a namespace with args

   -  =-r=, =--repl= Run a repl

   -  =-s=, =--serve= /host:port/ Start a simple web server to serve the current directory

   -  /path/ Run a script from a file or resource

-  For =--main= and =--repl=:

   -  Enters the =cljs.user= namespace

   -  Binds =*command-line-args*= to a seq of strings containing command line args that appear after any main option

   -  Runs all init options in order

   -  Calls a =-main= function or runs a repl or script if requested

The init options may be repeated and mixed freely, but must appear before any main option.

In the case of =--compile= you may supply =--repl= or =--serve= options afterwards.

Paths may be absolute or relative in the filesystem or relative to classpath. Classpath-relative paths have prefix of =@= or =@/=

The same is also described in the usage message:

#+BEGIN_EXAMPLE
    Usage: java -cp cljs.jar cljs.main [init-opt*] [main-opt] [arg*]

    With no options or args, runs an interactive Read-Eval-Print Loop

    init options:
      -co, --compile-opts edn     Options to configure the build, can be an EDN
                                  string or system-dependent path-separated list of
                                  EDN files / classpath resources. Options will be
                                  merged left to right.
       -d, --output-dir path      Set the output directory to use. If supplied,
                                  cljsc_opts.edn in that directory will be used to
                                  set ClojureScript compiler options
      -re, --repl-env env         The REPL environment to use. Built-in supported
                                  values: node, browser. Defaults to browser
      -ro, --repl-opts edn        Options to configure the repl-env, can be an EDN
                                  string or system-dependent path-separated list of
                                  EDN files / classpath resources. Options will be
                                  merged left to right.
       -t, --target name          The JavaScript target. Configures environment
                                  bootstrap and defaults to browser. Supported
                                  values: node or nodejs, webworker, none

    init options only for --main and --repl:
       -e, --eval string          Evaluate expressions in string; print non-nil
                                  values
       -i, --init path            Load a file or resource
       -v, --verbose bool         If true, will enable ClojureScript verbose logging

    init options only for --compile:
       -O, --optimizations level  Set optimization level, only effective with --
                                  compile main option. Valid values are: none,
                                  whitespace, simple, advanced
       -o, --output-to file       Set the output compiled file
       -w, --watch paths          Continuously build, only effective with the --
                                  compile main option. Specifies a system-dependent
                                  path-separated list of directories to watch.

    main options:
       -                          Run a script from standard input
       -c, --compile [ns]         Run a compile. If optional namespace specified,
                                  use as the main entry point. If --repl follows,
                                  will launch a REPL after the compile completes.
                                  If --server follows, will start a web server that
                                  serves the current directory after the compile
                                  completes.
       -h, --help, -?             Print this help message and exit
       -m, --main ns              Call the -main function from a namespace with args
       -r, --repl                 Run a repl
       -s, --serve host:port      Start a simple web server to serve the current
                                  directory
       path                       Run a script from a file or resource

    For --main and --repl:

      - Enters the cljs.user namespace
      - Binds *command-line-args* to a seq of strings containing command line
        args that appear after any main option
      - Runs all init options in order
      - Calls a -main function or runs a repl or script if requested

    The init options may be repeated and mixed freely, but must appear before
    any main option.

    In the case of --compile you may supply --repl or --serve options afterwards.

    Paths may be absolute or relative in the filesystem or relative to
    classpath. Classpath-relative paths have prefix of @ or @/
#+END_EXAMPLE

*** Launching a REPL
  :PROPERTIES:
  :CUSTOM_ID: _launching_a_repl
  :END:

The simplest way to launch a ClojureScript /repl/ is to use the following command line with the shipping =cljs.jar=:

#+BEGIN_EXAMPLE
    java -cp cljs.jar cljs.main
#+END_EXAMPLE

The REPL prompt shows the name of the current namespace, which defaults to /cljs.user/.

Several special vars are available when using the REPL:

-  =*1=, =*2=, =*3= - hold the result of the last three expressions that were evaluated

-  =*e= - holds the result of the last exception.

*** Launching a Script
  :PROPERTIES:
  :CUSTOM_ID: _launching_a_script
  :END:

To run a file full of ClojureScript code as a script, pass the path to the script to =cljs.main= as an argument:

#+BEGIN_EXAMPLE
    java -cp cljs.jar cljs.main /path/to/myscript.cljs
#+END_EXAMPLE

*** Passing arguments to a Script
  :PROPERTIES:
  :CUSTOM_ID: _passing_arguments_to_a_script
  :END:

To pass in arguments to a script, pass them in as further arguments when launching =cljs.main=:

#+BEGIN_EXAMPLE
    java -cp cljs.jar cljs.main /path/to/myscript.cljs arg1 arg2 arg3
#+END_EXAMPLE

The arguments will be provided to your program as a seq of strings bound to the var =*command-line-args*=:

#+BEGIN_EXAMPLE
    *command-line-args* => ("arg1" "arg2" "arg3")
#+END_EXAMPLE

*** Compiling Source
  :PROPERTIES:
  :CUSTOM_ID: _compiling_source
  :END:

To compile ClojureScript source code, pass the main namespace to =cljs.main= via the =-c= option:

#+BEGIN_EXAMPLE
    java -cp src:cljs.jar cljs.main -c my-namespace.core
#+END_EXAMPLE

The output will be written to the directory specified via the =-d= option (or =out= if unspecified), or to the file specified via the =-o= option.

** REPL Options
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/repl-options.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/repl-options
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/repl-options
:END:

ClojureScript REPLs can take nearly all the same options that can be supplied to =cljs.closure/build=, for details see [[file:compiler-options][Compiler Options]]. This page documents additional supported options.

Note that options presented below under General Options should be passed as compiler options (via =-co= / =--compile-opts= if using =cljs.main=), while REPL-environment-specific options should be passed as REPL options (via =-ro= / =repl-opts= if using =cljs.main=).

*** General Options
  :PROPERTIES:
  :CUSTOM_ID: _general_options
  :END:

**** :analyze-path
   :PROPERTIES:
   :CUSTOM_ID: analyze-path
   :END:

Sets a source path to analyze upon REPL initialization so that, if it connects to an already-running JavaScript environment, symbols for any previously loaded namespaces are available. May also be set to a vector of paths to analyze.

#+BEGIN_SRC clojure
    :analyze-path "src"
#+END_SRC

**** :def-emits-var
   :PROPERTIES:
   :CUSTOM_ID: def-emits-var
   :END:

Sets whether =def= (and derived) forms evaluated at the REPL return either a Var (if set to =true=) or the =def= init value (if =false=). Only affects forms evaluated at the REPL; compiled source behaves as if set to =false=. Default is =true=.

#+BEGIN_SRC clojure
    :def-emits-var false
#+END_SRC

**** :repl-requires
   :PROPERTIES:
   :CUSTOM_ID: repl-requires
   :END:

Specifies a set of lib specs (per the =require= REPL special) to be automatically loaded when launching a REPL. Defaults to specs that refer =doc= /etc./ along with =pp=.

#+BEGIN_SRC clojure
    :repl-requires [[cljs.repl :refer-macros [source doc find-doc apropos dir pst]]
                    [cljs.pprint :refer [pprint] :refer-macros [pp]]]
#+END_SRC

**** :repl-verbose
   :PROPERTIES:
   :CUSTOM_ID: repl-verbose
   :END:

Enable verbose reporting for the REPL. Useful for debugging. Defaults to =false=.

#+BEGIN_SRC clojure
    :repl-verbose true
#+END_SRC

This prints the compiled JavaScript before printing its evaluation:

#+BEGIN_EXAMPLE
    cljs.user=> (+ 1 2)
    ((1) + (2))
    3
#+END_EXAMPLE

**** :warn-on-undeclared
   :PROPERTIES:
   :CUSTOM_ID: warn-on-undeclared
   :END:

Overrides warnings related to the use of undeclared vars and non-existent namespaces at the REPL (specifically =:unprovided=, =:undeclared-var=, =:undeclared-ns=, and =:undeclared-ns-form=). Defaults to =true=.

#+BEGIN_SRC clojure
    :warn-on-undeclared false
#+END_SRC

**** :watch
   :PROPERTIES:
   :CUSTOM_ID: watch
   :END:

Watch a source directory for recompilation to avoid spinning up an additional JVM.

#+BEGIN_SRC clojure
    :watch "src"
#+END_SRC

**** :watch-fn
   :PROPERTIES:
   :CUSTOM_ID: watch-fn
   :END:

#+BEGIN_SRC clojure
    :watch-fn (fn [] (println "built!"))
#+END_SRC

A function of no arguments to run after a successful build.

*** Browser REPL Options
  :PROPERTIES:
  :CUSTOM_ID: _browser_repl_options
  :END:

These options are only applicable to the browser REPL that ships with ClojureScript.

**** :launch-browser
   :PROPERTIES:
   :CUSTOM_ID: launch-browser
   :END:

By default, starting the browser REPL launches the default browser configured with your operating system to connect back to it. You can disable this behavior by setting this option to =false=, and when doing so you will be prompted to connect with a message like

#+BEGIN_EXAMPLE
    Waiting for browser to connect to http://localhost:9000 ...
#+END_EXAMPLE

#+BEGIN_SRC clojure
    :launch-browser false
#+END_SRC

**** :working-dir
   :PROPERTIES:
   :CUSTOM_ID: working-dir
   :END:

The directory where the compiled REPL client JavaScript will be stored. Defaults to ".repl" with a ClojureScript version suffix, eg. ".repl-1.9-946".

**** :static-dir
   :PROPERTIES:
   :CUSTOM_ID: static-dir
   :END:

List of directories to search for static content. Defaults to =["." "out/"]=.

**** :src
   :PROPERTIES:
   :CUSTOM_ID: src
   :END:

The source directory containing user-defined cljs files. Used to support reflection. Defaults to ="src/"=.

*** Node REPL Options
  :PROPERTIES:
  :CUSTOM_ID: _node_repl_options
  :END:

**** :host
   :PROPERTIES:
   :CUSTOM_ID: host
   :END:

The host that the Node subprocess listens on for REPL traffic.

#+BEGIN_SRC clojure
    :host "localhost"
#+END_SRC

**** :port
   :PROPERTIES:
   :CUSTOM_ID: port
   :END:

The port that the Node subprocess listens on for REPL traffic.

#+BEGIN_SRC clojure
    :port 49152
#+END_SRC

*** Graal.JS REPL Options
  :PROPERTIES:
  :CUSTOM_ID: _graal_js_repl_options
  :END:

Executing =js --help:languages= will display a list of Graal.JS-specific options. Any REPL option with a string key starting with ="js."= will be passed through to the Graal.JS engine. Such entries should have string values.

Here is an example enabling and using the ECMAScript Internationalization API:

#+BEGIN_EXAMPLE
    $ clj -M -m cljs.main -re graaljs -ro '{"js.intl-402" "true"}' -r
    cljs.user=> (def gas-price (js/Intl.NumberFormat. "en-US"
                                 #js {:style "currency"
                                      :currency "USD"
                                      :minimumFractionDigits 3}))
    #'cljs.user/gas-price
    cljs.user=> (.format gas-price 5.259)
    "$5.259"
#+END_EXAMPLE

** REPL and Evaluation
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/repl.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/repl
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/repl
:END:

*This reference is intended for people who would like to launch REPLs programmatically from Clojure for some reason. The recommended way to start REPL is documented in the [[file:xref/../../guides/quick-start][Quick Start]]*.

One of the reasons for creating ClojureScript is that JavaScript reaches. There are many interesting environments in which JavaScript can run. Each of these environments has something unique about it. One of the reasons that Clojure rocks is that it has a REPL which gives developers the most dynamic development experience possible. We would like to support this dynamic development experience in every environment where JavaScript runs. To accomplish this, we have created an abstraction around the JavaScript environment and disconnected the REPL from any particular implementation. This gives the REPL the same reach as JavaScript as well as allowing evaluation environment implementations to be used independently for things like automated testing and cross-environment testing.

Most projects will target a specific environment. These changes will allow developers to have the full benefit of a REPL in their target environment. Currently there are implementations for multiple environments. By implementing one protocol, one may easily support additional environments.

*** Using the REPL
  :PROPERTIES:
  :CUSTOM_ID: using-the-repl
  :END:

The basic usage of the REPL is always the same:

1. require =cljs.repl=

2. require the namespace which implements the desired evaluation environment

3. create a new evaluation environment

4. start the REPL with the created environment

Using the REPL will also feel the same in each environment; forms are entered, results are printed and side-effects happen where they make the most sense.

**** Using the browser as an Evaluation Environment
   :PROPERTIES:
   :CUSTOM_ID: using-the-browser-as-an-evaluation-environment
   :END:

A browser-connected REPL works in much the same way as a normal REPL: forms are read from the console, evaluated and return values are printed. A major and useful difference from normal REPL usage is that all side-effects occur in the browser. You can show alerts, manipulate the dom and interact with a running application.

There is a sample project under =samples/repl= which shows how to set up a minimal browser-connected REPL. The example below will walk through doing the same thing, step-by-step.

The first step is to create the browser side of the connection. This is done by requiring one file and adding one line of code, as shown below in a file named =foo.cljs=.

#+BEGIN_SRC clojure
    (ns foo
      (:require [clojure.browser.repl :as repl]))
    (repl/connect "http://localhost:9000/repl")
#+END_SRC

The most interesting use case for a browser-connected REPL is to connect it to a project and use the REPL to drive and develop an application while it is running. To accomplish this, add the code above to any namespace in the project.

Next, compile the file in either development mode or with simple optimizations. No advanced optimizations please.

#+BEGIN_SRC sh
    ./bin/cljsc foo.cljs > foo.js
#+END_SRC

Create a host html page named index.html like the one shown below.

#+BEGIN_EXAMPLE
    <html>
      <head>
        <meta charset="UTF-8">
        <title>Browser-connected REPL</title>
      </head>
      <body>
        <div id="content">
          <script type="text/javascript" src="out/goog/base.js"></script>
          <script type="text/javascript" src="foo.js"></script>
          <script type="text/javascript">
            goog.require('foo');
          </script>
        </div>
      </body>
    </html>
#+END_EXAMPLE

There is nothing different about this and what one would do for any other browser-based ClojureScript project.

Start the REPL using the pattern described above, but with the browser as the evaluation environment.

#+BEGIN_SRC clojure
    (require '[cljs.repl :as repl])
    (require '[cljs.repl.browser :as browser])  ;; require the browser implementation of IJavaScriptEnv
    (def env (browser/repl-env)) ;; create a new environment
    (repl/repl env) ;; start the REPL
#+END_SRC

Once the REPL has started, you will see the message "Starting server on port 9000". At this point, open the html page by going to [[http://localhost:9000]] to complete the connection. Once the page is open and the connection is made, the REPL prompt will be displayed.

Port 9000 is the default. Notice that we point the browser to this port in the client code above. To use a different port, pass a :port option when creating a new evaluation environment.

#+BEGIN_SRC clojure
    (def env (browser/repl-env :port 8090)) ;; listen on port 8090
#+END_SRC

Just in case you can't think of anything interesting to do, here are some ideas.

#+BEGIN_SRC clojure
    ;; the basics
    (+ 1 1)
    (:a {:a :b})
    (reduce + [1 2 3 4 5])
    (defn sum [coll] (reduce + coll))
    (sum [2 2 2 2])

    ;; load a ClojureScript file and use it
    (load-file "clojure/string.cljs")
    (clojure.string/reverse "ClojureScript")

    ;; browser specific
    (js/alert "I am an evil side-effect")

    (ns test.dom (:require [clojure.browser.dom :as dom]))
    (dom/append (dom/get-element "content")
                (dom/element "ClojureScript is all up in your DOM."))

    ;; load and use goog code we haven't used yet
    (ns test.crypt (:require [goog.crypt :as c]))
    (c/stringToByteArray "ClojureScript")

    (load-namespace 'goog.date.Date)
    (goog.date.Date.)
#+END_SRC

There is currently no =require= function but =ns= forms can be used to load, require and alias new namespaces. The functions =load-file= and =load-namespace= can be used to load code with any environment and are described in more detail below.

***** Browser-connected REPL Options
    :PROPERTIES:
    :CUSTOM_ID: browser-connected-repl-options
    :END:

There are currently two options which may be used to configure the browser evaluation environment.

-  =:port= set the port to listen on - defaults to 9000

-  =:working-dir= set the working directory for compiling REPL related code - defaults to ".repl"

**** Loading code
   :PROPERTIES:
   :CUSTOM_ID: loading-code
   :END:

The code above shows examples of three ways to load code into an evaluation environment: =load-file=, =load-namespace= and within a =ns= form. =load-file= is the most low level method of loading code. It may only be used to load ClojureScript files. It will compile them and evaluate the compiled JavaScript. =load-namespace= loads any file, ClojureScript or JavaScript, with all of its dependencies, which have not already been loaded, in dependency order. When a namespace is required in an =ns= form, each required namespace will be loaded using =load-namespace=.

These functions are available in every evaluation environment.

**** Auto-loaded user code
   :PROPERTIES:
   :CUSTOM_ID: auto-loaded-user-code
   :END:

When a REPL starts, it automatically loads any =user.cljs= or =user.cljc= file present on your classpath. This is an ideal location to place code that is useful for development time.

The file may optionally contain an =ns= form in order to load required namespaces or to establish the namespace for any =def= forms that appear in the file.

If no namespace is specified, =cljs.user= is assumed.

*** Implementation
  :PROPERTIES:
  :CUSTOM_ID: implementation
  :END:

If you would like to work on this code then the following notes about implementation will be helpful.

**** Goals
   :PROPERTIES:
   :CUSTOM_ID: goals
   :END:

-  No additional dependencies

-  Should work *now* in all browsers

-  Security is a non-goal, this is for development and testing

**** The IJavaScriptEnv Protocol
   :PROPERTIES:
   :CUSTOM_ID: the-ijavascriptenv-protocol
   :END:

To create a new environment, implement the IJavaScriptEnv protocol.

#+BEGIN_SRC clojure
    (defprotocol IJavaScriptEnv
      (-setup [this opts])
      (-evaluate [this filename line js])
      (-load [this ns url])
      (-tear-down [this]))
#+END_SRC

=setup= and =tear-down= do any work which is required to create and destroy the JavaScript evaluation environment. These functions will have side-effects and will return nil.

=evaluate= takes a file name, line number and a JavaScript string and evaluates the string returning a map with the keys =:status= and =:value=. The value of status may be =:success=, =:error= or =:exception=. =:value= will be the return value or an error message. In the case of an exception, there may be a =:stacktrace= key containing the stack trace.

The =load= function takes a list of namespaces which are provided by a JavaScript file and the URL for the file and will load JavaScript from the given URL into the environment. The implementation is not responsible for ensuring that each namespace is loaded once and only once, as this is [[file:xref/../../../guides/custom-repls#eliminating-loaded-libs-tracking][managed by the infrastructure]].

**** Browser as Evaluation Environment
   :PROPERTIES:
   :CUSTOM_ID: browser-as-evaluation-environment
   :END:

To create the browser-connected REPL and meet the goals described above, we use long-polling and Google's CrossPageChannel. Long-polling allows us to treat the browser as the server and CrossPageChannel helps us get around the same-origin policy.

The model for a browser-connected REPL is that the REPL is the client and the browser is the server which evaluates JavaScript code. How do we implement this without resorting to WebSockets? If we think of the connection as a series of messages being passed between the browser and the REPL, and we ignore the first message sent from the browser, then we have what we need. When the browser initially connects, the REPL will hold that connection until is has something to send for evaluation. Once the next form is read and compiled, it will be sent to the browser using that saved connection. The browser will evaluate it and send the result with a new connection. And the cycle repeats...

Browsers enforce a same-origin policy for JavaScript code. This means that the JavaScript which is evaluated in a page can come from only one origin domain. This is a problem for the browser-connected REPL because FireFox and Chrome both view opening a file from the file system and connecting to localhost:9000 as different domains. It may also be a valid use case to want to connect to an application served from a totally different domain, which would be prohibited in all browsers.

Fortunately, Google has also run into this problem and has created something called a CrossPageChannel. Without going into the details, this allows an iframe served from one domain (the REPL) to communicate with the parent page which was served from another domain (the application server). This is accomplished in a way that is supported by all modern browsers.

**** Code loading in the Browser
   :PROPERTIES:
   :CUSTOM_ID: code-loading-in-the-browser
   :END:

Google Closure has a technique for loading dependencies. It uses a dependency file to create a dependency graph and to map namespaces to files. The ClojureScript =build= function creates this kind of dependency file when compiling a project in development mode. Google Closure makes the assumption that everything that needs to known about dependencies will be known when the application starts. This assumption is not valid when using a REPL and leads to two limitations.

The first limitation is that all dependencies need to be included in these files before the application starts. We cannot add new dependencies later for new ClojureScript or JavaScript namespaces that we would like to use.

Another limitation is that Google's method of loading dependencies assumes that all dependencies will be loaded when the application starts. The implementation of =goog.writeScriptTag_= uses =document.write= to add new script tags to a page. This works when it is used during the initial page load but if used after the page is loaded, it will remove the document's content. This means that even if the dependency file contains the dependency that we would like to load, it cannot be loaded. This can be fixed. See [[https://github.com/ibdknox/brepl/blob/master/out/brepl.js]] for an example.

The ClojureScript REPL already has a =load-file= function which can be used to load a single ClojureScript file. This function does not account for dependencies and cannot be used to load third-party JavaScript files.

This suggests that we need one unified way to load things which will work for anything that we may want to load. The =load-namespace= function was created for this purpose. It uses the build system to calculate all dependencies for the given namespace. This includes anything that we can currently build into a project: ClojureScript files, JavaScript files as well as third-party ClojureScript and JavaScript. Each dependency is then passed to the =-load= function in dependency order. The =-load= function is responsible to determining if the namespace has already been loaded and, if it has not, evaluating the JavaScript.

When the REPL compiles a namespace form, it will check for required namespaces and call =load-namespace= on each of them.

Note: conveying the :libs option to the REPL so that it can find third-party JavaScript libraries has not yet been implemented.

** Source maps
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/reference/source-maps.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/reference/source-maps
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-07-29
:CUSTOM_ID: content/reference/source-maps
:END:

ClojureScript now supports HTML source maps so that you can debug ClojureScript directly in the browser, using the configuration option =:source-map=.

=:source-map= can be either a boolean, or if optimizations are enabled, a path to a file for the map.

Using the =bin/cljsc= script herein, you can run something like the following on the command line, adjusted for your project:

#+BEGIN_SRC sh
     $ cljsc src '{:optimizations :whitespace :output-dir "out" :output-to "main.js" :source-map "main.js.map"}'
#+END_SRC

If you are building using leiningen, a similar section in =project.clj= would look something like:

#+BEGIN_SRC clojure
     :cljsbuild {
        :builds [{:id "main"
                  :source-paths ["src"]
                  :compiler {
                    :output-to "main.js"
                    :output-dir "out"
                    :optimizations :none
                    :source-map true}}]})
#+END_SRC

After compilation, you may then open an HTML file linking to the generated js file in Chrome. Make sure that source maps in Chrome are enabled via [[https://developer.chrome.com/devtools/docs/javascript-debugging#source-maps][the Chrome Developer Tools settings]].

Source maps also work with =:optimizations= set to =:none=. In this case the =:source-map= value doesn't control file names. So long as the value is truth-y (cf. the leiningen example above), an individual source map file will be generated for every ClojureScript source file.

It's important to note there are some source map option restrictions when using an =:optimizations= setting other than =:none=. In these cases =:output-to=, =:output-dir=, and =:source-map= must all share the exact same parent directory. The generated JavaScript file (=:output-to=) will contain a line at the end linking it to its source map like so:

#+BEGIN_EXAMPLE
    //# sourceMapping=<sourceMapURL>
#+END_EXAMPLE

The =sourceMapURL= is the =:source-map= path, relative to =:output-to=, since that is how the browser will then resolve it. For example, when given:

#+BEGIN_SRC clojure
    {:output-to "resources/public/js/compiled/main.js"
     :output-dir "resources/public/js/compiled"
     :optimizations :simple
     :source-map "resources/public/js/compiled/main.js.map"}
#+END_SRC

The resulting =sourceMapURL= will be: =main.js.map=.

*** Web Server integration
  :PROPERTIES:
  :CUSTOM_ID: web-server-integration
  :END:

All source files will get copied into =:output-dir= so that they can be resolved, however this is not useful in the case where you have a web server. =:source-map-path= can be used to define an arbitrary path prefix. So instead of source map file references resolving to something like =resources/public/js/out= you can instead instead specify =:source-map-path "js/out"=.

* Tools
** Atom
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/atom.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/atom
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-02
:CUSTOM_ID: content/tools/atom
:END:
*** How to Install Atom Packages
  :PROPERTIES:
  :CUSTOM_ID: packages
  :END:

You can bring up your Atom settings by pressing =Command + ,= (command + comma) or =Control + ,= (control + comma) on Windows. From there, you can go to the "Install" tab and search for the name of the package you'd like to install. If you prefer using the command line, you can also use =apm= to install packages using:

#+BEGIN_EXAMPLE
    $ apm install [package-name]
#+END_EXAMPLE

*** Parinfer
  :PROPERTIES:
  :CUSTOM_ID: parinfer
  :END:

Unlike Java and Javascript, the convention in ClojureScript is to place closing delimiters on the same line instead of on a new line. To help manage this, Shaun LeBron's [[https://shaunlebron.github.io/parinfer/][Parinfer]] can automatically balance your closing delimiters based on your code's indentation. Chris Oakman's Atom package for Parinfer can be found here: [[https://atom.io/packages/parinfer]]

*** Improved Newline Auto-Indentation
  :PROPERTIES:
  :CUSTOM_ID: indentation
  :END:

Atom, by default, does not auto-indent newlines correctly for Lisp dialects. You can solve this by installing Jon Spalding's [[https://atom.io/packages/lisp-paredit][lisp-paredit]] Atom package. If you're already using Parinfer and only want to use the lisp-paredit package for newline indentation, you can change lisp-paredit's settings to:

-  Enabled: checked

-  Strict: unchecked

-  Keybindings Enable: unchecked

...​and update your =keymap.cson= file with the following keybindings:

#+BEGIN_EXAMPLE
    # Provides proper indentation when enter is pressed
    'atom-text-editor[data-grammar~="clojure"]':
      'enter': 'lisp-paredit:newline'

    # Override newline back to original when in Proto-REPL console
    # GitHub Issue: https://github.com/jonspalding/lisp-paredit/issues/26
    'ink-console atom-text-editor[data-grammar~="clojure"]':
      'enter': 'editor:newline'
#+END_EXAMPLE

#+BEGIN_QUOTE
  *Note*

  The =keymap.cson= file is found in the main menu under "Atom > Keymap...​".
#+END_QUOTE

*** Joker Linter
  :PROPERTIES:
  :CUSTOM_ID: linters
  :END:

Roman Bataev's [[https://github.com/candid82/joker][Joker]] linter can let you know when you've made an error in your code. Ryan De La Torre's Atom package for Joker can be found here: [[https://atom.io/packages/linter-joker]]

To use this, you will also need to install Joker on your machine. You can download it [[https://github.com/candid82/joker/releases][here]] or install it via Homebrew with:

#+BEGIN_EXAMPLE
    brew install candid82/brew/joker
#+END_EXAMPLE

*** Proto REPL
  :PROPERTIES:
  :CUSTOM_ID: proto-repl
  :END:

Jason Gilman's [[https://atom.io/packages/proto-repl][Proto REPL]] allows you to evaluate ClojureScript code from your editor.

**** Setting Up Proto REPL with Figwheel
   :PROPERTIES:
   :CUSTOM_ID: _setting_up_proto_repl_with_figwheel
   :END:

If you're using Leiningen and Figwheel, the quickest way to connect Proto REPL to your application is to launch Figwheel from within Proto REPL. To do this, first merge =figwheel-sidecar=, =piggieback=, and =proto-repl= into your dev dependencies in your =project.clj=:

#+BEGIN_SRC clojure
    :profiles {:dev {:dependencies [[figwheel-sidecar "0.5.9"]
                                    [com.cemerick/piggieback "0.2.1"]
                                    [proto-repl "0.3.1"]]
#+END_SRC

Next, add piggieback's nREPL middleware for ClojureScript in your =project.clj=:

#+BEGIN_SRC clojure
    :repl-options {:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]}
#+END_SRC

Now open Proto REPL. You can do this by pressing =Command + Shift + P= (or =Control + Shift + P= on Windows) to bring up the Command Palette, then using the Command Palette to search for the =Proto REPL: Toggle= command.

After starting Proto REPL, you should see the message, "Starting REPL with lein in [path to your project]" at the bottom of the REPL instructions. If all went well, you should be able to run the following command in Proto REPL to start Figwheel and start a ClojureScript REPL:

#+BEGIN_SRC clojure
    (do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))
#+END_SRC

Open your locally-hosted webpage in a browser, then try typing some test code into Proto REPL, such as =(js/alert "Hello from Proto REPL!")= to verify that everything is working. (The above command should cause an alert to appear in your browser.)

**** Saving Commands to Proto REPL
   :PROPERTIES:
   :CUSTOM_ID: _saving_commands_to_proto_repl
   :END:

If you don't want to type the command to start Figwheel every time, you can save a custom command to your Atom's =init.js=/=init.coffee= file:

#+BEGIN_EXAMPLE
    atom.commands.add('atom-text-editor', 'Start Figwheel with CLJS REPL', function () {
      protoRepl.executeCode(`
        (when
          (try
            (require 'figwheel-sidecar.repl-api)
            (resolve 'figwheel-sidecar.repl-api/start-figwheel!)
            (catch Throwable _))
          (eval '(do (figwheel-sidecar.repl-api/start-figwheel!)
                     (figwheel-sidecar.repl-api/cljs-repl))))
      `);
    });
#+END_EXAMPLE

More documentation on extending Proto REPL can be found here: [[https://github.com/jasongilman/proto-repl/blob/master/extending_proto_repl.md]]

** Cursive
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/cursive.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/cursive
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-02
:CUSTOM_ID: content/tools/cursive
:END:

[[https://cursive-ide.com][Cursive]] is a plugin for IntelliJ that offers syntax highlighting, structural editing and navigation (paredit), code indexing / symbol lookup, refactoring, debugging, and static analysis / arity warnings. In addition, it includes an integrated REPL environment.

** Emacs and Inferior Clojure Interaction Mode
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/emacs-inf.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/emacs-inf
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-02
:CUSTOM_ID: content/tools/emacs-inf
:END:

*This guide requires ClojureScript 1.10.238 or later and assumes familiarity with the [[file:xref/../../guides/quick-start][Quick Start]]*.

Assuming you already have =clojure-mode=, run =M-x package-list-packages= and install =inf-clojure=. If you are using Emacs on OS X be sure to install =exec-path-from-shell= so that the Node.js REPL will work correctly. If you need =exec-path-from-shell= make sure to follow the [[https://github.com/purcell/exec-path-from-shell#usage][Usage]] instructions.

Edit your =.emacs= or =init.el= and add a function like the following if you are using the JAR in your current directory:

#+BEGIN_SRC clojure
    (defun cljs-node-repl ()
      (interactive)
      (inf-clojure "clj -M -m cljs.main -co build.edn -re node -r"))
#+END_SRC

Open your ClojureScript file and run =M-x cljs-node-repl=. You'll get a new buffer with the REPL. Switch back to your file and run =M-x
inf-clojure-minor-mode=. =C-c C-l= will load the file. =C-c Meta-n= will switch your namespace. If you place your cursor at the end of a s-expression, =C-x C-e= will evaluate that expression. =C-c C-v= will show the docs. =C-c C-s= will show the source. =C-c <return>= will macroexpand. Refer to [[https://github.com/clojure-emacs/inf-clojure][inf-clojure]] for more documentation.

** Leiningen
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/leiningen.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/leiningen
:CLOJURESCRIPT_SITE_AUTHOR: Denis Baudinot
:CLOJURESCRIPT_SITE_DATE: 2021-07-11
:CUSTOM_ID: content/tools/leiningen
:END:

[[https://leiningen.org/][Leiningen]] is a build tool for Clojure and ClojureScript with an extensible plugin and template system.

*** Plugins
  :PROPERTIES:
  :CUSTOM_ID: plugins
  :END:

[[https://github.com/emezeske/lein-cljsbuild][lein-cljsbuild]] provides ClojureScript compilation and file watching. For a more feature rich experience with browser hot reloading and CSS support head to [[https://github.com/bhauman/lein-figwheel][lein-figwheel]].

** Light Table
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/light-table.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/light-table
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-02
:CUSTOM_ID: content/tools/light-table
:END:

[[http://www.lighttable.com][Light Table]] is an extensible IDE that offers instant evaluation of your code, realtime feedback, and a ClojureScript plugin ecosystem.

To get started, check out this concise [[http://docs.lighttable.com/#start][introduction]] or the [[http://docs.lighttable.com/tutorials/full/][full tutorial]].

Once you feel comfortable navigating Light Table's interface and using basic commands, it is advisable to install the official Paredit plugin. You can do so via the integrated plugin manager: open the command bar and look for =Plugins: Show plugin manager=.

** shadow-cljs
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/shadow-cljs.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/shadow-cljs
:CLOJURESCRIPT_SITE_AUTHOR: Denis Baudinot
:CLOJURESCRIPT_SITE_DATE: 2021-07-11
:CUSTOM_ID: content/tools/shadow-cljs
:END:

[[https://github.com/thheller/shadow-cljs][shadow-cljs]] compiles, watches, hot reloads ClojureScript projects and provides targets and integration within the larger JavaScript ecosystem such as Nodejs, NPM and browser modules. It can be used as a standalone npm package to be run from the command line and a Clojure library to be integrated with other build tooling.

From the shadow-cljs [[https://shadow-cljs.github.io/docs/UsersGuide.html][user guide]]:

#+BEGIN_QUOTE
  shadow-cljs provides everything you need to compile your ClojureScript projects with a focus on simplicity and ease of use. The provided build targets abstract away most of the manual configuration so that you only have to configure the essentials for your build. Each target provides optimal defaults for each environment and get an optimized experience during development and in release builds.
#+END_QUOTE

** Sublime Text 2
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/sublime.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/sublime
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-02
:CUSTOM_ID: content/tools/sublime
:END:

Install Sublime Text 2, install Sublime Text Package Control, use that to install the SublimeREPL package, and install the latest Leiningen.

We recommend installing [[https://github.com/odyssomay/paredit][paredit]], [[https://github.com/odyssomay/sublime-lispindent][lispindent]], and [[http://github.com/wuub/SublimeREPL][SublimeREPL]] which ships with support for ClojureScript.

** Testing
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/testing.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/testing
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-01
:CUSTOM_ID: content/tools/testing
:END:

ClojureScript now ships with a port of =clojure.test= in the form of =cljs.test=. It attempts to preserve most of the functionality provided by =clojure.test= along with enhancements for asynchronous testing in a single threaded environment.

Most of the functionality is provided via macros as =cljs.test= relies on compiler reflection and static vars to provide most of its functionality.

For example your testing ns form will probably look something like the following:

#+BEGIN_SRC clojure
    (ns my-project.tests
      (:require [cljs.test :refer-macros [deftest is testing run-tests]]))
#+END_SRC

*** Writing Tests
  :PROPERTIES:
  :CUSTOM_ID: writing-tests
  :END:

You can write tests with =cljs.test/deftest= and =cljs.test/is= same as with =clojure.test=.

For example here is a trivial test with one assertion:

#+BEGIN_SRC clojure
    (deftest test-numbers
      (is (= 1 1)))
#+END_SRC

*** Running Tests
  :PROPERTIES:
  :CUSTOM_ID: running-tests
  :END:

You can run tests by using the =cljs.test/run-tests= macro. This may be done in your REPL or at the end of your file. If you have many test namespaces it's idiomatic to create a test runner namespace which imports all of your test namespaces and then invokes =run-tests=.

You may have to add =(enable-console-print!)= before calling =run-tests=

*** Fixtures
  :PROPERTIES:
  :CUSTOM_ID: fixtures
  :END:

You can declare fixtures with the =cljs.test/use-fixtures= macro. You can declare either =:once= fixtures or =:each= fixtures. =:once= fixtures are run only around all tests within a namespace. =:each= fixtures are run around each test. Unlike =clojure.test= fixtures are split into two parts =:before= and =:after=. This is so that fixtures will work correctly even when used asynchronously.

#+BEGIN_SRC clojure
    (use-fixtures :once
      {:before (fn [] ...)
       :after  (fn [] ...)})
#+END_SRC

*** Async Testing
  :PROPERTIES:
  :CUSTOM_ID: async-testing
  :END:

As client-side code tends to be highly asynchronous and JavaScript is single-threaded, it's important that =cljs.test= provide asynchronous testing support. You can use the =cljs.test/async= macro to create an asynchronous block. If you write an asynchronous test the last value you return /must/ be the async block.

#+BEGIN_SRC clojure
    (deftest test-async
      (async done
        (http/get "http://foo.com/api.edn"
          (fn [res]
            (is (= res :awesome))
            (done)))))
#+END_SRC

=done= is a function that you may invoke when you are ready to relinquish control and allow the next test to run. =done= can be called anything, but it probably makes sense to keep to the convention. All of your testing code must be in the async block. If you launch multiple asychronous processes in your async block you will need to coordinate them. This is a good reason to use =cljs.core.async=:

#+BEGIN_SRC clojure
    (deftest test-async
      (let [url0 "http://foo.com/api.edn"
            url1 "http://bar.com/api.edn"
            res0 (http/get url0)
            res1 (http/get url1)]
        (async done
          (go
            (is (= (<! res0) :awesome))
            (is (= (<! res1) :cool))
            (done)))))
#+END_SRC

*NOTE:* You cannot have more than one async test per =deftest= form or only the first one will run.

Bad:

#+BEGIN_SRC clojure
    (deftest test-async
      (testing "the API is awesome" ; <-- only this test will run
        (let [url "http://foo.com/api.edn"
              res (http/get url)]
          (async done
            (go
              (is (= (<! res) :awesome))
              (done)))))
        (testing "the API is cool"
          (let [url "http://bar.com/api.edn"
                res (http/get url)]
            (async done
              (go
                (is (= (<! res1) :cool))
                (done))))))
#+END_SRC

Good:

#+BEGIN_SRC clojure
    (deftest test-async-awesome
      (testing "the API is awesome"
        (let [url "http://foo.com/api.edn"
              res (http/get url)]
          (async done
            (go
              (is (= (<! res) :awesome))
              (done))))))

    (deftest test-async-cool
      (testing "the API is cool"
        (let [url "http://bar.com/api.edn"
              res (http/get url)]
          (async done
            (go
              (is (= (<! res1) :cool))
              (done))))))
#+END_SRC

*** Async Fixtures
  :PROPERTIES:
  :CUSTOM_ID: async-fixtures
  :END:

Often establishing your testing environment means you need your fixtures to be asynchronous too. This is easily accomplished:

#+BEGIN_SRC clojure
    (use-fixtures :once
      {:before
       #(async done
          ...
          (done))
       :after
       #(do ...)})
#+END_SRC

In this case =:before= will need to complete before any test can run. =:after= will complete immediately after all tests have run since it does not use an async block.

*** Detecting Test Completion & Success
  :PROPERTIES:
  :CUSTOM_ID: detecting-test-completion-success
  :END:

Often it's useful to be able to run some code after all tests have completed successfully (or unsuccessfully). Because tests may run async =cljs.test/run-tests= does not return a meaningful value. You can however add a test report event listener by adding a method to the =cljs.test/report= multimethod.

#+BEGIN_SRC clojure
    (defmethod cljs.test/report [:cljs.test/default :end-run-tests] [m]
      (if (cljs.test/successful? m)
        (println "Success!")
        (println "FAIL")))
#+END_SRC

** Tools
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/tools.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/tools
:CLOJURESCRIPT_SITE_AUTHOR: Alex Miller
:CLOJURESCRIPT_SITE_DATE: 2020-04-13
:CUSTOM_ID: content/tools/tools
:END:
*** Testing
  :PROPERTIES:
  :CUSTOM_ID: _testing
  :END:

-  [[file:testing][Testing]]

*** Editors
  :PROPERTIES:
  :CUSTOM_ID: _editors
  :END:

-  [[file:cursive][Cursive]]

-  [[file:emacs-inf][Emacs Inferior Clojure]]

-  [[file:vscode][VS Code]]

-  [[file:light-table][Light Table]]

-  [[file:sublime][Sublime Text 2]]

-  [[file:vim][Vim]]

-  [[file:atom][Atom]]

*** Build Tools
  :PROPERTIES:
  :CUSTOM_ID: _build_tools
  :END:

-  [[file:shadow-cljs]]

-  [[file:leiningen][Leiningen]]

-  [[https://github.com/emezeske/lein-cljsbuild][lein-cljsbuild]]

-  [[https://github.com/bhauman/lein-figwheel][lein-figwheel]]

** Vim
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/vim.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/vim
:CLOJURESCRIPT_SITE_AUTHOR: David Nolen
:CLOJURESCRIPT_SITE_DATE: 2016-08-02
:CUSTOM_ID: content/tools/vim
:END:
*** Paredit
  :PROPERTIES:
  :CUSTOM_ID: paredit
  :END:

Emacs users are used to the paredit plugin that makes it easy to keep parenthesis balanced. Vim users can get the same effect with [[http://www.vim.org/scripts/script.php?script_id=3998][paredit.vim]].

*** Multi-repl, single environment, evaluating forms from Vim
  :PROPERTIES:
  :CUSTOM_ID: multi-repl-single-environment-evaluating-forms-from-vim
  :END:

**** Dependencies
   :PROPERTIES:
   :CUSTOM_ID: dependencies
   :END:

-  Install Tmux

-  Install [[http://www.vim.org/scripts/script.php?script_id=3023][tslime.vim]]

-  Install Leiningen plugin: [[https://github.com/franks42/lein-repls][lein-repls]]

-  Also install the =cljsh= script on your path

**** Configure Lein repl
   :PROPERTIES:
   :CUSTOM_ID: configure-lein-repl
   :END:

In =project.clj= add:

#+BEGIN_SRC clojure
      :repl-init myapp.repl
#+END_SRC

In =src/clj/myapp/repl.clj=:

#+BEGIN_SRC clojure
    (ns myapp.repl
      (:use [cljs.repl.browser :only (repl-env)])
      (:require [cljs.repl]))

    (defn repljs []
      (cljs.repl/repl (repl-env)))
#+END_SRC

**** Run repls
   :PROPERTIES:
   :CUSTOM_ID: run-repls
   :END:

-  Open two TMux sessions in your project root directory

-  Run =lein repls= in one of them

-  This is your "server" or "macros" or "clj" repl

-  Run =cljsh= in the other one

-  This is your "client" or "cljs" repl

-  Eval =(repljs)=

**** Connect VIM
   :PROPERTIES:
   :CUSTOM_ID: connect-vim
   :END:

-  Open two instances of Vim

-  One in your =src/clj= directory and one in =src/cljs= directory

-  Press =cc= in each, selecting the right TMux session when prompted

** Visual Studio Code
:PROPEPTIES:
:CLOJURESCRIPT_SITE_FILE: [[./clojurescript-site/content/tools/vscode.adoc]]
:CLOJURESCRIPT_SITE_PAGE: https://clojurescript.org/tools/vscode
:CLOJURESCRIPT_SITE_AUTHOR: Denis Baudinot
:CLOJURESCRIPT_SITE_DATE: 2021-07-11
:CUSTOM_ID: content/tools/vscode
:END:
[[https://code.visualstudio.com/][Visual Studio Code]] has Clojure and ClojureScript support via the [[https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva][Calva]] extension.

From the [[https://calva.io/][calva documentation]]:

#+BEGIN_QUOTE
  Calva is an integrated REPL powered environment for enjoyable and productive Clojure and ClojureScript development in Visual Studio Code. It includes inline code evaluation, Paredit, code formatting, a test runner, syntax highlighting, linting, and more. Calva is open source and free to use.
#+END_QUOTE
